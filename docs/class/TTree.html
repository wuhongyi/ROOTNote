

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="zh-CN" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="zh-CN" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>TTree &mdash; ROOT Note 1 文档</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script type="text/javascript" src="../_static/jquery.js"></script>
        <script type="text/javascript" src="../_static/underscore.js"></script>
        <script type="text/javascript" src="../_static/doctools.js"></script>
        <script type="text/javascript" src="../_static/language_data.js"></script>
        <script type="text/javascript" src="../_static/translations.js"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/graphviz.css" type="text/css" />
    <link rel="index" title="索引" href="../genindex.html" />
    <link rel="search" title="搜索" href="../search.html" />
    <link rel="next" title="TCut" href="TCut.html" />
    <link rel="prev" title="TXMLFile" href="TXMLFile.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html" class="icon icon-home"> ROOT Note
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">简介</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../README.html">简介</a></li>
</ul>
<p class="caption"><span class="caption-text">base类的使用</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="README.html">类的使用</a></li>
<li class="toctree-l1"><a class="reference internal" href="TObject.html">TObject</a></li>
<li class="toctree-l1"><a class="reference internal" href="TTask.html">TTask</a></li>
<li class="toctree-l1"><a class="reference internal" href="Buttons.html">Buttons</a></li>
<li class="toctree-l1"><a class="reference internal" href="TNamed.html">TNamed</a></li>
<li class="toctree-l1"><a class="reference internal" href="TStyle.html">TStyle</a></li>
<li class="toctree-l1"><a class="reference internal" href="TSystem.html">TSystem</a></li>
<li class="toctree-l1"><a class="reference internal" href="TROOT.html">TROOT</a></li>
<li class="toctree-l1"><a class="reference internal" href="TFolder.html">TFolder</a></li>
<li class="toctree-l1"><a class="reference internal" href="TEnv.html">TEnv</a></li>
<li class="toctree-l1"><a class="reference internal" href="TMacro.html">TMacro</a></li>
<li class="toctree-l1"><a class="reference internal" href="TApplication.html">TApplication</a></li>
<li class="toctree-l1"><a class="reference internal" href="TProcessID.html">TProcessID</a></li>
<li class="toctree-l1"><a class="reference internal" href="TProcessUUID.html">TProcessUUID</a></li>
<li class="toctree-l1"><a class="reference internal" href="TString.html">TString</a></li>
<li class="toctree-l1"><a class="reference internal" href="TColor.html">TColor</a></li>
<li class="toctree-l1"><a class="reference internal" href="TBase64.html">TBase64</a></li>
<li class="toctree-l1"><a class="reference internal" href="TMD5.html">TMD5</a></li>
</ul>
<p class="caption"><span class="caption-text">IO类的使用</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="README.html">类的使用</a></li>
<li class="toctree-l1"><a class="reference internal" href="TKey.html">TKey</a></li>
<li class="toctree-l1"><a class="reference internal" href="TDirectory.html">TDirectory</a></li>
<li class="toctree-l1"><a class="reference internal" href="TDirectoryFile.html">TDirectoryFile</a></li>
<li class="toctree-l1"><a class="reference internal" href="TSystemFile.html">TSystemFile</a></li>
<li class="toctree-l1"><a class="reference internal" href="TSystemDirectory.html">TSystemDirectory</a></li>
<li class="toctree-l1"><a class="reference internal" href="TFile.html">TFile</a></li>
<li class="toctree-l1"><a class="reference internal" href="TFileCacheWrite.html">TFileCacheWrite</a></li>
<li class="toctree-l1"><a class="reference internal" href="TFileCacheRead.html">TFileCacheRead</a></li>
<li class="toctree-l1"><a class="reference internal" href="TFileMerger.html">TFileMerger</a></li>
<li class="toctree-l1"><a class="reference internal" href="TMemFile.html">TMemFile</a></li>
<li class="toctree-l1"><a class="reference internal" href="TKeyMapFile.html">TKeyMapFile</a></li>
<li class="toctree-l1"><a class="reference internal" href="TMapFile.html">TMapFile</a></li>
<li class="toctree-l1"><a class="reference internal" href="TArchiveFile.html">TArchiveFile</a></li>
<li class="toctree-l1"><a class="reference internal" href="TZIPFile.html">TZIPFile</a></li>
<li class="toctree-l1"><a class="reference internal" href="TFilePrefetch.html">TFilePrefetch</a></li>
<li class="toctree-l1"><a class="reference internal" href="TFPBlock.html">TFPBlock</a></li>
<li class="toctree-l1"><a class="reference internal" href="THDFSFile.html">THDFSFile</a></li>
<li class="toctree-l1"><a class="reference internal" href="TBuffer.html">TBuffer</a></li>
<li class="toctree-l1"><a class="reference internal" href="TBufferFile.html">TBufferFile</a></li>
<li class="toctree-l1"><a class="reference internal" href="TBufferJSON.html">TBufferJSON</a></li>
<li class="toctree-l1"><a class="reference internal" href="TKeySQL.html">TKeySQL</a></li>
<li class="toctree-l1"><a class="reference internal" href="TSQLObjectData.html">TSQLObjectData</a></li>
<li class="toctree-l1"><a class="reference internal" href="TSQLStructure.html">TSQLStructure</a></li>
<li class="toctree-l1"><a class="reference internal" href="TSQLClassInfo.html">TSQLClassInfo</a></li>
<li class="toctree-l1"><a class="reference internal" href="TBufferSQL2.html">TBufferSQL2</a></li>
<li class="toctree-l1"><a class="reference internal" href="TSQLFile.html">TSQLFile</a></li>
<li class="toctree-l1"><a class="reference internal" href="TXMLEngine.html">TXMLEngine</a></li>
<li class="toctree-l1"><a class="reference internal" href="TBufferXML.html">TBufferXML</a></li>
<li class="toctree-l1"><a class="reference internal" href="TXMLSetup.html">TXMLSetup</a></li>
<li class="toctree-l1"><a class="reference internal" href="TKeyXML.html">TKeyXML</a></li>
<li class="toctree-l1"><a class="reference internal" href="TXMLPlayer.html">TXMLPlayer</a></li>
<li class="toctree-l1"><a class="reference internal" href="TXMLFile.html">TXMLFile</a></li>
</ul>
<p class="caption"><span class="caption-text">常用类的使用</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="README.html">类的使用</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">TTree</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#function-scan">function Scan()</a></li>
<li class="toctree-l2"><a class="reference internal" href="#function-draw">function Draw()</a></li>
<li class="toctree-l2"><a class="reference internal" href="#class">class</a></li>
<li class="toctree-l2"><a class="reference internal" href="#code">code</a></li>
<li class="toctree-l2"><a class="reference internal" href="#example">example</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="TCut.html">TCut</a></li>
<li class="toctree-l1"><a class="reference internal" href="TTreePlayer.html">TTreePlayer</a></li>
<li class="toctree-l1"><a class="reference internal" href="TChain.html">TChain</a></li>
<li class="toctree-l1"><a class="reference internal" href="TEventList.html">TEventList</a></li>
<li class="toctree-l1"><a class="reference internal" href="TBranch.html">TBranch</a></li>
<li class="toctree-l1"><a class="reference internal" href="TNtuple.html">TNtuple</a></li>
<li class="toctree-l1"><a class="reference internal" href="TNtupleD.html">TNtupleD</a></li>
<li class="toctree-l1"><a class="reference internal" href="TCollection.html">TCollection</a></li>
<li class="toctree-l1"><a class="reference internal" href="TSeqCollection.html">TSeqCollection</a></li>
<li class="toctree-l1"><a class="reference internal" href="TList.html">TList</a></li>
<li class="toctree-l1"><a class="reference internal" href="TVirtualFitter.html">TVirtualFitter</a></li>
<li class="toctree-l1"><a class="reference internal" href="TBackCompFitter.html">TBackCompFitter</a></li>
<li class="toctree-l1"><a class="reference internal" href="FitResult.html">FitResult</a></li>
<li class="toctree-l1"><a class="reference internal" href="TFitter.html">TFitter</a></li>
<li class="toctree-l1"><a class="reference internal" href="TFitResult.html">TFitResult</a></li>
<li class="toctree-l1"><a class="reference internal" href="TFitResultPtr.html">TFitResultPtr</a></li>
<li class="toctree-l1"><a class="reference internal" href="TFractionFitter.html">TFractionFitter</a></li>
<li class="toctree-l1"><a class="reference internal" href="TLinearFitter.html">TLinearFitter</a></li>
<li class="toctree-l1"><a class="reference internal" href="TAttAxis.html">TAttAxis</a></li>
<li class="toctree-l1"><a class="reference internal" href="TAxis.html">TAxis</a></li>
<li class="toctree-l1"><a class="reference internal" href="TGaxis.html">TGaxis</a></li>
<li class="toctree-l1"><a class="reference internal" href="TGaxis.html#example">example</a></li>
<li class="toctree-l1"><a class="reference internal" href="TText.html">TText</a></li>
<li class="toctree-l1"><a class="reference internal" href="TPaveStats.html">TPaveStats</a></li>
<li class="toctree-l1"><a class="reference internal" href="TPolyMarker.html">TPolyMarker</a></li>
<li class="toctree-l1"><a class="reference internal" href="TPaveText.html">TPaveText</a></li>
<li class="toctree-l1"><a class="reference internal" href="TPolyMarker3D.html">TPolyMarker3D</a></li>
<li class="toctree-l1"><a class="reference internal" href="TLatex.html">TLatex</a></li>
<li class="toctree-l1"><a class="reference internal" href="TLegend.html">TLegend</a></li>
<li class="toctree-l1"><a class="reference internal" href="TLegendEntry.html">TLegendEntry</a></li>
<li class="toctree-l1"><a class="reference internal" href="TLine.html">TLine</a></li>
<li class="toctree-l1"><a class="reference internal" href="TVirtualPad.html">TVirtualPad</a></li>
<li class="toctree-l1"><a class="reference internal" href="TPad.html">TPad</a></li>
<li class="toctree-l1"><a class="reference internal" href="TCanvas.html">TCanvas</a></li>
<li class="toctree-l1"><a class="reference internal" href="TF1.html">TF1</a></li>
<li class="toctree-l1"><a class="reference internal" href="TF2.html">TF2</a></li>
<li class="toctree-l1"><a class="reference internal" href="TF3.html">TF3</a></li>
<li class="toctree-l1"><a class="reference internal" href="TGraph.html">TGraph</a></li>
<li class="toctree-l1"><a class="reference internal" href="TCutG.html">TCutG</a></li>
<li class="toctree-l1"><a class="reference internal" href="TMultiGraph.html">TMultiGraph</a></li>
<li class="toctree-l1"><a class="reference internal" href="TGraph2D.html">TGraph2D</a></li>
<li class="toctree-l1"><a class="reference internal" href="TGraph2DErrors.html">TGraph2DErrors</a></li>
<li class="toctree-l1"><a class="reference internal" href="TGraphErrors.html">TGraphErrors</a></li>
<li class="toctree-l1"><a class="reference internal" href="TGraphPolar.html">TGraphPolar</a></li>
<li class="toctree-l1"><a class="reference internal" href="TH1.html">TH1</a></li>
<li class="toctree-l1"><a class="reference internal" href="TH2.html">TH2</a></li>
<li class="toctree-l1"><a class="reference internal" href="TH2Poly.html">TH2Poly</a></li>
<li class="toctree-l1"><a class="reference internal" href="TH3.html">TH3</a></li>
<li class="toctree-l1"><a class="reference internal" href="TProfile.html">TProfile</a></li>
<li class="toctree-l1"><a class="reference internal" href="TProfile2D.html">TProfile2D</a></li>
<li class="toctree-l1"><a class="reference internal" href="TProfile3D.html">TProfile3D</a></li>
<li class="toctree-l1"><a class="reference internal" href="TMath.html">TMath</a></li>
<li class="toctree-l1"><a class="reference internal" href="TMathBase.html">TMathBase</a></li>
<li class="toctree-l1"><a class="reference internal" href="TMatrixT.html">TMatrixT</a></li>
<li class="toctree-l1"><a class="reference internal" href="TMatrixTBase.html">TMatrixTBase</a></li>
<li class="toctree-l1"><a class="reference internal" href="TMatrixTSparse.html">TMatrixTSparse</a></li>
<li class="toctree-l1"><a class="reference internal" href="TMatrixTSym.html">TMatrixTSym</a></li>
<li class="toctree-l1"><a class="reference internal" href="TSpline.html">TSpline</a></li>
<li class="toctree-l1"><a class="reference internal" href="TMinuit.html">TMinuit</a></li>
<li class="toctree-l1"><a class="reference internal" href="TMinuitMinimizer.html">TMinuitMinimizer</a></li>
<li class="toctree-l1"><a class="reference internal" href="TRandom.html">TRandom</a></li>
<li class="toctree-l1"><a class="reference internal" href="TRandom1.html">TRandom1</a></li>
<li class="toctree-l1"><a class="reference internal" href="TRandom2.html">TRandom2</a></li>
<li class="toctree-l1"><a class="reference internal" href="TRandom3.html">TRandom3</a></li>
<li class="toctree-l1"><a class="reference internal" href="TSelector.html">TSelector</a></li>
<li class="toctree-l1"><a class="reference internal" href="TSelectorCint.html">TSelectorCint</a></li>
<li class="toctree-l1"><a class="reference internal" href="TSelectorDraw.html">TSelectorDraw</a></li>
<li class="toctree-l1"><a class="reference internal" href="TSelectorEntries.html">TSelectorEntries</a></li>
<li class="toctree-l1"><a class="reference internal" href="TSelectorList.html">TSelectorList</a></li>
<li class="toctree-l1"><a class="reference internal" href="TSelectorScalar.html">TSelectorScalar</a></li>
<li class="toctree-l1"><a class="reference internal" href="TSpectrum.html">TSpectrum</a></li>
<li class="toctree-l1"><a class="reference internal" href="TSpectrum2.html">TSpectrum2</a></li>
<li class="toctree-l1"><a class="reference internal" href="TSpectrum2Fit.html">TSpectrum2Fit</a></li>
<li class="toctree-l1"><a class="reference internal" href="TSpectrum2Painter.html">TSpectrum2Painter</a></li>
<li class="toctree-l1"><a class="reference internal" href="TSpectrum2Transform.html">TSpectrum2Transform</a></li>
<li class="toctree-l1"><a class="reference internal" href="TSpectrum3.html">TSpectrum3</a></li>
<li class="toctree-l1"><a class="reference internal" href="TSpectrumFit.html">TSpectrumFit</a></li>
<li class="toctree-l1"><a class="reference internal" href="TSpectrumTransform.html">TSpectrumTransform</a></li>
<li class="toctree-l1"><a class="reference internal" href="TTime.html">TTime</a></li>
<li class="toctree-l1"><a class="reference internal" href="TTimer.html">TTimer</a></li>
<li class="toctree-l1"><a class="reference internal" href="TTimeStamp.html">TTimeStamp</a></li>
<li class="toctree-l1"><a class="reference internal" href="TStopwatch.html">TStopwatch</a></li>
<li class="toctree-l1"><a class="reference internal" href="TBenchmark.html">TBenchmark</a></li>
<li class="toctree-l1"><a class="reference internal" href="TThread.html">TThread</a></li>
<li class="toctree-l1"><a class="reference internal" href="TThreadFactory.html">TThreadFactory</a></li>
<li class="toctree-l1"><a class="reference internal" href="TThreadImp.html">TThreadImp</a></li>
<li class="toctree-l1"><a class="reference internal" href="TServerSocket.html">TServerSocket</a></li>
<li class="toctree-l1"><a class="reference internal" href="TSocket.html">TSocket</a></li>
<li class="toctree-l1"><a class="reference internal" href="TPServerSocket.html">TPServerSocket</a></li>
<li class="toctree-l1"><a class="reference internal" href="TPSocket.html">TPSocket</a></li>
<li class="toctree-l1"><a class="reference internal" href="TEllipse.html">TEllipse</a></li>
<li class="toctree-l1"><a class="reference internal" href="TNeuron.html">TNeuron</a></li>
<li class="toctree-l1"><a class="reference internal" href="TMLPAnalyzer.html">TMLPAnalyzer</a></li>
<li class="toctree-l1"><a class="reference internal" href="TMonitor.html">TMonitor</a></li>
<li class="toctree-l1"><a class="reference internal" href="TMultiLayerPerceptron.html">TMultiLayerPerceptron</a></li>
</ul>
<p class="caption"><span class="caption-text">图形界面的使用</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="gui/README.html">README</a></li>
<li class="toctree-l1"><a class="reference internal" href="gui/GuiTypes.html">GuiTypes</a></li>
<li class="toctree-l1"><a class="reference internal" href="gui/TGButton.html">TGButton</a></li>
<li class="toctree-l1"><a class="reference internal" href="gui/TGButtonGroup.html">TGButtonGroup</a></li>
<li class="toctree-l1"><a class="reference internal" href="gui/TGCanvas.html">TGCanvas</a></li>
<li class="toctree-l1"><a class="reference internal" href="gui/TGClient.html">TGClient</a></li>
<li class="toctree-l1"><a class="reference internal" href="gui/TGColorDialog.html">TGColorDialog</a></li>
<li class="toctree-l1"><a class="reference internal" href="gui/TGColorSelect.html">TGColorSelect</a></li>
<li class="toctree-l1"><a class="reference internal" href="gui/TGComboBox.html">TGComboBox</a></li>
<li class="toctree-l1"><a class="reference internal" href="gui/TGCommandPlugin.html">TGCommandPlugin</a></li>
<li class="toctree-l1"><a class="reference internal" href="gui/TGDimension.html">TGDimension</a></li>
<li class="toctree-l1"><a class="reference internal" href="gui/TGDNDManager.html">TGDNDManager</a></li>
<li class="toctree-l1"><a class="reference internal" href="gui/TGDockableFrame.html">TGDockableFrame</a></li>
<li class="toctree-l1"><a class="reference internal" href="gui/TGDoubleSlider.html">TGDoubleSlider</a></li>
<li class="toctree-l1"><a class="reference internal" href="gui/TGEventHandler.html">TGEventHandler</a></li>
<li class="toctree-l1"><a class="reference internal" href="gui/TGFileBrowser.html">TGFileBrowser</a></li>
<li class="toctree-l1"><a class="reference internal" href="gui/TGFileDialog.html">TGFileDialog</a></li>
<li class="toctree-l1"><a class="reference internal" href="gui/TGFont.html">TGFont</a></li>
<li class="toctree-l1"><a class="reference internal" href="gui/TGFontDialog.html">TGFontDialog</a></li>
<li class="toctree-l1"><a class="reference internal" href="gui/TGFrame.html">TGFrame</a></li>
<li class="toctree-l1"><a class="reference internal" href="gui/TGFSComboBox.html">TGFSComboBox</a></li>
<li class="toctree-l1"><a class="reference internal" href="gui/TGFSContainer.html">TGFSContainer</a></li>
<li class="toctree-l1"><a class="reference internal" href="gui/TGGC.html">TGGC</a></li>
<li class="toctree-l1"><a class="reference internal" href="gui/TGIcon.html">TGIcon</a></li>
<li class="toctree-l1"><a class="reference internal" href="gui/TGIdleHandler.html">TGIdleHandler</a></li>
<li class="toctree-l1"><a class="reference internal" href="gui/TGImageMap.html">TGImageMap</a></li>
<li class="toctree-l1"><a class="reference internal" href="gui/TGInputDialog.html">TGInputDialog</a></li>
<li class="toctree-l1"><a class="reference internal" href="gui/TGLabel.html">TGLabel</a></li>
<li class="toctree-l1"><a class="reference internal" href="gui/TGLayout.html">TGLayout</a></li>
<li class="toctree-l1"><a class="reference internal" href="gui/TGListBox.html">TGListBox</a></li>
<li class="toctree-l1"><a class="reference internal" href="gui/TGListTree.html">TGListTree</a></li>
<li class="toctree-l1"><a class="reference internal" href="gui/TGListView.html">TGListView</a></li>
<li class="toctree-l1"><a class="reference internal" href="gui/TGMdiDecorFrame.html">TGMdiDecorFrame</a></li>
<li class="toctree-l1"><a class="reference internal" href="gui/TGMdiFrame.html">TGMdiFrame</a></li>
<li class="toctree-l1"><a class="reference internal" href="gui/TGMdiMainFrame.html">TGMdiMainFrame</a></li>
<li class="toctree-l1"><a class="reference internal" href="gui/TGMdiMenu.html">TGMdiMenu</a></li>
<li class="toctree-l1"><a class="reference internal" href="gui/TGMenu.html">TGMenu</a></li>
<li class="toctree-l1"><a class="reference internal" href="gui/TGMimeTypes.html">TGMimeTypes</a></li>
<li class="toctree-l1"><a class="reference internal" href="gui/TGMsgBox.html">TGMsgBox</a></li>
<li class="toctree-l1"><a class="reference internal" href="gui/TGNumberEntry.html">TGNumberEntry</a></li>
<li class="toctree-l1"><a class="reference internal" href="gui/TGObject.html">TGObject</a></li>
<li class="toctree-l1"><a class="reference internal" href="gui/TGPack.html">TGPack</a></li>
<li class="toctree-l1"><a class="reference internal" href="gui/TGPasswdDialog.html">TGPasswdDialog</a></li>
<li class="toctree-l1"><a class="reference internal" href="gui/TGPicture.html">TGPicture</a></li>
<li class="toctree-l1"><a class="reference internal" href="gui/TGProgressBar.html">TGProgressBar</a></li>
<li class="toctree-l1"><a class="reference internal" href="gui/TGRedirectOutputGuard.html">TGRedirectOutputGuard</a></li>
<li class="toctree-l1"><a class="reference internal" href="gui/TGResourcePool.html">TGResourcePool</a></li>
<li class="toctree-l1"><a class="reference internal" href="gui/TGScrollBar.html">TGScrollBar</a></li>
<li class="toctree-l1"><a class="reference internal" href="gui/TGShapedFrame.html">TGShapedFrame</a></li>
<li class="toctree-l1"><a class="reference internal" href="gui/TGShutter.html">TGShutter</a></li>
<li class="toctree-l1"><a class="reference internal" href="gui/TGSimpleTable.html">TGSimpleTable</a></li>
<li class="toctree-l1"><a class="reference internal" href="gui/TGSimpleTableInterface.html">TGSimpleTableInterface</a></li>
<li class="toctree-l1"><a class="reference internal" href="gui/TGSlider.html">TGSlider</a></li>
<li class="toctree-l1"><a class="reference internal" href="gui/TGSpeedo.html">TGSpeedo</a></li>
<li class="toctree-l1"><a class="reference internal" href="gui/TGSplitFrame.html">TGSplitFrame</a></li>
<li class="toctree-l1"><a class="reference internal" href="gui/TGSplitter.html">TGSplitter</a></li>
<li class="toctree-l1"><a class="reference internal" href="gui/TGStatusBar.html">TGStatusBar</a></li>
<li class="toctree-l1"><a class="reference internal" href="gui/TGString.html">TGString</a></li>
<li class="toctree-l1"><a class="reference internal" href="gui/TGTab.html">TGTab</a></li>
<li class="toctree-l1"><a class="reference internal" href="gui/TGTable.html">TGTable</a></li>
<li class="toctree-l1"><a class="reference internal" href="gui/TGTableCell.html">TGTableCell</a></li>
<li class="toctree-l1"><a class="reference internal" href="gui/TGTableContainer.html">TGTableContainer</a></li>
<li class="toctree-l1"><a class="reference internal" href="gui/TGTableHeader.html">TGTableHeader</a></li>
<li class="toctree-l1"><a class="reference internal" href="gui/TGTableLayout.html">TGTableLayout</a></li>
<li class="toctree-l1"><a class="reference internal" href="gui/TGText.html">TGText</a></li>
<li class="toctree-l1"><a class="reference internal" href="gui/TGTextBuffer.html">TGTextBuffer</a></li>
<li class="toctree-l1"><a class="reference internal" href="gui/TGTextEdit.html">TGTextEdit</a></li>
<li class="toctree-l1"><a class="reference internal" href="gui/TGTextEditDialogs.html">TGTextEditDialogs</a></li>
<li class="toctree-l1"><a class="reference internal" href="gui/TGTextEditor.html">TGTextEditor</a></li>
<li class="toctree-l1"><a class="reference internal" href="gui/TGTextEntry.html">TGTextEntry</a></li>
<li class="toctree-l1"><a class="reference internal" href="gui/TGTextView.html">TGTextView</a></li>
<li class="toctree-l1"><a class="reference internal" href="gui/TGTextViewStream.html">TGTextViewStream</a></li>
<li class="toctree-l1"><a class="reference internal" href="gui/TGToolBar.html">TGToolBar</a></li>
<li class="toctree-l1"><a class="reference internal" href="gui/TGToolTip.html">TGToolTip</a></li>
<li class="toctree-l1"><a class="reference internal" href="gui/TGTripleSlider.html">TGTripleSlider</a></li>
<li class="toctree-l1"><a class="reference internal" href="gui/TGuiBuilder.html">TGuiBuilder</a></li>
<li class="toctree-l1"><a class="reference internal" href="gui/TGView.html">TGView</a></li>
<li class="toctree-l1"><a class="reference internal" href="gui/TGWidget.html">TGWidget</a></li>
<li class="toctree-l1"><a class="reference internal" href="gui/TGWindow.html">TGWindow</a></li>
<li class="toctree-l1"><a class="reference internal" href="gui/TGXYLayout.html">TGXYLayout</a></li>
<li class="toctree-l1"><a class="reference internal" href="gui/TQObject.html">TQObject</a></li>
<li class="toctree-l1"><a class="reference internal" href="gui/TRootEmbeddedCanvas.html">TRootEmbeddedCanvas</a></li>
</ul>
<p class="caption"><span class="caption-text">GRAF3D</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="graf3d/README.html">README</a></li>
<li class="toctree-l1"><a class="reference internal" href="graf3d/TAxis3D.html">TAxis3D</a></li>
<li class="toctree-l1"><a class="reference internal" href="graf3d/TBRIK.html">TBRIK</a></li>
<li class="toctree-l1"><a class="reference internal" href="graf3d/TCONE.html">TCONE</a></li>
<li class="toctree-l1"><a class="reference internal" href="graf3d/TCONS.html">TCONS</a></li>
<li class="toctree-l1"><a class="reference internal" href="graf3d/TCTUB.html">TCTUB</a></li>
<li class="toctree-l1"><a class="reference internal" href="graf3d/TELTU.html">TELTU</a></li>
<li class="toctree-l1"><a class="reference internal" href="graf3d/TGeometry.html">TGeometry</a></li>
<li class="toctree-l1"><a class="reference internal" href="graf3d/TGTRA.html">TGTRA</a></li>
<li class="toctree-l1"><a class="reference internal" href="graf3d/THelix.html">THelix</a></li>
<li class="toctree-l1"><a class="reference internal" href="graf3d/THYPE.html">THYPE</a></li>
<li class="toctree-l1"><a class="reference internal" href="graf3d/TMarker3DBox.html">TMarker3DBox</a></li>
<li class="toctree-l1"><a class="reference internal" href="graf3d/TMaterial.html">TMaterial</a></li>
<li class="toctree-l1"><a class="reference internal" href="graf3d/TMixture.html">TMixture</a></li>
<li class="toctree-l1"><a class="reference internal" href="graf3d/TNodeDiv.html">TNodeDiv</a></li>
<li class="toctree-l1"><a class="reference internal" href="graf3d/TNode.html">TNode</a></li>
<li class="toctree-l1"><a class="reference internal" href="graf3d/TPARA.html">TPARA</a></li>
<li class="toctree-l1"><a class="reference internal" href="graf3d/TPCON.html">TPCON</a></li>
<li class="toctree-l1"><a class="reference internal" href="graf3d/TPGON.html">TPGON</a></li>
<li class="toctree-l1"><a class="reference internal" href="graf3d/TPoints3DABC.html">TPoints3DABC</a></li>
<li class="toctree-l1"><a class="reference internal" href="graf3d/TPointSet3D.html">TPointSet3D</a></li>
<li class="toctree-l1"><a class="reference internal" href="graf3d/TPolyLine3D.html">TPolyLine3D</a></li>
<li class="toctree-l1"><a class="reference internal" href="graf3d/TPolyMarker3D.html">TPolyMarker3D</a></li>
<li class="toctree-l1"><a class="reference internal" href="graf3d/TRotMatrix.html">TRotMatrix</a></li>
<li class="toctree-l1"><a class="reference internal" href="graf3d/TShape.html">TShape</a></li>
<li class="toctree-l1"><a class="reference internal" href="graf3d/TSPHE.html">TSPHE</a></li>
<li class="toctree-l1"><a class="reference internal" href="graf3d/TTRAP.html">TTRAP</a></li>
<li class="toctree-l1"><a class="reference internal" href="graf3d/TTRD1.html">TTRD1</a></li>
<li class="toctree-l1"><a class="reference internal" href="graf3d/TTRD2.html">TTRD2</a></li>
<li class="toctree-l1"><a class="reference internal" href="graf3d/TTUBE.html">TTUBE</a></li>
<li class="toctree-l1"><a class="reference internal" href="graf3d/TTUBS.html">TTUBS</a></li>
<li class="toctree-l1"><a class="reference internal" href="graf3d/TView3D.html">TView3D</a></li>
<li class="toctree-l1"><a class="reference internal" href="graf3d/TXTRU.html">TXTRU</a></li>
<li class="toctree-l1"><a class="reference internal" href="graf3d/X3DBuffer.html">X3DBuffer</a></li>
</ul>
<p class="caption"><span class="caption-text">physics</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="math/README.html">README</a></li>
<li class="toctree-l1"><a class="reference internal" href="math/TFeldmanCousins.html">TFeldmanCousins</a></li>
<li class="toctree-l1"><a class="reference internal" href="math/TGenPhaseSpace.html">TGenPhaseSpace</a></li>
<li class="toctree-l1"><a class="reference internal" href="math/TLorentzRotation.html">TLorentzRotation</a></li>
<li class="toctree-l1"><a class="reference internal" href="math/TLorentzVector.html">TLorentzVector</a></li>
<li class="toctree-l1"><a class="reference internal" href="math/TQuaternion.html">TQuaternion</a></li>
<li class="toctree-l1"><a class="reference internal" href="math/TRobustEstimator.html">TRobustEstimator</a></li>
<li class="toctree-l1"><a class="reference internal" href="math/TRolke.html">TRolke</a></li>
<li class="toctree-l1"><a class="reference internal" href="math/TRotation.html">TRotation</a></li>
<li class="toctree-l1"><a class="reference internal" href="math/TVectorT.html">TVectorT</a></li>
<li class="toctree-l1"><a class="reference internal" href="math/TVector2.html">TVector2</a></li>
<li class="toctree-l1"><a class="reference internal" href="math/TVector3.html">TVector3</a></li>
</ul>
<p class="caption"><span class="caption-text">net</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="net/README.html">README</a></li>
<li class="toctree-l1"><a class="reference internal" href="net/TCivetweb.html">TCivetweb</a></li>
<li class="toctree-l1"><a class="reference internal" href="net/TFastCgi.html">TFastCgi</a></li>
<li class="toctree-l1"><a class="reference internal" href="net/THttpCallArg.html">THttpCallArg</a></li>
<li class="toctree-l1"><a class="reference internal" href="net/THttpEngine.html">THttpEngine</a></li>
<li class="toctree-l1"><a class="reference internal" href="net/THttpServer.html">THttpServer</a></li>
<li class="toctree-l1"><a class="reference internal" href="net/THttpWSEngine.html">THttpWSEngine</a></li>
<li class="toctree-l1"><a class="reference internal" href="net/THttpWSHandler.html">THttpWSHandler</a></li>
<li class="toctree-l1"><a class="reference internal" href="net/TRootSniffer.html">TRootSniffer</a></li>
<li class="toctree-l1"><a class="reference internal" href="net/TRootSnifferStore.html">TRootSnifferStore</a></li>
</ul>
<p class="caption"><span class="caption-text">数据结构</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../structure/README.html">数据结构</a></li>
<li class="toctree-l1"><a class="reference internal" href="../structure/datarecord.html">datarecord</a></li>
<li class="toctree-l1"><a class="reference internal" href="../structure/dobject.html">dataobject</a></li>
<li class="toctree-l1"><a class="reference internal" href="../structure/freesegments.html">FreeSegments</a></li>
<li class="toctree-l1"><a class="reference internal" href="../structure/gap.html">gap</a></li>
<li class="toctree-l1"><a class="reference internal" href="../structure/header.html">header</a></li>
<li class="toctree-l1"><a class="reference internal" href="../structure/keyslist.html">KeysList</a></li>
<li class="toctree-l1"><a class="reference internal" href="../structure/StreamerInfo.html">StreamerInfo</a></li>
<li class="toctree-l1"><a class="reference internal" href="../structure/TClonesArray.html">TClonesArray</a></li>
<li class="toctree-l1"><a class="reference internal" href="../structure/TDirectory.html">TDirectory</a></li>
<li class="toctree-l1"><a class="reference internal" href="../structure/TFile.html">TFile</a></li>
<li class="toctree-l1"><a class="reference internal" href="../structure/TObject.html">TObject</a></li>
<li class="toctree-l1"><a class="reference internal" href="../structure/TProcessID.html">TProcessID</a></li>
<li class="toctree-l1"><a class="reference internal" href="../structure/TRefArray.html">TRefArray</a></li>
<li class="toctree-l1"><a class="reference internal" href="../structure/TRef.html">TRef</a></li>
<li class="toctree-l1"><a class="reference internal" href="../structure/TTree.html">TTree</a></li>
</ul>
<p class="caption"><span class="caption-text">预定义</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../define/README.html">预定义</a></li>
<li class="toctree-l1"><a class="reference internal" href="../define/RVersion.html">RVersion</a></li>
</ul>
<p class="caption"><span class="caption-text">文件版本</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../version/version.html">文件更新版本</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">ROOT Note</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html">Docs</a> &raquo;</li>
        
      <li>TTree</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../_sources/class/TTree.md.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <!-- TTree.md --- 
;; 
;; Description: 
;; Author: Hongyi Wu(吴鸿毅)
;; Email: wuhongyi@qq.com 
;; Created: 六 3月 14 08:35:28 2015 (+0800)
;; Last-Updated: 日 3月 31 18:50:01 2019 (+0800)
;;           By: Hongyi Wu(吴鸿毅)
;;     Update #: 11
;; URL: http://wuhongyi.cn --><div class="section" id="ttree">
<h1>TTree<a class="headerlink" href="#ttree" title="永久链接至标题">¶</a></h1>
<p>继承 TNamed, TAttLine, TAttFill, TAttMarker</p>
<p>A TTree object is a list of TBranch.
To Create a TTree object one must:</p>
<ul class="simple">
<li><p>Create the TTree header via the TTree constructor</p></li>
<li><p>Call the TBranch constructor for every branch.</p></li>
</ul>
<p>To Fill this object, use member function Fill with no parameters.
The Fill function loops on all defined TBranch.</p>
<div class="section" id="function-scan">
<h2>function Scan()<a class="headerlink" href="#function-scan" title="永久链接至标题">¶</a></h2>
<p>The options string can contains the following parameters:</p>
<ul class="simple">
<li><p>lenmax=dd</p>
<ul>
<li><p>Where ‘dd’ is the maximum number of elements per array that should be printed.  If ‘dd’ is 0, all elements are printed (this is the default)</p></li>
</ul>
</li>
<li><p>colsize=ss</p>
<ul>
<li><p>Where ‘ss’ will be used as the default size for all the column. If this options is not specified, the default column size is 9</p></li>
</ul>
</li>
<li><p>precision=pp</p>
<ul>
<li><p>Where ‘pp’ will be used as the default ‘precision’ for the printing format.</p></li>
</ul>
</li>
<li><p>col=xxx</p>
<ul>
<li><p>Where ‘xxx’ is colon (:) delimited list of printing format for each column. The format string should follow the printf format specification.  The value given will be prefixed by % and, if no conversion specifier is given, will be suffixed by the letter g. before being passed to fprintf.  If no format is specified for a column, the default is used  (aka ${colsize}.${precision}g )</p></li>
</ul>
</li>
</ul>
</div>
<div class="section" id="function-draw">
<h2>function Draw()<a class="headerlink" href="#function-draw" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">Entry$</span></code>:</p>
<ul>
<li><p>A TTree::Draw formula can use the special variable <code class="docutils literal notranslate"><span class="pre">Entry$</span></code> to access the entry number being read.</p></li>
</ul>
</li>
</ul>
</div>
<div class="section" id="class">
<h2>class<a class="headerlink" href="#class" title="永久链接至标题">¶</a></h2>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span>   <span class="c1">// Used as the max value for any TTree range operation.</span>
   <span class="k">static</span> <span class="k">constexpr</span> <span class="n">Long64_t</span> <span class="n">kMaxEntries</span> <span class="o">=</span> <span class="n">TVirtualTreePlayer</span><span class="o">::</span><span class="n">kMaxEntries</span><span class="p">;</span>

   <span class="c1">// SetBranchAddress return values</span>
   <span class="k">enum</span> <span class="n">ESetBranchAddressStatus</span> <span class="p">{</span>
      <span class="n">kMissingBranch</span> <span class="o">=</span> <span class="o">-</span><span class="mi">5</span><span class="p">,</span>
      <span class="n">kInternalError</span> <span class="o">=</span> <span class="o">-</span><span class="mi">4</span><span class="p">,</span>
      <span class="n">kMissingCompiledCollectionProxy</span> <span class="o">=</span> <span class="o">-</span><span class="mi">3</span><span class="p">,</span>
      <span class="n">kMismatch</span> <span class="o">=</span> <span class="o">-</span><span class="mi">2</span><span class="p">,</span>
      <span class="n">kClassMismatch</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
      <span class="n">kMatch</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
      <span class="n">kMatchConversion</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
      <span class="n">kMatchConversionCollection</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
      <span class="n">kMakeClass</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span>
      <span class="n">kVoidPtr</span> <span class="o">=</span> <span class="mi">4</span><span class="p">,</span>
      <span class="n">kNoCheck</span> <span class="o">=</span> <span class="mi">5</span>
   <span class="p">};</span>

   <span class="c1">// TTree status bits</span>
   <span class="k">enum</span> <span class="p">{</span>
      <span class="n">kForceRead</span>   <span class="o">=</span> <span class="n">BIT</span><span class="p">(</span><span class="mi">11</span><span class="p">),</span>
      <span class="n">kCircular</span>    <span class="o">=</span> <span class="n">BIT</span><span class="p">(</span><span class="mi">12</span><span class="p">)</span>
   <span class="p">};</span>

   <span class="c1">// Split level modifier</span>
   <span class="k">enum</span> <span class="p">{</span>
      <span class="n">kSplitCollectionOfPointers</span> <span class="o">=</span> <span class="mi">100</span>
   <span class="p">};</span>

   <span class="k">class</span> <span class="nc">TClusterIterator</span>
   <span class="p">{</span>
   <span class="k">private</span><span class="o">:</span>
      <span class="n">TTree</span>    <span class="o">*</span><span class="n">fTree</span><span class="p">;</span>        <span class="c1">// TTree upon which we are iterating.</span>
      <span class="n">Int_t</span>    <span class="n">fClusterRange</span><span class="p">;</span> <span class="c1">// Which cluster range are we looking at.</span>
      <span class="n">Long64_t</span> <span class="n">fStartEntry</span><span class="p">;</span>   <span class="c1">// Where does the cluster start.</span>
      <span class="n">Long64_t</span> <span class="n">fNextEntry</span><span class="p">;</span>    <span class="c1">// Where does the cluster end (exclusive).</span>

      <span class="n">Long64_t</span> <span class="nf">GetEstimatedClusterSize</span><span class="p">();</span>

   <span class="k">protected</span><span class="o">:</span>
      <span class="k">friend</span> <span class="k">class</span> <span class="nc">TTree</span><span class="p">;</span>
      <span class="n">TClusterIterator</span><span class="p">(</span><span class="n">TTree</span> <span class="o">*</span><span class="n">tree</span><span class="p">,</span> <span class="n">Long64_t</span> <span class="n">firstEntry</span><span class="p">);</span>

   <span class="k">public</span><span class="o">:</span>
      <span class="c1">// Intentionally used the default copy constructor and default destructor</span>
      <span class="c1">// as the TClusterIterator does not own the TTree.</span>
      <span class="c1">//  TClusterIterator(const TClusterIterator&amp;);</span>
      <span class="c1">// ~TClusterIterator();</span>

      <span class="c1">// No public constructors, the iterator must be</span>
      <span class="c1">// created via TTree::GetClusterIterator</span>

      <span class="c1">// Move on to the next cluster and return the starting entry</span>
      <span class="c1">// of this next cluster</span>
      <span class="n">Long64_t</span> <span class="n">Next</span><span class="p">();</span>

      <span class="c1">// Return the start entry of the current cluster.</span>
      <span class="n">Long64_t</span> <span class="nf">GetStartEntry</span><span class="p">()</span> <span class="p">{</span>
         <span class="k">return</span> <span class="n">fStartEntry</span><span class="p">;</span>
      <span class="p">}</span>

      <span class="c1">// Return the first entry of the next cluster.</span>
      <span class="n">Long64_t</span> <span class="nf">GetNextEntry</span><span class="p">()</span> <span class="p">{</span>
         <span class="k">return</span> <span class="n">fNextEntry</span><span class="p">;</span>
      <span class="p">}</span>

      <span class="n">Long64_t</span> <span class="nf">operator</span><span class="p">()()</span> <span class="p">{</span> <span class="k">return</span> <span class="n">Next</span><span class="p">();</span> <span class="p">}</span>
   <span class="p">};</span>

   <span class="n">TTree</span><span class="p">();</span>
<span class="c1">/// Default constructor and I/O constructor.</span>
<span class="c1">/// Note: We do *not* insert ourself into the current directory.</span>

   <span class="n">TTree</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">name</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">title</span><span class="p">,</span> <span class="n">Int_t</span> <span class="n">splitlevel</span> <span class="o">=</span> <span class="mi">99</span><span class="p">);</span>
<span class="c1">/// Normal tree constructor.</span>
<span class="c1">/// The tree is created in the current directory.</span>
<span class="c1">/// Use the various functions Branch below to add branches to this tree.</span>
<span class="c1">/// If the first character of title is a &quot;/&quot;, the function assumes a folder name.</span>
<span class="c1">/// In this case, it creates automatically branches following the folder hierarchy.</span>
<span class="c1">/// splitlevel may be used in this case to control the split level.</span>

   <span class="k">virtual</span> <span class="o">~</span><span class="n">TTree</span><span class="p">();</span>

   <span class="k">virtual</span> <span class="n">Int_t</span>           <span class="nf">AddBranchToCache</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">bname</span><span class="p">,</span> <span class="n">Bool_t</span> <span class="n">subbranches</span> <span class="o">=</span> <span class="n">kFALSE</span><span class="p">);</span>
<span class="c1">/// Add branch with name bname to the Tree cache.</span>
<span class="c1">/// If bname=&quot;*&quot; all branches are added to the cache.</span>
<span class="c1">/// if subbranches is true all the branches of the subbranches are</span>
<span class="c1">/// also put to the cache.</span>
<span class="c1">/// Returns:</span>
<span class="c1">/// - 0 branch added or already included</span>
<span class="c1">/// - -1 on error</span>

   <span class="k">virtual</span> <span class="n">Int_t</span>           <span class="nf">AddBranchToCache</span><span class="p">(</span><span class="n">TBranch</span> <span class="o">*</span><span class="n">branch</span><span class="p">,</span>   <span class="n">Bool_t</span> <span class="n">subbranches</span> <span class="o">=</span> <span class="n">kFALSE</span><span class="p">);</span>
<span class="c1">/// Add branch b to the Tree cache.</span>
<span class="c1">/// if subbranches is true all the branches of the subbranches are</span>
<span class="c1">/// also put to the cache.</span>
<span class="c1">/// Returns:</span>
<span class="c1">/// - 0 branch added or already included</span>
<span class="c1">/// - -1 on error</span>

   <span class="k">virtual</span> <span class="n">Int_t</span>           <span class="nf">DropBranchFromCache</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">bname</span><span class="p">,</span> <span class="n">Bool_t</span> <span class="n">subbranches</span> <span class="o">=</span> <span class="n">kFALSE</span><span class="p">);</span>
<span class="c1">/// Remove the branch with name &#39;bname&#39; from the Tree cache.</span>
<span class="c1">/// If bname=&quot;*&quot; all branches are removed from the cache.</span>
<span class="c1">/// if subbranches is true all the branches of the subbranches are</span>
<span class="c1">/// also removed from the cache.</span>
<span class="c1">/// Returns:</span>
<span class="c1">/// - 0 branch dropped or not in cache</span>
<span class="c1">/// - -1 on error</span>

   <span class="k">virtual</span> <span class="n">Int_t</span>           <span class="nf">DropBranchFromCache</span><span class="p">(</span><span class="n">TBranch</span> <span class="o">*</span><span class="n">branch</span><span class="p">,</span>   <span class="n">Bool_t</span> <span class="n">subbranches</span> <span class="o">=</span> <span class="n">kFALSE</span><span class="p">);</span>
<span class="c1">/// Remove the branch b from the Tree cache.</span>
<span class="c1">/// if subbranches is true all the branches of the subbranches are</span>
<span class="c1">/// also removed from the cache.</span>
<span class="c1">/// Returns:</span>
<span class="c1">/// - 0 branch dropped or not in cache</span>
<span class="c1">/// - -1 on error</span>

   <span class="k">virtual</span> <span class="n">TFriendElement</span> <span class="o">*</span><span class="nf">AddFriend</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">treename</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">filename</span> <span class="o">=</span> <span class="s">&quot;&quot;</span><span class="p">);</span>
<span class="c1">/// Add a TFriendElement to the list of friends.</span>
<span class="c1">/// This function:</span>
<span class="c1">/// - opens a file if filename is specified</span>
<span class="c1">/// - reads a Tree with name treename from the file (current directory)</span>
<span class="c1">/// - adds the Tree to the list of friends</span>
<span class="c1">/// see other AddFriend functions</span>
<span class="c1">/// A TFriendElement TF describes a TTree object TF in a file.</span>
<span class="c1">/// When a TFriendElement TF is added to the the list of friends of an</span>
<span class="c1">/// existing TTree T, any variable from TF can be referenced in a query</span>
<span class="c1">/// to T.</span>
<span class="c1">///   A tree keeps a list of friends. In the context of a tree (or a chain),</span>
<span class="c1">/// friendship means unrestricted access to the friends data. In this way</span>
<span class="c1">/// it is much like adding another branch to the tree without taking the risk</span>
<span class="c1">/// of damaging it. To add a friend to the list, you can use the TTree::AddFriend</span>
<span class="c1">/// method.  The tree in the diagram below has two friends (friend_tree1 and</span>
<span class="c1">/// friend_tree2) and now has access to the variables a,b,c,i,j,k,l and m.</span>
<span class="c1">/// The AddFriend method has two parameters, the first is the tree name and the</span>
<span class="c1">/// second is the name of the ROOT file where the friend tree is saved.</span>
<span class="c1">/// AddFriend automatically opens the friend file. If no file name is given,</span>
<span class="c1">/// the tree called ft1 is assumed to be in the same file as the original tree.</span>
<span class="c1">/// tree.AddFriend(&quot;ft1&quot;,&quot;friendfile1.root&quot;);</span>
<span class="c1">/// If the friend tree has the same name as the original tree, you can give it</span>
<span class="c1">/// an alias in the context of the friendship:</span>
<span class="c1">/// tree.AddFriend(&quot;tree1 = tree&quot;,&quot;friendfile1.root&quot;);</span>
<span class="c1">/// Once the tree has friends, we can use TTree::Draw as if the friend&#39;s</span>
<span class="c1">/// variables were in the original tree. To specify which tree to use in</span>
<span class="c1">/// the Draw method, use the syntax:</span>
<span class="c1">/// ~~~ {.cpp}</span>
<span class="c1">///     &lt;treeName&gt;.&lt;branchname&gt;.&lt;varname&gt;</span>
<span class="c1">/// ~~~</span>
<span class="c1">/// If the variablename is enough to uniquely identify the variable, you can</span>
<span class="c1">/// leave out the tree and/or branch name.</span>
<span class="c1">/// For example, these commands generate a 3-d scatter plot of variable &quot;var&quot;</span>
<span class="c1">/// in the TTree tree versus variable v1 in TTree ft1 versus variable v2 in</span>
<span class="c1">/// TTree ft2.</span>
<span class="c1">/// ~~~ {.cpp}</span>
<span class="c1">///     tree.AddFriend(&quot;ft1&quot;,&quot;friendfile1.root&quot;);</span>
<span class="c1">///     tree.AddFriend(&quot;ft2&quot;,&quot;friendfile2.root&quot;);</span>
<span class="c1">///     tree.Draw(&quot;var:ft1.v1:ft2.v2&quot;);</span>
<span class="c1">/// ~~~</span>
<span class="c1">/// When AddFriend is called, the ROOT file is automatically opened and the</span>
<span class="c1">/// friend tree (ft1) is read into memory. The new friend (ft1) is added to</span>
<span class="c1">/// the list of friends of tree.</span>
<span class="c1">/// The number of entries in the friend must be equal or greater to the number</span>
<span class="c1">/// of entries of the original tree. If the friend tree has fewer entries a</span>
<span class="c1">/// warning is given and the missing entries are not included in the histogram.</span>
<span class="c1">/// To retrieve the list of friends from a tree use TTree::GetListOfFriends.</span>
<span class="c1">/// When the tree is written to file (TTree::Write), the friends list is saved</span>
<span class="c1">/// with it. And when the tree is retrieved, the trees on the friends list are</span>
<span class="c1">/// also retrieved and the friendship restored.</span>
<span class="c1">/// When a tree is deleted, the elements of the friend list are also deleted.</span>
<span class="c1">/// It is possible to declare a friend tree that has the same internal</span>
<span class="c1">/// structure (same branches and leaves) as the original tree, and compare the</span>
<span class="c1">/// same values by specifying the tree.</span>
<span class="c1">/// ~~~ {.cpp}</span>
<span class="c1">///     tree.Draw(&quot;var:ft1.var:ft2.var&quot;)</span>
<span class="c1">/// ~~~</span>

   <span class="k">virtual</span> <span class="n">TFriendElement</span> <span class="o">*</span><span class="nf">AddFriend</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">treename</span><span class="p">,</span> <span class="n">TFile</span><span class="o">*</span> <span class="n">file</span><span class="p">);</span>
<span class="c1">/// Add a TFriendElement to the list of friends.</span>
<span class="c1">/// The TFile is managed by the user (e.g. the user must delete the file).</span>
<span class="c1">/// For complete description see AddFriend(const char *, const char *).</span>
<span class="c1">/// This function:</span>
<span class="c1">/// - reads a Tree with name treename from the file</span>
<span class="c1">/// - adds the Tree to the list of friends</span>

   <span class="k">virtual</span> <span class="n">TFriendElement</span> <span class="o">*</span><span class="nf">AddFriend</span><span class="p">(</span><span class="n">TTree</span><span class="o">*</span> <span class="n">tree</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">alias</span> <span class="o">=</span> <span class="s">&quot;&quot;</span><span class="p">,</span> <span class="n">Bool_t</span> <span class="n">warn</span> <span class="o">=</span> <span class="n">kFALSE</span><span class="p">);</span>
<span class="c1">/// Add a TFriendElement to the list of friends.</span>
<span class="c1">/// The TTree is managed by the user (e.g., the user must delete the file).</span>
<span class="c1">/// For a complete description see AddFriend(const char *, const char *).</span>

   <span class="k">virtual</span> <span class="kt">void</span>            <span class="nf">AddTotBytes</span><span class="p">(</span><span class="n">Int_t</span> <span class="n">tot</span><span class="p">)</span> <span class="p">{</span> <span class="n">fTotBytes</span> <span class="o">+=</span> <span class="n">tot</span><span class="p">;</span> <span class="p">}</span>
   <span class="k">virtual</span> <span class="kt">void</span>            <span class="nf">AddZipBytes</span><span class="p">(</span><span class="n">Int_t</span> <span class="n">zip</span><span class="p">)</span> <span class="p">{</span> <span class="n">fZipBytes</span> <span class="o">+=</span> <span class="n">zip</span><span class="p">;</span> <span class="p">}</span>
   <span class="k">virtual</span> <span class="n">Long64_t</span>        <span class="nf">AutoSave</span><span class="p">(</span><span class="n">Option_t</span><span class="o">*</span> <span class="n">option</span> <span class="o">=</span> <span class="s">&quot;&quot;</span><span class="p">);</span>
<span class="c1">// AutoSave tree header every fAutoSave bytes.</span>
<span class="c1">//   When large Trees are produced, it is safe to activate the AutoSave</span>
<span class="c1">//   procedure. Some branches may have buffers holding many entries.</span>
<span class="c1">//   AutoSave is automatically called by TTree::Fill when the number of bytes</span>
<span class="c1">//   generated since the previous AutoSave is greater than fAutoSave bytes.</span>
<span class="c1">//   This function may also be invoked by the user, for example every</span>
<span class="c1">//   N entries.</span>
<span class="c1">//   Each AutoSave generates a new key on the file.</span>
<span class="c1">//   Once the key with the tree header has been written, the previous cycle</span>
<span class="c1">//   (if any) is deleted.</span>
<span class="c1">//   Note that calling TTree::AutoSave too frequently (or similarly calling</span>
<span class="c1">//   TTree::SetAutoSave with a small value) is an expensive operation.</span>
<span class="c1">//   You should make tests for your own application to find a compromise</span>
<span class="c1">//   between speed and the quantity of information you may loose in case of</span>
<span class="c1">//   a job crash.</span>
<span class="c1">//   In case your program crashes before closing the file holding this tree,</span>
<span class="c1">//   the file will be automatically recovered when you will connect the file</span>
<span class="c1">//   in UPDATE mode.</span>
<span class="c1">//   The Tree will be recovered at the status corresponding to the last AutoSave.</span>
<span class="c1">//   if option contains &quot;SaveSelf&quot;, gDirectory-&gt;SaveSelf() is called.</span>
<span class="c1">//   This allows another process to analyze the Tree while the Tree is being filled.</span>
<span class="c1">//   if option contains &quot;FlushBaskets&quot;, TTree::FlushBaskets is called and all</span>
<span class="c1">//   the current basket are closed-out and written to disk individually.</span>
<span class="c1">//   By default the previous header is deleted after having written the new header.</span>
<span class="c1">//   if option contains &quot;Overwrite&quot;, the previous Tree header is deleted</span>
<span class="c1">//   before written the new header. This option is slightly faster, but</span>
<span class="c1">//   the default option is safer in case of a problem (disk quota exceeded)</span>
<span class="c1">//   when writing the new header.</span>
<span class="c1">//   The function returns the number of bytes written to the file.</span>
<span class="c1">//   if the number of bytes is null, an error has occurred while writing</span>
<span class="c1">//   the header to the file.</span>

   <span class="k">virtual</span> <span class="n">Int_t</span>           <span class="nf">Branch</span><span class="p">(</span><span class="n">TCollection</span><span class="o">*</span> <span class="n">list</span><span class="p">,</span> <span class="n">Int_t</span> <span class="n">bufsize</span> <span class="o">=</span> <span class="mi">32000</span><span class="p">,</span> <span class="n">Int_t</span> <span class="n">splitlevel</span> <span class="o">=</span> <span class="mi">99</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">name</span> <span class="o">=</span> <span class="s">&quot;&quot;</span><span class="p">);</span>
<span class="c1">/// Create one branch for each element in the collection.</span>
<span class="c1">/// Each entry in the collection becomes a top level branch if the</span>
<span class="c1">/// corresponding class is not a collection. If it is a collection, the entry</span>
<span class="c1">/// in the collection becomes in turn top level branches, etc.</span>
<span class="c1">/// The splitlevel is decreased by 1 every time a new collection is found.</span>
<span class="c1">/// For example if list is a TObjArray*</span>
<span class="c1">///   - if splitlevel = 1, one top level branch is created for each element</span>
<span class="c1">///      of the TObjArray.</span>
<span class="c1">///   - if splitlevel = 2, one top level branch is created for each array element.</span>
<span class="c1">///     if, in turn, one of the array elements is a TCollection, one top level</span>
<span class="c1">///     branch will be created for each element of this collection.</span>
<span class="c1">/// In case a collection element is a TClonesArray, the special Tree constructor</span>
<span class="c1">/// for TClonesArray is called.</span>
<span class="c1">/// The collection itself cannot be a TClonesArray.</span>
<span class="c1">/// The function returns the total number of branches created.</span>
<span class="c1">/// If name is given, all branch names will be prefixed with name_.</span>
<span class="c1">/// IMPORTANT NOTE1: This function should not be called with splitlevel &lt; 1.</span>
<span class="c1">/// IMPORTANT NOTE2: The branches created by this function will have names</span>
<span class="c1">/// corresponding to the collection or object names. It is important</span>
<span class="c1">/// to give names to collections to avoid misleading branch names or</span>
<span class="c1">/// identical branch names. By default collections have a name equal to</span>
<span class="c1">/// the corresponding class name, e.g. the default name for a TList is &quot;TList&quot;.</span>
<span class="c1">/// And in general in any cases two or more master branches contain subbranches</span>
<span class="c1">/// with identical names, one must add a &quot;.&quot; (dot) character at the end</span>
<span class="c1">/// of the master branch name. This will force the name of the subbranch</span>
<span class="c1">/// to be master.subbranch instead of simply subbranch.</span>
<span class="c1">/// This situation happens when the top level object (say event)</span>
<span class="c1">/// has two or more members referencing the same class.</span>
<span class="c1">/// For example, if a Tree has two branches B1 and B2 corresponding</span>
<span class="c1">/// to objects of the same class MyClass, one can do:</span>
<span class="c1">/// ~~~ {.cpp}</span>
<span class="c1">///     tree.Branch(&quot;B1.&quot;,&quot;MyClass&quot;,&amp;b1,8000,1);</span>
<span class="c1">///     tree.Branch(&quot;B2.&quot;,&quot;MyClass&quot;,&amp;b2,8000,1);</span>
<span class="c1">/// ~~~</span>
<span class="c1">/// if MyClass has 3 members a,b,c, the two instructions above will generate</span>
<span class="c1">/// subbranches called B1.a, B1.b ,B1.c, B2.a, B2.b, B2.c</span>

   <span class="k">virtual</span> <span class="n">Int_t</span>           <span class="nf">Branch</span><span class="p">(</span><span class="n">TList</span><span class="o">*</span> <span class="n">list</span><span class="p">,</span> <span class="n">Int_t</span> <span class="n">bufsize</span> <span class="o">=</span> <span class="mi">32000</span><span class="p">,</span> <span class="n">Int_t</span> <span class="n">splitlevel</span> <span class="o">=</span> <span class="mi">99</span><span class="p">);</span>
<span class="c1">/// Deprecated function. Use next function instead.</span>

   <span class="k">virtual</span> <span class="n">Int_t</span>           <span class="nf">Branch</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">folder</span><span class="p">,</span> <span class="n">Int_t</span> <span class="n">bufsize</span> <span class="o">=</span> <span class="mi">32000</span><span class="p">,</span> <span class="n">Int_t</span> <span class="n">splitlevel</span> <span class="o">=</span> <span class="mi">99</span><span class="p">);</span>
<span class="c1">/// Create one branch for each element in the folder.</span>
<span class="c1">/// Returns the total number of branches created.</span>

   <span class="k">virtual</span> <span class="n">TBranch</span>        <span class="o">*</span><span class="nf">Branch</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">name</span><span class="p">,</span> <span class="kt">void</span><span class="o">*</span> <span class="n">address</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">leaflist</span><span class="p">,</span> <span class="n">Int_t</span> <span class="n">bufsize</span> <span class="o">=</span> <span class="mi">32000</span><span class="p">);</span>
<span class="c1">/// Create a new TTree Branch.</span>
<span class="c1">/// This Branch constructor is provided to support non-objects in</span>
<span class="c1">/// a Tree. The variables described in leaflist may be simple</span>
<span class="c1">/// variables or structures.  // See the two following</span>
<span class="c1">/// constructors for writing objects in a Tree.</span>
<span class="c1">/// By default the branch buffers are stored in the same file as the Tree.</span>
<span class="c1">/// use TBranch::SetFile to specify a different file</span>
<span class="c1">///    * address is the address of the first item of a structure.</span>
<span class="c1">///    * leaflist is the concatenation of all the variable names and types</span>
<span class="c1">///      separated by a colon character :</span>
<span class="c1">///      The variable name and the variable type are separated by a slash (/).</span>
<span class="c1">///      The variable type may be 0,1 or 2 characters. If no type is given,</span>
<span class="c1">///      the type of the variable is assumed to be the same as the previous</span>
<span class="c1">///      variable. If the first variable does not have a type, it is assumed</span>
<span class="c1">///      of type F by default. The list of currently supported types is given below:</span>
<span class="c1">///         - C : a character string terminated by the 0 character</span>
<span class="c1">///         - B : an 8 bit signed integer (Char_t)</span>
<span class="c1">///         - b : an 8 bit unsigned integer (UChar_t)</span>
<span class="c1">///         - S : a 16 bit signed integer (Short_t)</span>
<span class="c1">///         - s : a 16 bit unsigned integer (UShort_t)</span>
<span class="c1">///         - I : a 32 bit signed integer (Int_t)</span>
<span class="c1">///         - i : a 32 bit unsigned integer (UInt_t)</span>
<span class="c1">///         - F : a 32 bit floating point (Float_t)</span>
<span class="c1">///         - D : a 64 bit floating point (Double_t)</span>
<span class="c1">///         - L : a 64 bit signed integer (Long64_t)</span>
<span class="c1">///         - l : a 64 bit unsigned integer (ULong64_t)</span>
<span class="c1">///         - O : [the letter &#39;o&#39;, not a zero] a boolean (Bool_t)</span>
<span class="c1">///      Arrays of values are supported with the following syntax:</span>
<span class="c1">///         - If leaf name has the form var[nelem], where nelem is alphanumeric, then</span>
<span class="c1">///           if nelem is a leaf name, it is used as the variable size of the array,</span>
<span class="c1">///           otherwise return 0.</span>
<span class="c1">///         - If leaf name has the form var[nelem], where nelem is a non-negative integer, then</span>
<span class="c1">///           it is used as the fixed size of the array.</span>
<span class="c1">///         - If leaf name has the form of a multi-dimensional array (e.g. var[nelem][nelem2])</span>
<span class="c1">///           where nelem and nelem2 are non-negative integer) then</span>
<span class="c1">///           it is used as a 2 dimensional array of fixed size.</span>
<span class="c1">///      Any of other form is not supported.</span>
<span class="c1">/// Note that the TTree will assume that all the item are contiguous in memory.</span>
<span class="c1">/// On some platform, this is not always true of the member of a struct or a class,</span>
<span class="c1">/// due to padding and alignment.  Sorting your data member in order of decreasing</span>
<span class="c1">/// sizeof usually leads to their being contiguous in memory.</span>
<span class="c1">///    * bufsize is the buffer size in bytes for this branch</span>
<span class="c1">///      The default value is 32000 bytes and should be ok for most cases.</span>
<span class="c1">///      You can specify a larger value (e.g. 256000) if your Tree is not split</span>
<span class="c1">///      and each entry is large (Megabytes)</span>
<span class="c1">///      A small value for bufsize is optimum if you intend to access</span>
<span class="c1">///      the entries in the Tree randomly and your Tree is in split mode.</span>

           <span class="n">TBranch</span>        <span class="o">*</span><span class="nf">Branch</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">name</span><span class="p">,</span> <span class="kt">char</span><span class="o">*</span> <span class="n">address</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">leaflist</span><span class="p">,</span> <span class="n">Int_t</span> <span class="n">bufsize</span> <span class="o">=</span> <span class="mi">32000</span><span class="p">)</span>
   <span class="p">{</span>
      <span class="c1">// Overload to avoid confusion between this signature and the template instance.</span>
      <span class="k">return</span> <span class="n">Branch</span><span class="p">(</span><span class="n">name</span><span class="p">,(</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="n">address</span><span class="p">,</span><span class="n">leaflist</span><span class="p">,</span><span class="n">bufsize</span><span class="p">);</span>
   <span class="p">}</span>
   <span class="n">TBranch</span>        <span class="o">*</span><span class="nf">Branch</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">name</span><span class="p">,</span> <span class="n">Long_t</span> <span class="n">address</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">leaflist</span><span class="p">,</span> <span class="n">Int_t</span> <span class="n">bufsize</span> <span class="o">=</span> <span class="mi">32000</span><span class="p">)</span>
   <span class="p">{</span>
      <span class="c1">// Overload to avoid confusion between this signature and the template instance.</span>
      <span class="k">return</span> <span class="n">Branch</span><span class="p">(</span><span class="n">name</span><span class="p">,(</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="n">address</span><span class="p">,</span><span class="n">leaflist</span><span class="p">,</span><span class="n">bufsize</span><span class="p">);</span>
   <span class="p">}</span>
   <span class="n">TBranch</span>        <span class="o">*</span><span class="nf">Branch</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">name</span><span class="p">,</span> <span class="kt">int</span> <span class="n">address</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">leaflist</span><span class="p">,</span> <span class="n">Int_t</span> <span class="n">bufsize</span> <span class="o">=</span> <span class="mi">32000</span><span class="p">)</span>
   <span class="p">{</span>
      <span class="c1">// Overload to avoid confusion between this signature and the template instance.</span>
      <span class="k">return</span> <span class="n">Branch</span><span class="p">(</span><span class="n">name</span><span class="p">,(</span><span class="kt">void</span><span class="o">*</span><span class="p">)(</span><span class="n">Long_t</span><span class="p">)</span><span class="n">address</span><span class="p">,</span><span class="n">leaflist</span><span class="p">,</span><span class="n">bufsize</span><span class="p">);</span>
   <span class="p">}</span>
<span class="cp">#if !defined(__CINT__)</span>
   <span class="k">virtual</span> <span class="n">TBranch</span>        <span class="o">*</span><span class="nf">Branch</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">name</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">classname</span><span class="p">,</span> <span class="kt">void</span><span class="o">*</span> <span class="n">addobj</span><span class="p">,</span> <span class="n">Int_t</span> <span class="n">bufsize</span> <span class="o">=</span> <span class="mi">32000</span><span class="p">,</span> <span class="n">Int_t</span> <span class="n">splitlevel</span> <span class="o">=</span> <span class="mi">99</span><span class="p">);</span>
<span class="c1">/// Create a new branch with the object of class classname at address addobj.</span>
<span class="c1">/// WARNING:</span>
<span class="c1">/// Starting with Root version 3.01, the Branch function uses the new style</span>
<span class="c1">/// branches (TBranchElement). To get the old behaviour, you can:</span>
<span class="c1">///   - call BranchOld or</span>
<span class="c1">///   - call TTree::SetBranchStyle(0)</span>
<span class="c1">/// Note that with the new style, classname does not need to derive from TObject.</span>
<span class="c1">/// It must derived from TObject if the branch style has been set to 0 (old)</span>
<span class="c1">/// Note: See the comments in TBranchElement::SetAddress() for a more</span>
<span class="c1">///       detailed discussion of the meaning of the addobj parameter in</span>
<span class="c1">///       the case of new-style branches.</span>
<span class="c1">/// Use splitlevel &lt; 0 instead of splitlevel=0 when the class</span>
<span class="c1">/// has a custom Streamer</span>
<span class="c1">/// Note: if the split level is set to the default (99),  TTree::Branch will</span>
<span class="c1">/// not issue a warning if the class can not be split.</span>

<span class="cp">#endif</span>
   <span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span> <span class="n">TBranch</span> <span class="o">*</span><span class="n">Branch</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">name</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">classname</span><span class="p">,</span> <span class="n">T</span><span class="o">*</span> <span class="n">obj</span><span class="p">,</span> <span class="n">Int_t</span> <span class="n">bufsize</span> <span class="o">=</span> <span class="mi">32000</span><span class="p">,</span> <span class="n">Int_t</span> <span class="n">splitlevel</span> <span class="o">=</span> <span class="mi">99</span><span class="p">)</span>
   <span class="p">{</span>
      <span class="c1">// See BranchImpRed for details. Here we __ignore</span>
      <span class="k">return</span> <span class="n">BranchImpRef</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">classname</span><span class="p">,</span> <span class="n">TBuffer</span><span class="o">::</span><span class="n">GetClass</span><span class="p">(</span><span class="k">typeid</span><span class="p">(</span><span class="n">T</span><span class="p">)),</span> <span class="n">obj</span><span class="p">,</span> <span class="n">bufsize</span><span class="p">,</span> <span class="n">splitlevel</span><span class="p">);</span>
   <span class="p">}</span>
   <span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span> <span class="n">TBranch</span> <span class="o">*</span><span class="n">Branch</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">name</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">classname</span><span class="p">,</span> <span class="n">T</span><span class="o">**</span> <span class="n">addobj</span><span class="p">,</span> <span class="n">Int_t</span> <span class="n">bufsize</span> <span class="o">=</span> <span class="mi">32000</span><span class="p">,</span> <span class="n">Int_t</span> <span class="n">splitlevel</span> <span class="o">=</span> <span class="mi">99</span><span class="p">)</span>
   <span class="p">{</span>
      <span class="c1">// See BranchImp for details</span>
      <span class="k">return</span> <span class="n">BranchImp</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">classname</span><span class="p">,</span> <span class="n">TBuffer</span><span class="o">::</span><span class="n">GetClass</span><span class="p">(</span><span class="k">typeid</span><span class="p">(</span><span class="n">T</span><span class="p">)),</span> <span class="n">addobj</span><span class="p">,</span> <span class="n">bufsize</span><span class="p">,</span> <span class="n">splitlevel</span><span class="p">);</span>
   <span class="p">}</span>
   <span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span> <span class="n">TBranch</span> <span class="o">*</span><span class="n">Branch</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">name</span><span class="p">,</span> <span class="n">T</span><span class="o">**</span> <span class="n">addobj</span><span class="p">,</span> <span class="n">Int_t</span> <span class="n">bufsize</span> <span class="o">=</span> <span class="mi">32000</span><span class="p">,</span> <span class="n">Int_t</span> <span class="n">splitlevel</span> <span class="o">=</span> <span class="mi">99</span><span class="p">)</span>
   <span class="p">{</span>
      <span class="c1">// See BranchImp for details</span>
      <span class="k">return</span> <span class="n">BranchImp</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">TBuffer</span><span class="o">::</span><span class="n">GetClass</span><span class="p">(</span><span class="k">typeid</span><span class="p">(</span><span class="n">T</span><span class="p">)),</span> <span class="n">addobj</span><span class="p">,</span> <span class="n">bufsize</span><span class="p">,</span> <span class="n">splitlevel</span><span class="p">);</span>
   <span class="p">}</span>
   <span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span> <span class="n">TBranch</span> <span class="o">*</span><span class="n">Branch</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">name</span><span class="p">,</span> <span class="n">T</span><span class="o">*</span> <span class="n">obj</span><span class="p">,</span> <span class="n">Int_t</span> <span class="n">bufsize</span> <span class="o">=</span> <span class="mi">32000</span><span class="p">,</span> <span class="n">Int_t</span> <span class="n">splitlevel</span> <span class="o">=</span> <span class="mi">99</span><span class="p">)</span>
   <span class="p">{</span>
      <span class="c1">// See BranchImp for details</span>
      <span class="k">return</span> <span class="n">BranchImpRef</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">TBuffer</span><span class="o">::</span><span class="n">GetClass</span><span class="p">(</span><span class="k">typeid</span><span class="p">(</span><span class="n">T</span><span class="p">)),</span> <span class="n">TDataType</span><span class="o">::</span><span class="n">GetType</span><span class="p">(</span><span class="k">typeid</span><span class="p">(</span><span class="n">T</span><span class="p">)),</span> <span class="n">obj</span><span class="p">,</span> <span class="n">bufsize</span><span class="p">,</span> <span class="n">splitlevel</span><span class="p">);</span>
   <span class="p">}</span>
   <span class="k">virtual</span> <span class="n">TBranch</span>        <span class="o">*</span><span class="n">Bronch</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">name</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">classname</span><span class="p">,</span> <span class="kt">void</span><span class="o">*</span> <span class="n">addobj</span><span class="p">,</span> <span class="n">Int_t</span> <span class="n">bufsize</span> <span class="o">=</span> <span class="mi">32000</span><span class="p">,</span> <span class="n">Int_t</span> <span class="n">splitlevel</span> <span class="o">=</span> <span class="mi">99</span><span class="p">);</span>
<span class="c1">/// Create a new TTree BranchElement.</span>
<span class="c1">/// ## WARNING about this new function</span>
<span class="c1">/// This function is designed to replace the internal</span>
<span class="c1">/// implementation of the old TTree::Branch (whose implementation</span>
<span class="c1">/// has been moved to BranchOld).</span>
<span class="c1">/// NOTE: The &#39;Bronch&#39; method supports only one possible calls</span>
<span class="c1">/// signature (where the object type has to be specified</span>
<span class="c1">/// explicitly and the address must be the address of a pointer).</span>
<span class="c1">/// For more flexibility use &#39;Branch&#39;.  Use Bronch only in (rare)</span>
<span class="c1">/// cases (likely to be legacy cases) where both the new and old</span>
<span class="c1">/// implementation of Branch needs to be used at the same time.</span>
<span class="c1">/// This function is far more powerful than the old Branch</span>
<span class="c1">/// function.  It supports the full C++, including STL and has</span>
<span class="c1">/// the same behaviour in split or non-split mode. classname does</span>
<span class="c1">/// not have to derive from TObject.  The function is based on</span>
<span class="c1">/// the new TStreamerInfo.</span>
<span class="c1">/// Build a TBranchElement for an object of class classname.</span>
<span class="c1">/// addr is the address of a pointer to an object of class</span>
<span class="c1">/// classname.  The class dictionary must be available (ClassDef</span>
<span class="c1">/// in class header).</span>
<span class="c1">/// Note: See the comments in TBranchElement::SetAddress() for a more</span>
<span class="c1">///       detailed discussion of the meaning of the addr parameter.</span>
<span class="c1">/// This option requires access to the library where the</span>
<span class="c1">/// corresponding class is defined. Accessing one single data</span>
<span class="c1">/// member in the object implies reading the full object.</span>
<span class="c1">/// By default the branch buffers are stored in the same file as the Tree.</span>
<span class="c1">/// use TBranch::SetFile to specify a different file</span>
<span class="c1">/// IMPORTANT NOTE about branch names:</span>
<span class="c1">/// In case two or more master branches contain subbranches with</span>
<span class="c1">/// identical names, one must add a &quot;.&quot; (dot) character at the end</span>
<span class="c1">/// of the master branch name. This will force the name of the subbranch</span>
<span class="c1">/// to be master.subbranch instead of simply subbranch.</span>
<span class="c1">/// This situation happens when the top level object (say event)</span>
<span class="c1">/// has two or more members referencing the same class.</span>
<span class="c1">/// For example, if a Tree has two branches B1 and B2 corresponding</span>
<span class="c1">/// to objects of the same class MyClass, one can do:</span>
<span class="c1">/// ~~~ {.cpp}</span>
<span class="c1">///     tree.Branch(&quot;B1.&quot;,&quot;MyClass&quot;,&amp;b1,8000,1);</span>
<span class="c1">///     tree.Branch(&quot;B2.&quot;,&quot;MyClass&quot;,&amp;b2,8000,1);</span>
<span class="c1">/// ~~~</span>
<span class="c1">/// if MyClass has 3 members a,b,c, the two instructions above will generate</span>
<span class="c1">/// subbranches called B1.a, B1.b ,B1.c, B2.a, B2.b, B2.c</span>
<span class="c1">/// bufsize is the buffer size in bytes for this branch</span>
<span class="c1">/// The default value is 32000 bytes and should be ok for most cases.</span>
<span class="c1">/// You can specify a larger value (e.g. 256000) if your Tree is not split</span>
<span class="c1">/// and each entry is large (Megabytes)</span>
<span class="c1">/// A small value for bufsize is optimum if you intend to access</span>
<span class="c1">/// the entries in the Tree randomly and your Tree is in split mode.</span>
<span class="c1">/// Use splitlevel &lt; 0 instead of splitlevel=0 when the class</span>
<span class="c1">/// has a custom Streamer</span>
<span class="c1">/// Note: if the split level is set to the default (99),  TTree::Branch will</span>
<span class="c1">/// not issue a warning if the class can not be split.</span>

   <span class="k">virtual</span> <span class="n">TBranch</span>        <span class="o">*</span><span class="nf">BranchOld</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">name</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">classname</span><span class="p">,</span> <span class="kt">void</span><span class="o">*</span> <span class="n">addobj</span><span class="p">,</span> <span class="n">Int_t</span> <span class="n">bufsize</span> <span class="o">=</span> <span class="mi">32000</span><span class="p">,</span> <span class="n">Int_t</span> <span class="n">splitlevel</span> <span class="o">=</span> <span class="mi">1</span><span class="p">);</span>
<span class="c1">/// Create a new TTree BranchObject.</span>
<span class="c1">/// Build a TBranchObject for an object of class classname.</span>
<span class="c1">/// addobj is the address of a pointer to an object of class classname.</span>
<span class="c1">/// IMPORTANT: classname must derive from TObject.</span>
<span class="c1">/// The class dictionary must be available (ClassDef in class header).</span>
<span class="c1">/// This option requires access to the library where the corresponding class</span>
<span class="c1">/// is defined. Accessing one single data member in the object implies</span>
<span class="c1">/// reading the full object.</span>
<span class="c1">/// See the next Branch constructor for a more efficient storage</span>
<span class="c1">/// in case the entry consists of arrays of identical objects.</span>
<span class="c1">/// By default the branch buffers are stored in the same file as the Tree.</span>
<span class="c1">/// use TBranch::SetFile to specify a different file</span>
<span class="c1">/// IMPORTANT NOTE about branch names:</span>
<span class="c1">/// In case two or more master branches contain subbranches with</span>
<span class="c1">/// identical names, one must add a &quot;.&quot; (dot) character at the end</span>
<span class="c1">/// of the master branch name. This will force the name of the subbranch</span>
<span class="c1">/// to be master.subbranch instead of simply subbranch.</span>
<span class="c1">/// This situation happens when the top level object (say event)</span>
<span class="c1">/// has two or more members referencing the same class.</span>
<span class="c1">/// For example, if a Tree has two branches B1 and B2 corresponding</span>
<span class="c1">/// to objects of the same class MyClass, one can do:</span>
<span class="c1">/// ~~~ {.cpp}</span>
<span class="c1">///     tree.Branch(&quot;B1.&quot;,&quot;MyClass&quot;,&amp;b1,8000,1);</span>
<span class="c1">///     tree.Branch(&quot;B2.&quot;,&quot;MyClass&quot;,&amp;b2,8000,1);</span>
<span class="c1">/// ~~~</span>
<span class="c1">/// if MyClass has 3 members a,b,c, the two instructions above will generate</span>
<span class="c1">/// subbranches called B1.a, B1.b ,B1.c, B2.a, B2.b, B2.c</span>
<span class="c1">/// bufsize is the buffer size in bytes for this branch</span>
<span class="c1">/// The default value is 32000 bytes and should be ok for most cases.</span>
<span class="c1">/// You can specify a larger value (e.g. 256000) if your Tree is not split</span>
<span class="c1">/// and each entry is large (Megabytes)</span>
<span class="c1">/// A small value for bufsize is optimum if you intend to access</span>
<span class="c1">/// the entries in the Tree randomly and your Tree is in split mode.</span>

   <span class="k">virtual</span> <span class="n">TBranch</span>        <span class="o">*</span><span class="nf">BranchRef</span><span class="p">();</span>
<span class="c1">/// Build the optional branch supporting the TRefTable.</span>
<span class="c1">/// This branch will keep all the information to find the branches</span>
<span class="c1">/// containing referenced objects.</span>
<span class="c1">/// At each Tree::Fill, the branch numbers containing the</span>
<span class="c1">/// referenced objects are saved to the TBranchRef basket.</span>
<span class="c1">/// When the Tree header is saved (via TTree::Write), the branch</span>
<span class="c1">/// is saved keeping the information with the pointers to the branches</span>
<span class="c1">/// having referenced objects.</span>

   <span class="k">virtual</span> <span class="kt">void</span>            <span class="nf">Browse</span><span class="p">(</span><span class="n">TBrowser</span><span class="o">*</span><span class="p">);</span><span class="c1">/// Browse content of the TTree.</span>
   <span class="k">virtual</span> <span class="n">Int_t</span>           <span class="nf">BuildIndex</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">majorname</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">minorname</span> <span class="o">=</span> <span class="s">&quot;0&quot;</span><span class="p">);</span>
<span class="c1">/// Build a Tree Index (default is TTreeIndex).</span>
<span class="c1">/// See a description of the parameters and functionality in</span>
<span class="c1">/// TTreeIndex::TTreeIndex().</span>
<span class="c1">/// The return value is the number of entries in the Index (&lt; 0 indicates failure).</span>
<span class="c1">/// A TTreeIndex object pointed by fTreeIndex is created.</span>
<span class="c1">/// This object will be automatically deleted by the TTree destructor.</span>
<span class="c1">/// See also comments in TTree::SetTreeIndex().</span>

   <span class="n">TStreamerInfo</span>          <span class="o">*</span><span class="nf">BuildStreamerInfo</span><span class="p">(</span><span class="n">TClass</span><span class="o">*</span> <span class="n">cl</span><span class="p">,</span> <span class="kt">void</span><span class="o">*</span> <span class="n">pointer</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">Bool_t</span> <span class="n">canOptimize</span> <span class="o">=</span> <span class="n">kTRUE</span><span class="p">);</span>
<span class="c1">/// Build StreamerInfo for class cl.</span>
<span class="c1">/// pointer is an optional argument that may contain a pointer to an object of cl.</span>

   <span class="k">virtual</span> <span class="n">TFile</span>          <span class="o">*</span><span class="nf">ChangeFile</span><span class="p">(</span><span class="n">TFile</span><span class="o">*</span> <span class="n">file</span><span class="p">);</span>
<span class="c1">/// Called by TTree::Fill() when file has reached its maximum fgMaxTreeSize.</span>
<span class="c1">/// Create a new file. If the original file is named &quot;myfile.root&quot;,</span>
<span class="c1">/// subsequent files are named &quot;myfile_1.root&quot;, &quot;myfile_2.root&quot;, etc.</span>
<span class="c1">/// Returns a pointer to the new file.</span>
<span class="c1">/// Currently, the automatic change of file is restricted</span>
<span class="c1">/// to the case where the tree is in the top level directory.</span>
<span class="c1">/// The file should not contain sub-directories.</span>
<span class="c1">/// Before switching to a new file, the tree header is written</span>
<span class="c1">/// to the current file, then the current file is closed.</span>
<span class="c1">/// To process the multiple files created by ChangeFile, one must use</span>
<span class="c1">/// a TChain.</span>
<span class="c1">/// The new file name has a suffix &quot;_N&quot; where N is equal to fFileNumber+1.</span>
<span class="c1">/// By default a Root session starts with fFileNumber=0. One can set</span>
<span class="c1">/// fFileNumber to a different value via TTree::SetFileNumber.</span>
<span class="c1">/// In case a file named &quot;_N&quot; already exists, the function will try</span>
<span class="c1">/// a file named &quot;__N&quot;, then &quot;___N&quot;, etc.</span>
<span class="c1">/// fgMaxTreeSize can be set via the static function TTree::SetMaxTreeSize.</span>
<span class="c1">/// The default value of fgMaxTreeSize is 100 Gigabytes.</span>
<span class="c1">/// If the current file contains other objects like TH1 and TTree,</span>
<span class="c1">/// these objects are automatically moved to the new file.</span>
<span class="c1">/// IMPORTANT NOTE:</span>
<span class="c1">/// Be careful when writing the final Tree header to the file!</span>
<span class="c1">/// Don&#39;t do:</span>
<span class="c1">/// ~~~ {.cpp}</span>
<span class="c1">///     TFile *file = new TFile(&quot;myfile.root&quot;,&quot;recreate&quot;);</span>
<span class="c1">///     TTree *T = new TTree(&quot;T&quot;,&quot;title&quot;);</span>
<span class="c1">///     T-&gt;Fill(); //loop</span>
<span class="c1">///     file-&gt;Write();</span>
<span class="c1">///     file-&gt;Close();</span>
<span class="c1">///~~~</span>
<span class="c1">/// but do the following:</span>
<span class="c1">///~~~ {.cpp}</span>
<span class="c1">///     TFile *file = new TFile(&quot;myfile.root&quot;,&quot;recreate&quot;);</span>
<span class="c1">///     TTree *T = new TTree(&quot;T&quot;,&quot;title&quot;);</span>
<span class="c1">///     T-&gt;Fill(); //loop</span>
<span class="c1">///     file = T-&gt;GetCurrentFile(); //to get the pointer to the current file</span>
<span class="c1">///     file-&gt;Write();</span>
<span class="c1">///     file-&gt;Close();</span>
<span class="c1">/// ~~~</span>

   <span class="k">virtual</span> <span class="n">TTree</span>          <span class="o">*</span><span class="nf">CloneTree</span><span class="p">(</span><span class="n">Long64_t</span> <span class="n">nentries</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">Option_t</span><span class="o">*</span> <span class="n">option</span> <span class="o">=</span> <span class="s">&quot;&quot;</span><span class="p">);</span>
<span class="c1">/// Create a clone of this tree and copy nentries.</span>
<span class="c1">/// By default copy all entries.</span>
<span class="c1">/// The compression level of the cloned tree is set to the destination</span>
<span class="c1">/// file&#39;s compression level.</span>
<span class="c1">/// NOTE: Only active branches are copied.</span>
<span class="c1">/// NOTE: If the TTree is a TChain, the structure of the first TTree</span>
<span class="c1">///       is used for the copy.</span>
<span class="c1">/// IMPORTANT: The cloned tree stays connected with this tree until</span>
<span class="c1">///            this tree is deleted. In particular, any changes in</span>
<span class="c1">///            branch addresses in this tree are forwarded to the</span>
<span class="c1">///            clone trees, unless a branch in a clone tree has had</span>
<span class="c1">///            its address changed, in which case that change stays in</span>
<span class="c1">///            effect. When this tree is deleted, all the addresses of</span>
<span class="c1">///            the cloned tree are reset to their default values.</span>
<span class="c1">/// If &#39;option&#39; contains the word &#39;fast&#39; and nentries is -1, the</span>
<span class="c1">/// cloning will be done without unzipping or unstreaming the baskets</span>
<span class="c1">/// (i.e., a direct copy of the raw bytes on disk).</span>
<span class="c1">///</span>
<span class="c1">/// When &#39;fast&#39; is specified, &#39;option&#39; can also contain a sorting</span>
<span class="c1">/// order for the baskets in the output file.</span>
<span class="c1">/// There are currently 3 supported sorting order:</span>
<span class="c1">/// - SortBasketsByOffset (the default)</span>
<span class="c1">/// - SortBasketsByBranch</span>
<span class="c1">/// - SortBasketsByEntry</span>
<span class="c1">/// When using SortBasketsByOffset the baskets are written in the</span>
<span class="c1">/// output file in the same order as in the original file (i.e. the</span>
<span class="c1">/// baskets are sorted by their offset in the original file; Usually</span>
<span class="c1">/// this also means that the baskets are sorted by the index/number of</span>
<span class="c1">/// the _last_ entry they contain)</span>
<span class="c1">/// When using SortBasketsByBranch all the baskets of each individual</span>
<span class="c1">/// branches are stored contiguously. This tends to optimize reading</span>
<span class="c1">/// speed when reading a small number (1-&gt;5) of branches, since all</span>
<span class="c1">/// their baskets will be clustered together instead of being spread</span>
<span class="c1">/// across the file. However it might decrease the performance when</span>
<span class="c1">/// reading more branches (or the full entry).</span>
<span class="c1">/// When using SortBasketsByEntry the baskets with the lowest starting</span>
<span class="c1">/// entry are written first. (i.e. the baskets are sorted by the</span>
<span class="c1">/// index/number of the first entry they contain). This means that on</span>
<span class="c1">/// the file the baskets will be in the order in which they will be</span>
<span class="c1">/// needed when reading the whole tree sequentially.</span>
<span class="c1">/// For examples of CloneTree, see tutorials:</span>
<span class="c1">/// - copytree:</span>
<span class="c1">///     A macro to copy a subset of a TTree to a new TTree.</span>
<span class="c1">///     The input file has been generated by the program in</span>
<span class="c1">///     $ROOTSYS/test/Event with: Event 1000 1 1 1</span>
<span class="c1">/// - copytree2:</span>
<span class="c1">///     A macro to copy a subset of a TTree to a new TTree.</span>
<span class="c1">///     One branch of the new Tree is written to a separate file.</span>
<span class="c1">///     The input file has been generated by the program in</span>
<span class="c1">///     $ROOTSYS/test/Event with: Event 1000 1 1 1</span>

   <span class="k">virtual</span> <span class="kt">void</span>            <span class="nf">CopyAddresses</span><span class="p">(</span><span class="n">TTree</span><span class="o">*</span><span class="p">,</span><span class="n">Bool_t</span> <span class="n">undo</span> <span class="o">=</span> <span class="n">kFALSE</span><span class="p">);</span>
<span class="c1">/// Set branch addresses of passed tree equal to ours.</span>
<span class="c1">/// If undo is true, reset the branch address instead of copying them.</span>
<span class="c1">/// This insures &#39;separation&#39; of a cloned tree from its original</span>

   <span class="k">virtual</span> <span class="n">Long64_t</span>        <span class="nf">CopyEntries</span><span class="p">(</span><span class="n">TTree</span><span class="o">*</span> <span class="n">tree</span><span class="p">,</span> <span class="n">Long64_t</span> <span class="n">nentries</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">Option_t</span> <span class="o">*</span><span class="n">option</span> <span class="o">=</span> <span class="s">&quot;&quot;</span><span class="p">);</span>
<span class="c1">/// Copy nentries from given tree to this tree.</span>
<span class="c1">/// This routines assumes that the branches that intended to be copied are</span>
<span class="c1">/// already connected.   The typical case is that this tree was created using</span>
<span class="c1">/// tree-&gt;CloneTree(0).</span>
<span class="c1">/// By default copy all entries.</span>
<span class="c1">/// Returns number of bytes copied to this tree.</span>
<span class="c1">/// If &#39;option&#39; contains the word &#39;fast&#39; and nentries is -1, the cloning will be</span>
<span class="c1">/// done without unzipping or unstreaming the baskets (i.e., a direct copy of the</span>
<span class="c1">/// raw bytes on disk).</span>
<span class="c1">/// When &#39;fast&#39; is specified, &#39;option&#39; can also contains a sorting order for the</span>
<span class="c1">/// baskets in the output file.</span>
<span class="c1">/// There are currently 3 supported sorting order:</span>
<span class="c1">/// - SortBasketsByOffset (the default)</span>
<span class="c1">/// - SortBasketsByBranch</span>
<span class="c1">/// - SortBasketsByEntry</span>
<span class="c1">/// See TTree::CloneTree for a detailed explanation of the semantics of these 3 options.</span>
<span class="c1">/// If the tree or any of the underlying tree of the chain has an index, that index and any</span>
<span class="c1">/// index in the subsequent underlying TTree objects will be merged.</span>
<span class="c1">/// There are currently three &#39;options&#39; to control this merging:</span>
<span class="c1">/// - NoIndex             : all the TTreeIndex object are dropped.</span>
<span class="c1">/// - DropIndexOnError    : if any of the underlying TTree object do no have a TTreeIndex,</span>
<span class="c1">///                          they are all dropped.</span>
<span class="c1">/// - AsIsIndexOnError [default]: In case of missing TTreeIndex, the resulting TTree index has gaps.</span>
<span class="c1">/// - BuildIndexOnError : If any of the underlying TTree objects do not have a TTreeIndex,</span>
<span class="c1">///                          all TTreeIndex are &#39;ignored&#39; and the missing piece are rebuilt.</span>

   <span class="k">virtual</span> <span class="n">TTree</span>          <span class="o">*</span><span class="nf">CopyTree</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">selection</span><span class="p">,</span> <span class="n">Option_t</span><span class="o">*</span> <span class="n">option</span> <span class="o">=</span> <span class="s">&quot;&quot;</span><span class="p">,</span> <span class="n">Long64_t</span> <span class="n">nentries</span> <span class="o">=</span> <span class="n">kMaxEntries</span><span class="p">,</span> <span class="n">Long64_t</span> <span class="n">firstentry</span> <span class="o">=</span> <span class="mi">0</span><span class="p">);</span>
<span class="c1">/// Copy a tree with selection.</span>
<span class="c1">/// IMPORTANT:</span>
<span class="c1">/// The returned copied tree stays connected with the original tree</span>
<span class="c1">/// until the original tree is deleted.  In particular, any changes</span>
<span class="c1">/// to the branch addresses in the original tree are also made to</span>
<span class="c1">/// the copied tree.  Any changes made to the branch addresses of the</span>
<span class="c1">/// copied tree are overridden anytime the original tree changes its</span>
<span class="c1">/// branch addresses.  When the original tree is deleted, all the</span>
<span class="c1">/// branch addresses of the copied tree are set to zero.</span>
<span class="c1">///</span>
<span class="c1">/// For examples of CopyTree, see the tutorials:</span>
<span class="c1">/// - copytree:</span>
<span class="c1">/// Example macro to copy a subset of a tree to a new tree.</span>
<span class="c1">/// The input file was generated by running the program in</span>
<span class="c1">/// $ROOTSYS/test/Event in this way:</span>
<span class="c1">/// ~~~ {.cpp}</span>
<span class="c1">///     ./Event 1000 1 1 1</span>
<span class="c1">/// ~~~</span>
<span class="c1">/// - copytree2</span>
<span class="c1">/// Example macro to copy a subset of a tree to a new tree.</span>
<span class="c1">/// One branch of the new tree is written to a separate file.</span>
<span class="c1">/// The input file was generated by running the program in</span>
<span class="c1">/// $ROOTSYS/test/Event in this way:</span>
<span class="c1">/// ~~~ {.cpp}</span>
<span class="c1">///     ./Event 1000 1 1 1</span>
<span class="c1">/// ~~~</span>
<span class="c1">/// - copytree3</span>
<span class="c1">/// Example macro to copy a subset of a tree to a new tree.</span>
<span class="c1">/// Only selected entries are copied to the new tree.</span>
<span class="c1">/// NOTE that only the active branches are copied.</span>

   <span class="k">virtual</span> <span class="n">TBasket</span>        <span class="o">*</span><span class="nf">CreateBasket</span><span class="p">(</span><span class="n">TBranch</span><span class="o">*</span><span class="p">);</span><span class="c1">/// Create a basket for this tree and given branch.</span>
   <span class="k">virtual</span> <span class="kt">void</span>            <span class="nf">DirectoryAutoAdd</span><span class="p">(</span><span class="n">TDirectory</span> <span class="o">*</span><span class="p">);</span>
 <span class="c1">/// Called by TKey and TObject::Clone to automatically add us to a directory</span>
 <span class="c1">/// when we are read from a file.</span>

   <span class="n">Int_t</span>                   <span class="nf">Debug</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">fDebug</span><span class="p">;</span> <span class="p">}</span>
   <span class="k">virtual</span> <span class="kt">void</span>            <span class="nf">Delete</span><span class="p">(</span><span class="n">Option_t</span><span class="o">*</span> <span class="n">option</span> <span class="o">=</span> <span class="s">&quot;&quot;</span><span class="p">);</span> <span class="c1">// *MENU*</span>
<span class="c1">/// Delete this tree from memory or/and disk.</span>
<span class="c1">/// - if option == &quot;all&quot; delete Tree object from memory AND from disk</span>
<span class="c1">///                     all baskets on disk are deleted. All keys with same name</span>
<span class="c1">///                     are deleted.</span>
<span class="c1">/// - if option ==&quot;&quot; only Tree object in memory is deleted.</span>

   <span class="k">virtual</span> <span class="kt">void</span>            <span class="nf">Draw</span><span class="p">(</span><span class="n">Option_t</span><span class="o">*</span> <span class="n">opt</span><span class="p">)</span> <span class="p">{</span> <span class="n">Draw</span><span class="p">(</span><span class="n">opt</span><span class="p">,</span> <span class="s">&quot;&quot;</span><span class="p">,</span> <span class="s">&quot;&quot;</span><span class="p">,</span> <span class="n">kMaxEntries</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span> <span class="p">}</span>
   <span class="k">virtual</span> <span class="n">Long64_t</span>        <span class="nf">Draw</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">varexp</span><span class="p">,</span> <span class="k">const</span> <span class="n">TCut</span><span class="o">&amp;</span> <span class="n">selection</span><span class="p">,</span> <span class="n">Option_t</span><span class="o">*</span> <span class="n">option</span> <span class="o">=</span> <span class="s">&quot;&quot;</span><span class="p">,</span> <span class="n">Long64_t</span> <span class="n">nentries</span> <span class="o">=</span> <span class="n">kMaxEntries</span><span class="p">,</span> <span class="n">Long64_t</span> <span class="n">firstentry</span> <span class="o">=</span> <span class="mi">0</span><span class="p">);</span>
<span class="c1">/// Draw expression varexp for specified entries.</span>
<span class="c1">/// Returns -1 in case of error or number of selected events in case of success.</span>
<span class="c1">/// This function accepts TCut objects as arguments.</span>
<span class="c1">/// Useful to use the string operator +</span>
<span class="c1">/// Example:</span>
<span class="c1">///     ntuple.Draw(&quot;x&quot;,cut1+cut2+cut3);</span>

   <span class="k">virtual</span> <span class="n">Long64_t</span>        <span class="nf">Draw</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">varexp</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">selection</span><span class="p">,</span> <span class="n">Option_t</span><span class="o">*</span> <span class="n">option</span> <span class="o">=</span> <span class="s">&quot;&quot;</span><span class="p">,</span> <span class="n">Long64_t</span> <span class="n">nentries</span> <span class="o">=</span> <span class="n">kMaxEntries</span><span class="p">,</span> <span class="n">Long64_t</span> <span class="n">firstentry</span> <span class="o">=</span> <span class="mi">0</span><span class="p">);</span> <span class="c1">// *MENU*</span>
<span class="c1">/// Draw expression varexp for specified entries.</span>
<span class="c1">/// Returns -1 in case of error or number of selected events in case of success.</span>
<span class="c1">/// varexp is an expression of the general form</span>
<span class="c1">///  - &quot;e1&quot;           produces a 1-d histogram (TH1F) of expression &quot;e1&quot;</span>
<span class="c1">///  - &quot;e1:e2&quot;        produces an unbinned 2-d scatter-plot (TGraph) of &quot;e1&quot;</span>
<span class="c1">///                   on the y-axis versus &quot;e2&quot; on the x-axis</span>
<span class="c1">///  - &quot;e1:e2:e3&quot;     produces an unbinned 3-d scatter-plot (TPolyMarker3D) of &quot;e1&quot;</span>
<span class="c1">///                   versus &quot;e2&quot; versus &quot;e3&quot; on the x-, y-, z-axis, respectively.</span>
<span class="c1">///  - &quot;e1:e2:e3:e4&quot;  produces an unbinned 3-d scatter-plot (TPolyMarker3D) of &quot;e1&quot;</span>
<span class="c1">///                   versus &quot;e2&quot; versus &quot;e3&quot; and &quot;e4&quot; mapped on the color number.</span>
<span class="c1">/// (to create histograms in the 2, 3, and 4 dimensional case, see section &quot;Saving</span>
<span class="c1">/// the result of Draw to an histogram&quot;)</span>
<span class="c1">/// Example:</span>
<span class="c1">///  -  varexp = x     simplest case: draw a 1-Dim distribution of column named x</span>
<span class="c1">///  -  varexp = sqrt(x)            : draw distribution of sqrt(x)</span>
<span class="c1">///  -  varexp = x*y/z</span>
<span class="c1">///  -  varexp = y:sqrt(x) 2-Dim distribution of y versus sqrt(x)</span>
<span class="c1">///  -  varexp = px:py:pz:2.5*E  produces a 3-d scatter-plot of px vs py ps pz</span>
<span class="c1">///             and the color number of each marker will be 2.5*E.</span>
<span class="c1">///             If the color number is negative it is set to 0.</span>
<span class="c1">///             If the color number is greater than the current number of colors</span>
<span class="c1">///             it is set to the highest color number.The default number of</span>
<span class="c1">///             colors is 50. see TStyle::SetPalette for setting a new color palette.</span>
<span class="c1">/// Note that the variables e1, e2 or e3 may contain a selection.</span>
<span class="c1">/// example, if e1= x*(y&lt;0), the value histogrammed will be x if y&lt;0</span>
<span class="c1">/// and will be 0 otherwise.</span>
<span class="c1">/// The expressions can use all the operations and build-in functions</span>
<span class="c1">/// supported by TFormula (See TFormula::Analyze), including free</span>
<span class="c1">/// standing function taking numerical arguments (TMath::Bessel).</span>
<span class="c1">/// In addition, you can call member functions taking numerical</span>
<span class="c1">/// arguments. For example:</span>
<span class="c1">/// ~~~ {.cpp}</span>
<span class="c1">///     TMath::BreitWigner(fPx,3,2)</span>
<span class="c1">///     event.GetHistogram().GetXaxis().GetXmax()</span>
<span class="c1">/// ~~~</span>
<span class="c1">/// Note: You can only pass expression that depend on the TTree&#39;s data</span>
<span class="c1">/// to static functions and you can only call non-static member function</span>
<span class="c1">/// with &#39;fixed&#39; parameters.</span>
<span class="c1">/// selection is an expression with a combination of the columns.</span>
<span class="c1">/// In a selection all the C++ operators are authorized.</span>
<span class="c1">/// The value corresponding to the selection expression is used as a weight</span>
<span class="c1">/// to fill the histogram.</span>
<span class="c1">/// If the expression includes only boolean operations, the result</span>
<span class="c1">/// is 0 or 1. If the result is 0, the histogram is not filled.</span>
<span class="c1">/// In general, the expression may be of the form:</span>
<span class="c1">/// ~~~ {.cpp}</span>
<span class="c1">///     value*(boolean expression)</span>
<span class="c1">/// ~~~</span>
<span class="c1">/// if boolean expression is true, the histogram is filled with</span>
<span class="c1">/// a `weight = value`.</span>
<span class="c1">///</span>
<span class="c1">/// Examples:</span>
<span class="c1">///  -  selection1 = &quot;x&lt;y &amp;&amp; sqrt(z)&gt;3.2&quot;</span>
<span class="c1">///  -  selection2 = &quot;(x+y)*(sqrt(z)&gt;3.2)&quot;</span>
<span class="c1">///</span>
<span class="c1">///  -  selection1 returns a weight = 0 or 1</span>
<span class="c1">///  -  selection2 returns a weight = x+y if sqrt(z)&gt;3.2</span>
<span class="c1">///                returns a weight = 0 otherwise.</span>
<span class="c1">///</span>
<span class="c1">/// option is the drawing option.</span>
<span class="c1">///  - See TH1::Draw for the list of all drawing options.</span>
<span class="c1">///  - If option COL is specified when varexp has three fields:</span>
<span class="c1">///~~~ {.cpp}</span>
<span class="c1">///      tree.Draw(&quot;e1:e2:e3&quot;,&quot;&quot;,&quot;col&quot;);</span>
<span class="c1">///~~~</span>
<span class="c1">///    a 2D scatter is produced with e1 vs e2, and e3 is mapped on the color</span>
<span class="c1">///    table. The colors for e3 are evaluated once in linear scale before</span>
<span class="c1">///    painting. Therefore changing the pad to log scale along Z as no effect</span>
<span class="c1">///    on the colors.</span>
<span class="c1">///  - If option contains the string &quot;goff&quot;, no graphics is generated.</span>
<span class="c1">///</span>
<span class="c1">/// `nentries` is the number of entries to process (default is all)</span>
<span class="c1">/// first is the first entry to process (default is 0)</span>
<span class="c1">///</span>
<span class="c1">/// This function returns the number of selected entries. It returns -1</span>
<span class="c1">/// if an error occurs.</span>
<span class="c1">///</span>
<span class="c1">/// ## Drawing expressions using arrays and array elements</span>
<span class="c1">///</span>
<span class="c1">/// Let assumes, a leaf fMatrix, on the branch fEvent, which is a 3 by 3 array,</span>
<span class="c1">/// or a TClonesArray.</span>
<span class="c1">/// In a TTree::Draw expression you can now access fMatrix using the following</span>
<span class="c1">/// syntaxes:</span>
<span class="c1">///</span>
<span class="c1">/// | String passed   | What is used for each entry of the tree</span>
<span class="c1">/// |-----------------|--------------------------------------------------------|</span>
<span class="c1">/// | `fMatrix`       | the 9 elements of fMatrix |</span>
<span class="c1">/// | `fMatrix[][]`   | the 9 elements of fMatrix |</span>
<span class="c1">/// | `fMatrix[2][2]` | only the elements fMatrix[2][2] |</span>
<span class="c1">/// | `fMatrix[1]`    | the 3 elements fMatrix[1][0], fMatrix[1][1] and fMatrix[1][2] |</span>
<span class="c1">/// | `fMatrix[1][]`  | the 3 elements fMatrix[1][0], fMatrix[1][1] and fMatrix[1][2] |</span>
<span class="c1">/// | `fMatrix[][0]`  | the 3 elements fMatrix[0][0], fMatrix[1][0] and fMatrix[2][0] |</span>
<span class="c1">///</span>
<span class="c1">/// &quot;fEvent.fMatrix....&quot; same as &quot;fMatrix...&quot; (unless there is more than one leaf named fMatrix!).</span>
<span class="c1">///</span>
<span class="c1">/// In summary, if a specific index is not specified for a dimension, TTree::Draw</span>
<span class="c1">/// will loop through all the indices along this dimension.  Leaving off the</span>
<span class="c1">/// last (right most) dimension of specifying then with the two characters &#39;[]&#39;</span>
<span class="c1">/// is equivalent.  For variable size arrays (and TClonesArray) the range</span>
<span class="c1">/// of the first dimension is recalculated for each entry of the tree.</span>
<span class="c1">/// You can also specify the index as an expression of any other variables from the</span>
<span class="c1">/// tree.</span>
<span class="c1">///</span>
<span class="c1">/// TTree::Draw also now properly handling operations involving 2 or more arrays.</span>
<span class="c1">///</span>
<span class="c1">/// Let assume a second matrix fResults[5][2], here are a sample of some</span>
<span class="c1">/// of the possible combinations, the number of elements they produce and</span>
<span class="c1">/// the loop used:</span>
<span class="c1">///</span>
<span class="c1">/// | expression                       | element(s) | Loop                     |</span>
<span class="c1">/// |----------------------------------|------------|--------------------------|</span>
<span class="c1">/// | `fMatrix[2][1] - fResults[5][2]` |  one       | no loop |</span>
<span class="c1">/// | `fMatrix[2][]  - fResults[5][2]` |  three     | on 2nd dim fMatrix |</span>
<span class="c1">/// | `fMatrix[2][]  - fResults[5][]`  |  two       | on both 2nd dimensions |</span>
<span class="c1">/// | `fMatrix[][2]  - fResults[][1]`  |  three     | on both 1st dimensions |</span>
<span class="c1">/// | `fMatrix[][2]  - fResults[][]`   |  six       | on both 1st and 2nd dimensions of fResults |</span>
<span class="c1">/// | `fMatrix[][2]  - fResults[3][]`  |  two       | on 1st dim of fMatrix and 2nd of fResults (at the same time) |</span>
<span class="c1">/// | `fMatrix[][]   - fResults[][]`   |  six       | on 1st dim then on  2nd dim |</span>
<span class="c1">/// | `fMatrix[][fResult[][]]`         |  30        | on 1st dim of fMatrix then on both dimensions of fResults.  The value if fResults[j][k] is used as the second index of fMatrix.|</span>
<span class="c1">///</span>
<span class="c1">///</span>
<span class="c1">/// In summary, TTree::Draw loops through all unspecified dimensions.  To</span>
<span class="c1">/// figure out the range of each loop, we match each unspecified dimension</span>
<span class="c1">/// from left to right (ignoring ALL dimensions for which an index has been</span>
<span class="c1">/// specified), in the equivalent loop matched dimensions use the same index</span>
<span class="c1">/// and are restricted to the smallest range (of only the matched dimensions).</span>
<span class="c1">/// When involving variable arrays, the range can of course be different</span>
<span class="c1">/// for each entry of the tree.</span>
<span class="c1">///</span>
<span class="c1">/// So the loop equivalent to &quot;fMatrix[][2] - fResults[3][]&quot; is:</span>
<span class="c1">/// ~~~ {.cpp}</span>
<span class="c1">///     for (Int_t i0; i &lt; min(3,2); i++) {</span>
<span class="c1">///        use the value of (fMatrix[i0][2] - fMatrix[3][i0])</span>
<span class="c1">///     }</span>
<span class="c1">/// ~~~</span>
<span class="c1">/// So the loop equivalent to &quot;fMatrix[][2] - fResults[][]&quot; is:</span>
<span class="c1">/// ~~~ {.cpp}</span>
<span class="c1">///     for (Int_t i0; i &lt; min(3,5); i++) {</span>
<span class="c1">///        for (Int_t i1; i1 &lt; 2; i1++) {</span>
<span class="c1">///           use the value of (fMatrix[i0][2] - fMatrix[i0][i1])</span>
<span class="c1">///        }</span>
<span class="c1">///     }</span>
<span class="c1">/// ~~~</span>
<span class="c1">/// So the loop equivalent to &quot;fMatrix[][] - fResults[][]&quot; is:</span>
<span class="c1">/// ~~~ {.cpp}</span>
<span class="c1">///     for (Int_t i0; i &lt; min(3,5); i++) {</span>
<span class="c1">///        for (Int_t i1; i1 &lt; min(3,2); i1++) {</span>
<span class="c1">///           use the value of (fMatrix[i0][i1] - fMatrix[i0][i1])</span>
<span class="c1">///        }</span>
<span class="c1">///     }</span>
<span class="c1">/// ~~~</span>
<span class="c1">/// So the loop equivalent to &quot;fMatrix[][fResults[][]]&quot; is:</span>
<span class="c1">/// ~~~ {.cpp}</span>
<span class="c1">///     for (Int_t i0; i0 &lt; 3; i0++) {</span>
<span class="c1">///        for (Int_t j2; j2 &lt; 5; j2++) {</span>
<span class="c1">///           for (Int_t j3; j3 &lt; 2; j3++) {</span>
<span class="c1">///              i1 = fResults[j2][j3];</span>
<span class="c1">///              use the value of fMatrix[i0][i1]</span>
<span class="c1">///        }</span>
<span class="c1">///     }</span>
<span class="c1">/// ~~~</span>
<span class="c1">/// ## Retrieving the result of Draw</span>
<span class="c1">///</span>
<span class="c1">/// By default the temporary histogram created is called &quot;htemp&quot;, but only in</span>
<span class="c1">/// the one dimensional Draw(&quot;e1&quot;) it contains the TTree&#39;s data points. For</span>
<span class="c1">/// a two dimensional Draw, the data is filled into a TGraph which is named</span>
<span class="c1">/// &quot;Graph&quot;. They can be retrieved by calling</span>
<span class="c1">/// ~~~ {.cpp}</span>
<span class="c1">///     TH1F *htemp = (TH1F*)gPad-&gt;GetPrimitive(&quot;htemp&quot;); // 1D</span>
<span class="c1">///     TGraph *graph = (TGraph*)gPad-&gt;GetPrimitive(&quot;Graph&quot;); // 2D</span>
<span class="c1">/// ~~~</span>
<span class="c1">/// For a three and four dimensional Draw the TPolyMarker3D is unnamed, and</span>
<span class="c1">/// cannot be retrieved.</span>
<span class="c1">///</span>
<span class="c1">/// gPad always contains a TH1 derived object called &quot;htemp&quot; which allows to</span>
<span class="c1">/// access the axes:</span>
<span class="c1">/// ~~~ {.cpp}</span>
<span class="c1">///     TGraph *graph = (TGraph*)gPad-&gt;GetPrimitive(&quot;Graph&quot;); // 2D</span>
<span class="c1">///     TH2F   *htemp = (TH2F*)gPad-&gt;GetPrimitive(&quot;htemp&quot;); // empty, but has axes</span>
<span class="c1">///     TAxis  *xaxis = htemp-&gt;GetXaxis();</span>
<span class="c1">/// ~~~</span>
<span class="c1">/// ## Saving the result of Draw to an histogram</span>
<span class="c1">///</span>
<span class="c1">/// If varexp0 contains &gt;&gt;hnew (following the variable(s) name(s),</span>
<span class="c1">/// the new histogram created is called hnew and it is kept in the current</span>
<span class="c1">/// directory (and also the current pad). This works for all dimensions.</span>
<span class="c1">///</span>
<span class="c1">/// Example:</span>
<span class="c1">/// ~~~ {.cpp}</span>
<span class="c1">///     tree.Draw(&quot;sqrt(x)&gt;&gt;hsqrt&quot;,&quot;y&gt;0&quot;)</span>
<span class="c1">/// ~~~</span>
<span class="c1">/// will draw `sqrt(x)` and save the histogram as &quot;hsqrt&quot; in the current</span>
<span class="c1">/// directory. To retrieve it do:</span>
<span class="c1">/// ~~~ {.cpp}</span>
<span class="c1">///     TH1F *hsqrt = (TH1F*)gDirectory-&gt;Get(&quot;hsqrt&quot;);</span>
<span class="c1">/// ~~~</span>
<span class="c1">/// The binning information is taken from the environment variables</span>
<span class="c1">/// ~~~ {.cpp}</span>
<span class="c1">///     Hist.Binning.?D.?</span>
<span class="c1">/// ~~~</span>
<span class="c1">/// In addition, the name of the histogram can be followed by up to 9</span>
<span class="c1">/// numbers between &#39;(&#39; and &#39;)&#39;, where the numbers describe the</span>
<span class="c1">/// following:</span>
<span class="c1">///</span>
<span class="c1">/// -  1 - bins in x-direction</span>
<span class="c1">/// -  2 - lower limit in x-direction</span>
<span class="c1">/// -  3 - upper limit in x-direction</span>
<span class="c1">/// -  4-6 same for y-direction</span>
<span class="c1">/// -  7-9 same for z-direction</span>
<span class="c1">///</span>
<span class="c1">/// When a new binning is used the new value will become the default.</span>
<span class="c1">/// Values can be skipped.</span>
<span class="c1">///</span>
<span class="c1">/// Example:</span>
<span class="c1">/// ~~~ {.cpp}</span>
<span class="c1">///     tree.Draw(&quot;sqrt(x)&gt;&gt;hsqrt(500,10,20)&quot;)</span>
<span class="c1">///          // plot sqrt(x) between 10 and 20 using 500 bins</span>
<span class="c1">///     tree.Draw(&quot;sqrt(x):sin(y)&gt;&gt;hsqrt(100,10,60,50,.1,.5)&quot;)</span>
<span class="c1">///          // plot sqrt(x) against sin(y)</span>
<span class="c1">///          // 100 bins in x-direction; lower limit on x-axis is 10; upper limit is 60</span>
<span class="c1">///          //  50 bins in y-direction; lower limit on y-axis is .1; upper limit is .5</span>
<span class="c1">/// ~~~</span>
<span class="c1">/// By default, the specified histogram is reset.</span>
<span class="c1">/// To continue to append data to an existing histogram, use &quot;+&quot; in front</span>
<span class="c1">/// of the histogram name.</span>
<span class="c1">///</span>
<span class="c1">/// A &#39;+&#39; in front of the histogram name is ignored, when the name is followed by</span>
<span class="c1">/// binning information as described in the previous paragraph.</span>
<span class="c1">/// ~~~ {.cpp}</span>
<span class="c1">///     tree.Draw(&quot;sqrt(x)&gt;&gt;+hsqrt&quot;,&quot;y&gt;0&quot;)</span>
<span class="c1">/// ~~~</span>
<span class="c1">/// will not reset `hsqrt`, but will continue filling. This works for 1-D, 2-D</span>
<span class="c1">/// and 3-D histograms.</span>
<span class="c1">///</span>
<span class="c1">/// ## Accessing collection objects</span>
<span class="c1">///</span>
<span class="c1">/// TTree::Draw default&#39;s handling of collections is to assume that any</span>
<span class="c1">/// request on a collection pertain to it content.  For example, if fTracks</span>
<span class="c1">/// is a collection of Track objects, the following:</span>
<span class="c1">/// ~~~ {.cpp}</span>
<span class="c1">///     tree-&gt;Draw(&quot;event.fTracks.fPx&quot;);</span>
<span class="c1">/// ~~~</span>
<span class="c1">/// will plot the value of fPx for each Track objects inside the collection.</span>
<span class="c1">/// Also</span>
<span class="c1">/// ~~~ {.cpp}</span>
<span class="c1">///     tree-&gt;Draw(&quot;event.fTracks.size()&quot;);</span>
<span class="c1">/// ~~~</span>
<span class="c1">/// would plot the result of the member function Track::size() for each</span>
<span class="c1">/// Track object inside the collection.</span>
<span class="c1">/// To access information about the collection itself, TTree::Draw support</span>
<span class="c1">/// the &#39;@&#39; notation.  If a variable which points to a collection is prefixed</span>
<span class="c1">/// or postfixed with &#39;@&#39;, the next part of the expression will pertain to</span>
<span class="c1">/// the collection object.  For example:</span>
<span class="c1">/// ~~~ {.cpp}</span>
<span class="c1">///     tree-&gt;Draw(&quot;event.@fTracks.size()&quot;);</span>
<span class="c1">/// ~~~</span>
<span class="c1">/// will plot the size of the collection referred to by `fTracks` (i.e the number</span>
<span class="c1">/// of Track objects).</span>
<span class="c1">///</span>
<span class="c1">/// ## Drawing &#39;objects&#39;</span>
<span class="c1">///</span>
<span class="c1">/// When a class has a member function named AsDouble or AsString, requesting</span>
<span class="c1">/// to directly draw the object will imply a call to one of the 2 functions.</span>
<span class="c1">/// If both AsDouble and AsString are present, AsDouble will be used.</span>
<span class="c1">/// AsString can return either a char*, a std::string or a TString.s</span>
<span class="c1">/// For example, the following</span>
<span class="c1">/// ~~~ {.cpp}</span>
<span class="c1">///     tree-&gt;Draw(&quot;event.myTTimeStamp&quot;);</span>
<span class="c1">/// ~~~</span>
<span class="c1">/// will draw the same histogram as</span>
<span class="c1">/// ~~~ {.cpp}</span>
<span class="c1">///     tree-&gt;Draw(&quot;event.myTTimeStamp.AsDouble()&quot;);</span>
<span class="c1">/// ~~~</span>
<span class="c1">/// In addition, when the object is a type TString or std::string, TTree::Draw</span>
<span class="c1">/// will call respectively `TString::Data` and `std::string::c_str()`</span>
<span class="c1">///</span>
<span class="c1">/// If the object is a TBits, the histogram will contain the index of the bit</span>
<span class="c1">/// that are turned on.</span>
<span class="c1">///</span>
<span class="c1">/// ## Retrieving  information about the tree itself.</span>
<span class="c1">///</span>
<span class="c1">/// You can refer to the tree (or chain) containing the data by using the</span>
<span class="c1">/// string &#39;This&#39;.</span>
<span class="c1">/// You can then could any TTree methods. For example:</span>
<span class="c1">/// ~~~ {.cpp}</span>
<span class="c1">///     tree-&gt;Draw(&quot;This-&gt;GetReadEntry()&quot;);</span>
<span class="c1">/// ~~~</span>
<span class="c1">/// will display the local entry numbers be read.</span>
<span class="c1">/// ~~~ {.cpp}</span>
<span class="c1">///     tree-&gt;Draw(&quot;This-&gt;GetUserInfo()-&gt;At(0)-&gt;GetName()&quot;);</span>
<span class="c1">/// ~~~</span>
<span class="c1">///  will display the name of the first &#39;user info&#39; object.</span>
<span class="c1">///</span>
<span class="c1">/// ## Special functions and variables</span>
<span class="c1">///</span>
<span class="c1">/// `Entry$`:  A TTree::Draw formula can use the special variable `Entry$`</span>
<span class="c1">/// to access the entry number being read. For example to draw every</span>
<span class="c1">/// other entry use:</span>
<span class="c1">/// ~~~ {.cpp}</span>
<span class="c1">///     tree.Draw(&quot;myvar&quot;,&quot;Entry$%2==0&quot;);</span>
<span class="c1">/// ~~~</span>
<span class="c1">/// - `Entry$`      : return the current entry number (`== TTree::GetReadEntry()`)</span>
<span class="c1">/// - `LocalEntry$` : return the current entry number in the current tree of a</span>
<span class="c1">///   chain (`== GetTree()-&gt;GetReadEntry()`)</span>
<span class="c1">/// - `Entries$`    : return the total number of entries (== TTree::GetEntries())</span>
<span class="c1">/// - `Length$`     : return the total number of element of this formula for this</span>
<span class="c1">///   entry (`==TTreeFormula::GetNdata()`)</span>
<span class="c1">/// - `Iteration$`  : return the current iteration over this formula for this</span>
<span class="c1">///   entry (i.e. varies from 0 to `Length$`).</span>
<span class="c1">/// - `Length$(formula )`  : return the total number of element of the formula</span>
<span class="c1">///   given as a parameter.</span>
<span class="c1">/// - `Sum$(formula )`  : return the sum of the value of the elements of the</span>
<span class="c1">///   formula given as a parameter.  For example the mean for all the elements in</span>
<span class="c1">///   one entry can be calculated with:</span>
<span class="c1">///   `Sum$(formula )/Length$(formula )`</span>
<span class="c1">/// - `Min$(formula )` : return the minimun (within one TTree entry) of the value of the</span>
<span class="c1">///    elements of the formula given as a parameter.</span>
<span class="c1">/// - `Max$(formula )` : return the maximum (within one TTree entry) of the value of the</span>
<span class="c1">///   elements of the formula given as a parameter.</span>
<span class="c1">/// - `MinIf$(formula,condition)`</span>
<span class="c1">/// - `MaxIf$(formula,condition)` : return the minimum (maximum) (within one TTree entry)</span>
<span class="c1">///   of the value of the elements of the formula given as a parameter</span>
<span class="c1">///   if they match the condition. If no element matches the condition,</span>
<span class="c1">///   the result is zero.  To avoid the resulting peak at zero, use the</span>
<span class="c1">///   pattern:</span>
<span class="c1">/// ~~~ {.cpp}</span>
<span class="c1">///        tree-&gt;Draw(&quot;MinIf$(formula,condition)&quot;,&quot;condition&quot;);</span>
<span class="c1">/// ~~~</span>
<span class="c1">///   which will avoid calculation `MinIf$` for the entries that have no match</span>
<span class="c1">///   for the condition.</span>
<span class="c1">/// - `Alt$(primary,alternate)` : return the value of &quot;primary&quot; if it is available</span>
<span class="c1">///   for the current iteration otherwise return the value of &quot;alternate&quot;.</span>
<span class="c1">///   For example, with arr1[3] and arr2[2]</span>
<span class="c1">/// ~~~ {.cpp}</span>
<span class="c1">///        tree-&gt;Draw(&quot;arr1+Alt$(arr2,0)&quot;);</span>
<span class="c1">/// ~~~</span>
<span class="c1">///   will draw arr1[0]+arr2[0] ; arr1[1]+arr2[1] and arr1[2]+0</span>
<span class="c1">///   Or with a variable size array arr3</span>
<span class="c1">/// ~~~ {.cpp}</span>
<span class="c1">///        tree-&gt;Draw(&quot;Alt$(arr3[0],0)+Alt$(arr3[1],0)+Alt$(arr3[2],0)&quot;);</span>
<span class="c1">/// ~~~</span>
<span class="c1">///   will draw the sum arr3 for the index 0 to min(2,actual_size_of_arr3-1)</span>
<span class="c1">///   As a comparison</span>
<span class="c1">/// ~~~ {.cpp}</span>
<span class="c1">///        tree-&gt;Draw(&quot;arr3[0]+arr3[1]+arr3[2]&quot;);</span>
<span class="c1">/// ~~~</span>
<span class="c1">///   will draw the sum arr3 for the index 0 to 2 only if the</span>
<span class="c1">///   actual_size_of_arr3 is greater or equal to 3.</span>
<span class="c1">///   Note that the array in &#39;primary&#39; is flattened/linearized thus using</span>
<span class="c1">///   Alt$ with multi-dimensional arrays of different dimensions in unlikely</span>
<span class="c1">///   to yield the expected results.  To visualize a bit more what elements</span>
<span class="c1">///   would be matched by TTree::Draw, TTree::Scan can be used:</span>
<span class="c1">/// ~~~ {.cpp}</span>
<span class="c1">///        tree-&gt;Scan(&quot;arr1:Alt$(arr2,0)&quot;);</span>
<span class="c1">/// ~~~</span>
<span class="c1">///   will print on one line the value of arr1 and (arr2,0) that will be</span>
<span class="c1">///   matched by</span>
<span class="c1">/// ~~~ {.cpp}</span>
<span class="c1">///        tree-&gt;Draw(&quot;arr1-Alt$(arr2,0)&quot;);</span>
<span class="c1">/// ~~~</span>
<span class="c1">/// The ternary operator is not directly supported in TTree::Draw however, to plot the</span>
<span class="c1">/// equivalent of `var2&lt;20 ? -99 : var1`, you can use:</span>
<span class="c1">/// ~~~ {.cpp}</span>
<span class="c1">///     tree-&gt;Draw(&quot;(var2&lt;20)*99+(var2&gt;=20)*var1&quot;,&quot;&quot;);</span>
<span class="c1">/// ~~~</span>
<span class="c1">/// ## Drawing a user function accessing the TTree data directly</span>
<span class="c1">///</span>
<span class="c1">/// If the formula contains  a file name, TTree::MakeProxy will be used</span>
<span class="c1">/// to load and execute this file.   In particular it will draw the</span>
<span class="c1">/// result of a function with the same name as the file.  The function</span>
<span class="c1">/// will be executed in a context where the name of the branches can</span>
<span class="c1">/// be used as a C++ variable.</span>
<span class="c1">///</span>
<span class="c1">/// For example draw px using the file hsimple.root (generated by the</span>
<span class="c1">/// hsimple.C tutorial), we need a file named hsimple.cxx:</span>
<span class="c1">/// ~~~ {.cpp}</span>
<span class="c1">///     double hsimple() {</span>
<span class="c1">///        return px;</span>
<span class="c1">///     }</span>
<span class="c1">/// ~~~</span>
<span class="c1">/// MakeProxy can then be used indirectly via the TTree::Draw interface</span>
<span class="c1">/// as follow:</span>
<span class="c1">/// ~~~ {.cpp}</span>
<span class="c1">///     new TFile(&quot;hsimple.root&quot;)</span>
<span class="c1">///     ntuple-&gt;Draw(&quot;hsimple.cxx&quot;);</span>
<span class="c1">/// ~~~</span>
<span class="c1">/// A more complete example is available in the tutorials directory:</span>
<span class="c1">/// `h1analysisProxy.cxx`, `h1analysProxy.h` and `h1analysisProxyCut.C`</span>
<span class="c1">/// which reimplement the selector found in `h1analysis.C`</span>
<span class="c1">///</span>
<span class="c1">/// The main features of this facility are:</span>
<span class="c1">///</span>
<span class="c1">///  * on-demand loading of branches</span>
<span class="c1">///  * ability to use the &#39;branchname&#39; as if it was a data member</span>
<span class="c1">///  * protection against array out-of-bound</span>
<span class="c1">///  * ability to use the branch data as object (when the user code is available)</span>
<span class="c1">///</span>
<span class="c1">///  See TTree::MakeProxy for more details.</span>
<span class="c1">///</span>
<span class="c1">/// ## Making a Profile histogram</span>
<span class="c1">///</span>
<span class="c1">///  In case of a 2-Dim expression, one can generate a TProfile histogram</span>
<span class="c1">///  instead of a TH2F histogram by specifying option=prof or option=profs</span>
<span class="c1">///  or option=profi or option=profg ; the trailing letter select the way</span>
<span class="c1">///  the bin error are computed, See TProfile2D::SetErrorOption for</span>
<span class="c1">///  details on the differences.</span>
<span class="c1">///  The option=prof is automatically selected in case of y:x&gt;&gt;pf</span>
<span class="c1">///  where pf is an existing TProfile histogram.</span>
<span class="c1">///</span>
<span class="c1">/// ## Making a 2D Profile histogram</span>
<span class="c1">///</span>
<span class="c1">/// In case of a 3-Dim expression, one can generate a TProfile2D histogram</span>
<span class="c1">/// instead of a TH3F histogram by specifying option=prof or option=profs.</span>
<span class="c1">/// or option=profi or option=profg ; the trailing letter select the way</span>
<span class="c1">/// the bin error are computed, See TProfile2D::SetErrorOption for</span>
<span class="c1">/// details on the differences.</span>
<span class="c1">/// The option=prof is automatically selected in case of z:y:x&gt;&gt;pf</span>
<span class="c1">/// where pf is an existing TProfile2D histogram.</span>
<span class="c1">///</span>
<span class="c1">/// ## Making a 5D plot using GL</span>
<span class="c1">///</span>
<span class="c1">/// If option GL5D is specified together with 5 variables, a 5D plot is drawn</span>
<span class="c1">/// using OpenGL. See $ROOTSYS/tutorials/tree/staff.C as example.</span>
<span class="c1">///</span>
<span class="c1">/// ## Making a parallel coordinates plot</span>
<span class="c1">///</span>
<span class="c1">/// In case of a 2-Dim or more expression with the option=para, one can generate</span>
<span class="c1">/// a parallel coordinates plot. With that option, the number of dimensions is</span>
<span class="c1">/// arbitrary. Giving more than 4 variables without the option=para or</span>
<span class="c1">/// option=candle or option=goff will produce an error.</span>
<span class="c1">///</span>
<span class="c1">/// ## Making a candle sticks chart</span>
<span class="c1">///</span>
<span class="c1">/// In case of a 2-Dim or more expression with the option=candle, one can generate</span>
<span class="c1">/// a candle sticks chart. With that option, the number of dimensions is</span>
<span class="c1">/// arbitrary. Giving more than 4 variables without the option=para or</span>
<span class="c1">/// option=candle or option=goff will produce an error.</span>
<span class="c1">///</span>
<span class="c1">/// ## Normalizing the output histogram to 1</span>
<span class="c1">///</span>
<span class="c1">/// When option contains &quot;norm&quot; the output histogram is normalized to 1.</span>
<span class="c1">///</span>
<span class="c1">/// ## Saving the result of Draw to a TEventList, a TEntryList or a TEntryListArray</span>
<span class="c1">///</span>
<span class="c1">/// TTree::Draw can be used to fill a TEventList object (list of entry numbers)</span>
<span class="c1">/// instead of histogramming one variable.</span>
<span class="c1">/// If varexp0 has the form &gt;&gt;elist , a TEventList object named &quot;elist&quot;</span>
<span class="c1">/// is created in the current directory. elist will contain the list</span>
<span class="c1">/// of entry numbers satisfying the current selection.</span>
<span class="c1">/// If option &quot;entrylist&quot; is used, a TEntryList object is created</span>
<span class="c1">/// If the selection contains arrays, vectors or any container class and option</span>
<span class="c1">/// &quot;entrylistarray&quot; is used, a TEntryListArray object is created</span>
<span class="c1">/// containing also the subentries satisfying the selection, i.e. the indices of</span>
<span class="c1">/// the branches which hold containers classes.</span>
<span class="c1">/// Example:</span>
<span class="c1">/// ~~~ {.cpp}</span>
<span class="c1">///     tree.Draw(&quot;&gt;&gt;yplus&quot;,&quot;y&gt;0&quot;)</span>
<span class="c1">/// ~~~</span>
<span class="c1">/// will create a TEventList object named &quot;yplus&quot; in the current directory.</span>
<span class="c1">/// In an interactive session, one can type (after TTree::Draw)</span>
<span class="c1">/// ~~~ {.cpp}</span>
<span class="c1">///     yplus.Print(&quot;all&quot;)</span>
<span class="c1">/// ~~~</span>
<span class="c1">/// to print the list of entry numbers in the list.</span>
<span class="c1">/// ~~~ {.cpp}</span>
<span class="c1">///     tree.Draw(&quot;&gt;&gt;yplus&quot;, &quot;y&gt;0&quot;, &quot;entrylist&quot;)</span>
<span class="c1">/// ~~~</span>
<span class="c1">/// will create a TEntryList object names &quot;yplus&quot; in the current directory</span>
<span class="c1">/// ~~~ {.cpp}</span>
<span class="c1">///     tree.Draw(&quot;&gt;&gt;yplus&quot;, &quot;y&gt;0&quot;, &quot;entrylistarray&quot;)</span>
<span class="c1">/// ~~~</span>
<span class="c1">/// will create a TEntryListArray object names &quot;yplus&quot; in the current directory</span>
<span class="c1">///</span>
<span class="c1">/// By default, the specified entry list is reset.</span>
<span class="c1">/// To continue to append data to an existing list, use &quot;+&quot; in front</span>
<span class="c1">/// of the list name;</span>
<span class="c1">/// ~~~ {.cpp}</span>
<span class="c1">///     tree.Draw(&quot;&gt;&gt;+yplus&quot;,&quot;y&gt;0&quot;)</span>
<span class="c1">/// ~~~</span>
<span class="c1">/// will not reset yplus, but will enter the selected entries at the end</span>
<span class="c1">/// of the existing list.</span>
<span class="c1">///</span>
<span class="c1">/// ## Using a TEventList, TEntryList or TEntryListArray as Input</span>
<span class="c1">///</span>
<span class="c1">/// Once a TEventList or a TEntryList object has been generated, it can be used as input</span>
<span class="c1">/// for TTree::Draw. Use TTree::SetEventList or TTree::SetEntryList to set the</span>
<span class="c1">/// current event list</span>
<span class="c1">///</span>
<span class="c1">/// Example 1:</span>
<span class="c1">/// ~~~ {.cpp}</span>
<span class="c1">///     TEventList *elist = (TEventList*)gDirectory-&gt;Get(&quot;yplus&quot;);</span>
<span class="c1">///     tree-&gt;SetEventList(elist);</span>
<span class="c1">///     tree-&gt;Draw(&quot;py&quot;);</span>
<span class="c1">/// ~~~</span>
<span class="c1">/// Example 2:</span>
<span class="c1">/// ~~~ {.cpp}</span>
<span class="c1">///     TEntryList *elist = (TEntryList*)gDirectory-&gt;Get(&quot;yplus&quot;);</span>
<span class="c1">///     tree-&gt;SetEntryList(elist);</span>
<span class="c1">///     tree-&gt;Draw(&quot;py&quot;);</span>
<span class="c1">/// ~~~</span>
<span class="c1">/// If a TEventList object is used as input, a new TEntryList object is created</span>
<span class="c1">/// inside the SetEventList function. In case of a TChain, all tree headers are loaded</span>
<span class="c1">/// for this transformation. This new object is owned by the chain and is deleted</span>
<span class="c1">/// with it, unless the user extracts it by calling GetEntryList() function.</span>
<span class="c1">/// See also comments to SetEventList() function of TTree and TChain.</span>
<span class="c1">///</span>
<span class="c1">/// If arrays are used in the selection criteria and TEntryListArray is not used,</span>
<span class="c1">/// all the entries that have at least one element of the array that satisfy the selection</span>
<span class="c1">/// are entered in the list.</span>
<span class="c1">///</span>
<span class="c1">/// Example:</span>
<span class="c1">/// ~~~ {.cpp}</span>
<span class="c1">///     tree.Draw(&quot;&gt;&gt;pyplus&quot;,&quot;fTracks.fPy&gt;0&quot;);</span>
<span class="c1">///     tree-&gt;SetEventList(pyplus);</span>
<span class="c1">///     tree-&gt;Draw(&quot;fTracks.fPy&quot;);</span>
<span class="c1">/// ~~~</span>
<span class="c1">///  will draw the fPy of ALL tracks in event with at least one track with</span>
<span class="c1">///  a positive fPy.</span>
<span class="c1">///</span>
<span class="c1">/// To select only the elements that did match the original selection</span>
<span class="c1">/// use TEventList::SetReapplyCut or TEntryList::SetReapplyCut.</span>
<span class="c1">///</span>
<span class="c1">/// Example:</span>
<span class="c1">/// ~~~ {.cpp}</span>
<span class="c1">///     tree.Draw(&quot;&gt;&gt;pyplus&quot;,&quot;fTracks.fPy&gt;0&quot;);</span>
<span class="c1">///     pyplus-&gt;SetReapplyCut(kTRUE);</span>
<span class="c1">///     tree-&gt;SetEventList(pyplus);</span>
<span class="c1">///     tree-&gt;Draw(&quot;fTracks.fPy&quot;);</span>
<span class="c1">/// ~~~</span>
<span class="c1">/// will draw the fPy of only the tracks that have a positive fPy.</span>
<span class="c1">///</span>
<span class="c1">/// To draw only the elements that match a selection in case of arrays,</span>
<span class="c1">/// you can also use TEntryListArray (faster in case of a more general selection).</span>
<span class="c1">///</span>
<span class="c1">/// Example:</span>
<span class="c1">/// ~~~ {.cpp}</span>
<span class="c1">///     tree.Draw(&quot;&gt;&gt;pyplus&quot;,&quot;fTracks.fPy&gt;0&quot;, &quot;entrylistarray&quot;);</span>
<span class="c1">///     tree-&gt;SetEntryList(pyplus);</span>
<span class="c1">///     tree-&gt;Draw(&quot;fTracks.fPy&quot;);</span>
<span class="c1">/// ~~~</span>
<span class="c1">/// will draw the fPy of only the tracks that have a positive fPy,</span>
<span class="c1">/// but without redoing the selection.</span>
<span class="c1">///</span>
<span class="c1">///  Note: Use tree-&gt;SetEventList(0) if you do not want use the list as input.</span>
<span class="c1">///</span>
<span class="c1">/// ## How to obtain more info from TTree::Draw</span>
<span class="c1">///</span>
<span class="c1">///  Once TTree::Draw has been called, it is possible to access useful</span>
<span class="c1">///  information still stored in the TTree object via the following functions:</span>
<span class="c1">///</span>
<span class="c1">/// - GetSelectedRows() // return the number of values accepted by the selection expression. In case where no selection was specified, returns the number of values processed.</span>
<span class="c1">/// - GetV1()           // returns a pointer to the double array of V1</span>
<span class="c1">/// - GetV2()           // returns a pointer to the double array of V2</span>
<span class="c1">/// - GetV3()           // returns a pointer to the double array of V3</span>
<span class="c1">/// - GetV4()           // returns a pointer to the double array of V4</span>
<span class="c1">/// - GetW()            // returns a pointer to the double array of Weights where weight equal the result of the selection expression.</span>
<span class="c1">///</span>
<span class="c1">/// where V1,V2,V3 correspond to the expressions in</span>
<span class="c1">/// ~~~ {.cpp}</span>
<span class="c1">///     TTree::Draw(&quot;V1:V2:V3:V4&quot;,selection);</span>
<span class="c1">/// ~~~</span>
<span class="c1">/// If the expression has more than 4 component use GetVal(index)</span>
<span class="c1">///</span>
<span class="c1">/// Example:</span>
<span class="c1">/// ~~~ {.cpp}</span>
<span class="c1">///     Root &gt; ntuple-&gt;Draw(&quot;py:px&quot;,&quot;pz&gt;4&quot;);</span>
<span class="c1">///     Root &gt; TGraph *gr = new TGraph(ntuple-&gt;GetSelectedRows(),</span>
<span class="c1">///                                   ntuple-&gt;GetV2(), ntuple-&gt;GetV1());</span>
<span class="c1">///     Root &gt; gr-&gt;Draw(&quot;ap&quot;); //draw graph in current pad</span>
<span class="c1">/// ~~~</span>
<span class="c1">/// creates a TGraph object with a number of points corresponding to the</span>
<span class="c1">/// number of entries selected by the expression &quot;pz&gt;4&quot;, the x points of the graph</span>
<span class="c1">/// being the px values of the Tree and the y points the py values.</span>
<span class="c1">///</span>
<span class="c1">/// Important note: By default TTree::Draw creates the arrays obtained</span>
<span class="c1">/// with GetW, GetV1, GetV2, GetV3, GetV4, GetVal with a length corresponding</span>
<span class="c1">/// to the parameter fEstimate.  The content will be the last `GetSelectedRows() % GetEstimate()`</span>
<span class="c1">/// values calculated.</span>
<span class="c1">/// By default fEstimate=1000000 and can be modified</span>
<span class="c1">/// via TTree::SetEstimate. To keep in memory all the results (in case</span>
<span class="c1">/// where there is only one result per entry), use</span>
<span class="c1">/// ~~~ {.cpp}</span>
<span class="c1">///     tree-&gt;SetEstimate(tree-&gt;GetEntries()+1); // same as tree-&gt;SetEstimate(-1);</span>
<span class="c1">/// ~~~</span>
<span class="c1">/// You must call SetEstimate if the expected number of selected rows</span>
<span class="c1">/// you need to look at is greater than 1000000.</span>
<span class="c1">///</span>
<span class="c1">/// You can use the option &quot;goff&quot; to turn off the graphics output</span>
<span class="c1">/// of TTree::Draw in the above example.</span>
<span class="c1">///</span>
<span class="c1">/// ## Automatic interface to TTree::Draw via the TTreeViewer</span>
<span class="c1">/// A complete graphical interface to this function is implemented</span>
<span class="c1">/// in the class TTreeViewer.</span>
<span class="c1">/// To start the TTreeViewer, three possibilities:</span>
<span class="c1">/// - select TTree context menu item &quot;StartViewer&quot;</span>
<span class="c1">/// - type the command  &quot;TTreeViewer TV(treeName)&quot;</span>
<span class="c1">/// - execute statement &quot;tree-&gt;StartViewer();&quot;</span>

   <span class="k">virtual</span> <span class="kt">void</span>            <span class="nf">DropBaskets</span><span class="p">();</span><span class="c1">/// Remove some baskets from memory.</span>
   <span class="k">virtual</span> <span class="kt">void</span>            <span class="nf">DropBuffers</span><span class="p">(</span><span class="n">Int_t</span> <span class="n">nbytes</span><span class="p">);</span><span class="c1">/// Drop branch buffers to accommodate nbytes below MaxVirtualsize.</span>
   <span class="k">virtual</span> <span class="n">Int_t</span>           <span class="nf">Fill</span><span class="p">();</span><span class="c1">//填充到buffer中，一定数量之后写入硬盘</span>
<span class="c1">/// Fill all branches.</span>
<span class="c1">/// This function loops on all the branches of this tree.  For</span>
<span class="c1">/// each branch, it copies to the branch buffer (basket) the current</span>
<span class="c1">/// values of the leaves data types. If a leaf is a simple data type,</span>
<span class="c1">/// a simple conversion to a machine independent format has to be done.</span>
<span class="c1">/// This machine independent version of the data is copied into a</span>
<span class="c1">/// basket (each branch has its own basket).  When a basket is full</span>
<span class="c1">/// (32k worth of data by default), it is then optionally compressed</span>
<span class="c1">/// and written to disk (this operation is also called committing or</span>
<span class="c1">/// &#39;flushing&#39; the basket).  The committed baskets are then</span>
<span class="c1">/// immediately removed from memory.</span>
<span class="c1">/// The function returns the number of bytes committed to the</span>
<span class="c1">/// individual branches.</span>
<span class="c1">/// If a write error occurs, the number of bytes returned is -1.</span>
<span class="c1">/// If no data are written, because, e.g., the branch is disabled,</span>
<span class="c1">/// the number of bytes returned is 0.</span>
<span class="c1">/// __The baskets are flushed and the Tree header saved at regular intervals__</span>
<span class="c1">/// At regular intervals, when the amount of data written so far is</span>
<span class="c1">/// greater than fAutoFlush (see SetAutoFlush) all the baskets are flushed to disk.</span>
<span class="c1">/// This makes future reading faster as it guarantees that baskets belonging to nearby</span>
<span class="c1">/// entries will be on the same disk region.</span>
<span class="c1">/// When the first call to flush the baskets happen, we also take this opportunity</span>
<span class="c1">/// to optimize the baskets buffers.</span>
<span class="c1">/// We also check if the amount of data written is greater than fAutoSave (see SetAutoSave).</span>
<span class="c1">/// In this case we also write the Tree header. This makes the Tree recoverable up to this point</span>
<span class="c1">/// in case the program writing the Tree crashes.</span>
<span class="c1">/// The decisions to FlushBaskets and Auto Save can be made based either on the number</span>
<span class="c1">/// of bytes written (fAutoFlush and fAutoSave negative) or on the number of entries</span>
<span class="c1">/// written (fAutoFlush and fAutoSave positive).</span>
<span class="c1">/// Note that the user can decide to call FlushBaskets and AutoSave in her event loop</span>
<span class="c1">/// base on the number of events written instead of the number of bytes written.</span>
<span class="c1">/// Note that calling FlushBaskets too often increases the IO time.</span>
<span class="c1">/// Note that calling AutoSave too often increases the IO time and also the file size.</span>

   <span class="k">virtual</span> <span class="n">TBranch</span>        <span class="o">*</span><span class="nf">FindBranch</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">name</span><span class="p">);</span>
<span class="c1">/// Return the branch that correspond to the path &#39;branchname&#39;, which can</span>
<span class="c1">/// include the name of the tree or the omitted name of the parent branches.</span>
<span class="c1">/// In case of ambiguity, returns the first match.</span>

   <span class="k">virtual</span> <span class="n">TLeaf</span>          <span class="o">*</span><span class="nf">FindLeaf</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">name</span><span class="p">);</span><span class="c1">/// Find leaf..</span>
   <span class="k">virtual</span> <span class="n">Int_t</span>           <span class="nf">Fit</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">funcname</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">varexp</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">selection</span> <span class="o">=</span> <span class="s">&quot;&quot;</span><span class="p">,</span> <span class="n">Option_t</span><span class="o">*</span> <span class="n">option</span> <span class="o">=</span> <span class="s">&quot;&quot;</span><span class="p">,</span> <span class="n">Option_t</span><span class="o">*</span> <span class="n">goption</span> <span class="o">=</span> <span class="s">&quot;&quot;</span><span class="p">,</span> <span class="n">Long64_t</span> <span class="n">nentries</span> <span class="o">=</span> <span class="n">kMaxEntries</span><span class="p">,</span> <span class="n">Long64_t</span> <span class="n">firstentry</span> <span class="o">=</span> <span class="mi">0</span><span class="p">);</span> <span class="c1">// *MENU*</span>
<span class="c1">/// Fit  a projected item(s) from a tree.</span>
<span class="c1">/// funcname is a TF1 function.</span>
<span class="c1">/// See TTree::Draw() for explanations of the other parameters.</span>
<span class="c1">/// By default the temporary histogram created is called htemp.</span>
<span class="c1">/// If varexp contains &gt;&gt;hnew , the new histogram created is called hnew</span>
<span class="c1">/// and it is kept in the current directory.</span>
<span class="c1">/// The function returns the number of selected entries.</span>
<span class="c1">/// ## Return status</span>
<span class="c1">///  The function returns the status of the histogram fit (see TH1::Fit)</span>
<span class="c1">///  If no entries were selected, the function returns -1;</span>
<span class="c1">///   (i.e. fitResult is null is the fit is OK)</span>

   <span class="k">virtual</span> <span class="n">Int_t</span>           <span class="nf">FlushBaskets</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
<span class="c1">/// Write to disk all the basket that have not yet been individually written.</span>
<span class="c1">/// Return the number of bytes written or -1 in case of write error.</span>

   <span class="k">virtual</span> <span class="k">const</span> <span class="kt">char</span>     <span class="o">*</span><span class="nf">GetAlias</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">aliasName</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span><span class="c1">/// Returns the expanded value of the alias.  Search in the friends if any.</span>
   <span class="k">virtual</span> <span class="n">Long64_t</span>        <span class="nf">GetAutoFlush</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span><span class="k">return</span> <span class="n">fAutoFlush</span><span class="p">;}</span>
   <span class="k">virtual</span> <span class="n">Long64_t</span>        <span class="nf">GetAutoSave</span><span class="p">()</span>  <span class="k">const</span> <span class="p">{</span><span class="k">return</span> <span class="n">fAutoSave</span><span class="p">;}</span>
   <span class="k">virtual</span> <span class="n">TBranch</span>        <span class="o">*</span><span class="nf">GetBranch</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">name</span><span class="p">);</span><span class="c1">/// Return pointer to the branch with the given name in this tree or its friends.</span>
   <span class="k">virtual</span> <span class="n">TBranchRef</span>     <span class="o">*</span><span class="nf">GetBranchRef</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">fBranchRef</span><span class="p">;</span> <span class="p">};</span>
   <span class="k">virtual</span> <span class="n">Bool_t</span>          <span class="nf">GetBranchStatus</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">branchname</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
<span class="c1">/// Return status of branch with name branchname.</span>
<span class="c1">/// - 0 if branch is not activated</span>
<span class="c1">/// - 1 if branch is activated</span>

   <span class="k">static</span>  <span class="n">Int_t</span>           <span class="nf">GetBranchStyle</span><span class="p">();</span>
<span class="c1">/// Static function returning the current branch style.</span>
<span class="c1">/// - style = 0 old Branch</span>
<span class="c1">/// - style = 1 new Bronch</span>

   <span class="k">virtual</span> <span class="n">Long64_t</span>        <span class="nf">GetCacheSize</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">fCacheSize</span><span class="p">;</span> <span class="p">}</span>
   <span class="k">virtual</span> <span class="n">TClusterIterator</span> <span class="nf">GetClusterIterator</span><span class="p">(</span><span class="n">Long64_t</span> <span class="n">firstentry</span><span class="p">);</span>
<span class="c1">/// Return an iterator over the cluster of baskets starting at firstentry.</span>
<span class="c1">/// This iterator is not yet supported for TChain object.</span>

   <span class="k">virtual</span> <span class="n">Long64_t</span>        <span class="nf">GetChainEntryNumber</span><span class="p">(</span><span class="n">Long64_t</span> <span class="n">entry</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">entry</span><span class="p">;</span> <span class="p">}</span>
   <span class="k">virtual</span> <span class="n">Long64_t</span>        <span class="nf">GetChainOffset</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">fChainOffset</span><span class="p">;</span> <span class="p">}</span>
   <span class="n">TFile</span>                  <span class="o">*</span><span class="nf">GetCurrentFile</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span><span class="c1">/// Return pointer to the current file.</span>
           <span class="n">Int_t</span>           <span class="nf">GetDefaultEntryOffsetLen</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span><span class="k">return</span> <span class="n">fDefaultEntryOffsetLen</span><span class="p">;}</span>
           <span class="n">Long64_t</span>        <span class="nf">GetDebugMax</span><span class="p">()</span>  <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">fDebugMax</span><span class="p">;</span> <span class="p">}</span>
           <span class="n">Long64_t</span>        <span class="nf">GetDebugMin</span><span class="p">()</span>  <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">fDebugMin</span><span class="p">;</span> <span class="p">}</span>
   <span class="n">TDirectory</span>             <span class="o">*</span><span class="nf">GetDirectory</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">fDirectory</span><span class="p">;</span> <span class="p">}</span>
   <span class="k">virtual</span> <span class="n">Long64_t</span>        <span class="nf">GetEntries</span><span class="p">()</span> <span class="k">const</span>   <span class="p">{</span> <span class="k">return</span> <span class="n">fEntries</span><span class="p">;</span> <span class="p">}</span><span class="c1">//获取entry数</span>
   <span class="k">virtual</span> <span class="n">Long64_t</span>        <span class="nf">GetEntries</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">selection</span><span class="p">);</span>
<span class="c1">/// Return the number of entries matching the selection.</span>
<span class="c1">/// Return -1 in case of errors.</span>
<span class="c1">/// If the selection uses any arrays or containers, we return the number</span>
<span class="c1">/// of entries where at least one element match the selection.</span>
<span class="c1">/// GetEntries is implemented using the selector class TSelectorEntries,</span>
<span class="c1">/// which can be used directly (see code in TTreePlayer::GetEntries) for</span>
<span class="c1">/// additional option.</span>
<span class="c1">/// If SetEventList was used on the TTree or TChain, only that subset</span>
<span class="c1">/// of entries will be considered.</span>

   <span class="k">virtual</span> <span class="n">Long64_t</span>        <span class="nf">GetEntriesFast</span><span class="p">()</span> <span class="k">const</span>   <span class="p">{</span> <span class="k">return</span> <span class="n">fEntries</span><span class="p">;</span> <span class="p">}</span>
   <span class="k">virtual</span> <span class="n">Long64_t</span>        <span class="nf">GetEntriesFriend</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
<span class="c1">/// Return pointer to the 1st Leaf named name in any Branch of this Tree or</span>
<span class="c1">/// any branch in the list of friend trees.</span>

   <span class="k">virtual</span> <span class="n">Long64_t</span>        <span class="nf">GetEstimate</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">fEstimate</span><span class="p">;</span> <span class="p">}</span>
   <span class="k">virtual</span> <span class="n">Int_t</span>           <span class="nf">GetEntry</span><span class="p">(</span><span class="n">Long64_t</span> <span class="n">entry</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">Int_t</span> <span class="n">getall</span> <span class="o">=</span> <span class="mi">0</span><span class="p">);</span>
<span class="c1">/// Read all branches of entry and return total number of bytes read.</span>
<span class="c1">/// - getall = 0 : get only active branches</span>
<span class="c1">/// - getall = 1 : get all branches</span>
<span class="c1">/// The function returns the number of bytes read from the input buffer.</span>
<span class="c1">/// If entry does not exist the function returns 0.</span>
<span class="c1">/// If an I/O error occurs, the function returns -1.</span>
<span class="c1">/// If the Tree has friends, also read the friends entry.</span>
<span class="c1">/// ## IMPORTANT NOTE</span>
<span class="c1">///</span>
<span class="c1">/// By default, GetEntry reuses the space allocated by the previous object</span>
<span class="c1">/// for each branch. You can force the previous object to be automatically</span>
<span class="c1">/// deleted if you call mybranch.SetAutoDelete(kTRUE) (default is kFALSE).</span>

           <span class="n">Int_t</span>           <span class="nf">GetEvent</span><span class="p">(</span><span class="n">Long64_t</span> <span class="n">entry</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">Int_t</span> <span class="n">getall</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">GetEntry</span><span class="p">(</span><span class="n">entry</span><span class="p">,</span> <span class="n">getall</span><span class="p">);</span> <span class="p">}</span>
   <span class="k">virtual</span> <span class="n">Int_t</span>           <span class="nf">GetEntryWithIndex</span><span class="p">(</span><span class="n">Int_t</span> <span class="n">major</span><span class="p">,</span> <span class="n">Int_t</span> <span class="n">minor</span> <span class="o">=</span> <span class="mi">0</span><span class="p">);</span>
<span class="c1">/// Read entry corresponding to major and minor number.</span>
<span class="c1">///  The function returns the total number of bytes read.</span>
<span class="c1">///  If the Tree has friend trees, the corresponding entry with</span>
<span class="c1">///  the index values (major,minor) is read. Note that the master Tree</span>
<span class="c1">///  and its friend may have different entry serial numbers corresponding</span>
<span class="c1">///  to (major,minor).</span>

   <span class="k">virtual</span> <span class="n">Long64_t</span>        <span class="nf">GetEntryNumberWithBestIndex</span><span class="p">(</span><span class="n">Long64_t</span> <span class="n">major</span><span class="p">,</span> <span class="n">Long64_t</span> <span class="n">minor</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
<span class="c1">/// Return entry number corresponding to major and minor number.</span>
<span class="c1">/// Note that this function returns only the entry number, not the data</span>
<span class="c1">/// To read the data corresponding to an entry number, use TTree::GetEntryWithIndex</span>
<span class="c1">/// the BuildIndex function has created a table of Long64_t* of sorted values</span>
<span class="c1">/// corresponding to val = major&lt;&lt;31 + minor;</span>
<span class="c1">/// The function performs binary search in this sorted table.</span>
<span class="c1">/// If it finds a pair that matches val, it returns directly the</span>
<span class="c1">/// index in the table.</span>
<span class="c1">/// If an entry corresponding to major and minor is not found, the function</span>
<span class="c1">/// returns the index of the major,minor pair immediately lower than the</span>
<span class="c1">/// requested value, ie it will return -1 if the pair is lower than</span>
<span class="c1">/// the first entry in the index.</span>
<span class="c1">/// See also GetEntryNumberWithIndex</span>

   <span class="k">virtual</span> <span class="n">Long64_t</span>        <span class="nf">GetEntryNumberWithIndex</span><span class="p">(</span><span class="n">Long64_t</span> <span class="n">major</span><span class="p">,</span> <span class="n">Long64_t</span> <span class="n">minor</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
<span class="c1">/// Return entry number corresponding to major and minor number.</span>
<span class="c1">/// Note that this function returns only the entry number, not the data</span>
<span class="c1">/// To read the data corresponding to an entry number, use TTree::GetEntryWithIndex</span>
<span class="c1">/// the BuildIndex function has created a table of Long64_t* of sorted values</span>
<span class="c1">/// corresponding to val = major&lt;&lt;31 + minor;</span>
<span class="c1">/// The function performs binary search in this sorted table.</span>
<span class="c1">/// If it finds a pair that matches val, it returns directly the</span>
<span class="c1">/// index in the table, otherwise it returns -1.</span>
<span class="c1">/// See also GetEntryNumberWithBestIndex</span>

   <span class="n">TEventList</span>             <span class="o">*</span><span class="nf">GetEventList</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">fEventList</span><span class="p">;</span> <span class="p">}</span>
   <span class="k">virtual</span> <span class="n">TEntryList</span>     <span class="o">*</span><span class="nf">GetEntryList</span><span class="p">();</span><span class="c1">///Returns the entry list, set to this tree</span>
   <span class="k">virtual</span> <span class="n">Long64_t</span>        <span class="nf">GetEntryNumber</span><span class="p">(</span><span class="n">Long64_t</span> <span class="n">entry</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
<span class="c1">/// Return entry number corresponding to entry.</span>
<span class="c1">/// if no TEntryList set returns entry</span>
<span class="c1">/// else returns the entry number corresponding to the list index=entry</span>

   <span class="k">virtual</span> <span class="n">Int_t</span>           <span class="nf">GetFileNumber</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">fFileNumber</span><span class="p">;</span> <span class="p">}</span>
   <span class="k">virtual</span> <span class="n">TTree</span>          <span class="o">*</span><span class="nf">GetFriend</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span><span class="c1">/// Return a pointer to the TTree friend whose name or alias is &#39;friendname.</span>
   <span class="k">virtual</span> <span class="k">const</span> <span class="kt">char</span>     <span class="o">*</span><span class="nf">GetFriendAlias</span><span class="p">(</span><span class="n">TTree</span><span class="o">*</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
<span class="c1">/// If the &#39;tree&#39; is a friend, this method returns its alias name.</span>
<span class="c1">/// This alias is an alternate name for the tree.</span>
<span class="c1">/// It can be used in conjunction with a branch or leaf name in a TTreeFormula,</span>
<span class="c1">/// to specify in which particular tree the branch or leaf can be found if</span>
<span class="c1">/// the friend trees have branches or leaves with the same name as the master</span>
<span class="c1">/// tree.</span>
<span class="c1">/// It can also be used in conjunction with an alias created using</span>
<span class="c1">/// TTree::SetAlias in a TTreeFormula, e.g.:</span>
<span class="c1">///      maintree-&gt;Draw(&quot;treealias.fPx - treealias.myAlias&quot;);</span>
<span class="c1">/// where fPx is a branch of the friend tree aliased as &#39;treealias&#39; and &#39;myAlias&#39;</span>
<span class="c1">/// was created using TTree::SetAlias on the friend tree.</span>
<span class="c1">/// However, note that &#39;treealias.myAlias&#39; will be expanded literally,</span>
<span class="c1">/// without remembering that it comes from the aliased friend and thus</span>
<span class="c1">/// the branch name might not be disambiguated properly, which means</span>
<span class="c1">/// that you may not be able to take advantage of this feature.</span>

   <span class="n">TH1</span>                    <span class="o">*</span><span class="nf">GetHistogram</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="n">GetPlayer</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">GetHistogram</span><span class="p">();</span> <span class="p">}</span>
   <span class="k">virtual</span> <span class="n">Int_t</span>          <span class="o">*</span><span class="nf">GetIndex</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="o">&amp;</span><span class="n">fIndex</span><span class="p">.</span><span class="n">fArray</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span> <span class="p">}</span>
   <span class="k">virtual</span> <span class="n">Double_t</span>       <span class="o">*</span><span class="nf">GetIndexValues</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="o">&amp;</span><span class="n">fIndexValues</span><span class="p">.</span><span class="n">fArray</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span> <span class="p">}</span>
   <span class="k">virtual</span> <span class="n">TIterator</span>      <span class="o">*</span><span class="nf">GetIteratorOnAllLeaves</span><span class="p">(</span><span class="n">Bool_t</span> <span class="n">dir</span> <span class="o">=</span> <span class="n">kIterForward</span><span class="p">);</span>
<span class="c1">/// Creates a new iterator that will go through all the leaves on the tree itself and its friend.</span>
   
   <span class="k">virtual</span> <span class="n">TLeaf</span>          <span class="o">*</span><span class="nf">GetLeaf</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">branchname</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">leafname</span><span class="p">);</span>
<span class="c1">/// Return pointer to the 1st Leaf named name in any Branch of this</span>
<span class="c1">/// Tree or any branch in the list of friend trees.</span>
<span class="c1">/// The leaf name can contain the name of a friend tree with the</span>
<span class="c1">/// syntax: friend_dir_and_tree.full_leaf_name</span>
<span class="c1">/// the friend_dir_and_tree can be of the form:</span>
<span class="c1">///     TDirectoryName/TreeName</span>

   <span class="k">virtual</span> <span class="n">TLeaf</span>          <span class="o">*</span><span class="nf">GetLeaf</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">name</span><span class="p">);</span>
<span class="c1">/// Return pointer to the 1st Leaf named name in any Branch of this</span>
<span class="c1">/// Tree or any branch in the list of friend trees.</span>
<span class="c1">/// aname may be of the form branchname/leafname</span>

   <span class="k">virtual</span> <span class="n">TList</span>          <span class="o">*</span><span class="nf">GetListOfClones</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="n">fClones</span><span class="p">;</span> <span class="p">}</span>
   <span class="k">virtual</span> <span class="n">TObjArray</span>      <span class="o">*</span><span class="nf">GetListOfBranches</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="o">&amp;</span><span class="n">fBranches</span><span class="p">;</span> <span class="p">}</span>
   <span class="k">virtual</span> <span class="n">TObjArray</span>      <span class="o">*</span><span class="nf">GetListOfLeaves</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="o">&amp;</span><span class="n">fLeaves</span><span class="p">;</span> <span class="p">}</span>
   <span class="k">virtual</span> <span class="n">TList</span>          <span class="o">*</span><span class="nf">GetListOfFriends</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">fFriends</span><span class="p">;</span> <span class="p">}</span>
   <span class="k">virtual</span> <span class="n">TList</span>          <span class="o">*</span><span class="nf">GetListOfAliases</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">fAliases</span><span class="p">;</span> <span class="p">}</span>

   <span class="c1">// GetMakeClass is left non-virtual for efficiency reason.</span>
   <span class="c1">// Making it virtual affects the performance of the I/O</span>
           <span class="n">Int_t</span>           <span class="nf">GetMakeClass</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">fMakeClass</span><span class="p">;</span> <span class="p">}</span>

   <span class="k">virtual</span> <span class="n">Long64_t</span>        <span class="nf">GetMaxEntryLoop</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">fMaxEntryLoop</span><span class="p">;</span> <span class="p">}</span>
   <span class="k">virtual</span> <span class="n">Double_t</span>        <span class="nf">GetMaximum</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">columname</span><span class="p">);</span>
<span class="c1">/// Return maximum of column with name columname.</span>
<span class="c1">/// if the Tree has an associated TEventList or TEntryList, the maximum</span>
<span class="c1">/// is computed for the entries in this list.</span>

   <span class="k">static</span>  <span class="n">Long64_t</span>        <span class="nf">GetMaxTreeSize</span><span class="p">();</span><span class="c1">/// Static function which returns the tree file size limit in bytes.</span>
   <span class="k">virtual</span> <span class="n">Long64_t</span>        <span class="nf">GetMaxVirtualSize</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">fMaxVirtualSize</span><span class="p">;</span> <span class="p">}</span>
   <span class="k">virtual</span> <span class="n">Double_t</span>        <span class="nf">GetMinimum</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">columname</span><span class="p">);</span>
<span class="c1">/// Return minimum of column with name columname.</span>
<span class="c1">/// if the Tree has an associated TEventList or TEntryList, the minimum</span>
<span class="c1">/// is computed for the entries in this list.</span>

   <span class="k">virtual</span> <span class="n">Int_t</span>           <span class="nf">GetNbranches</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="n">fBranches</span><span class="p">.</span><span class="n">GetEntriesFast</span><span class="p">();</span> <span class="p">}</span>
   <span class="n">TObject</span>                <span class="o">*</span><span class="nf">GetNotify</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">fNotify</span><span class="p">;</span> <span class="p">}</span>
   <span class="n">TVirtualTreePlayer</span>     <span class="o">*</span><span class="nf">GetPlayer</span><span class="p">();</span><span class="c1">/// Load the TTreePlayer (if not already done).</span>
   <span class="k">virtual</span> <span class="n">Int_t</span>           <span class="nf">GetPacketSize</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">fPacketSize</span><span class="p">;</span> <span class="p">}</span>
   <span class="k">virtual</span> <span class="n">TVirtualPerfStats</span> <span class="o">*</span><span class="nf">GetPerfStats</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">fPerfStats</span><span class="p">;</span> <span class="p">}</span>
   <span class="k">virtual</span> <span class="n">Long64_t</span>        <span class="nf">GetReadEntry</span><span class="p">()</span>  <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">fReadEntry</span><span class="p">;</span> <span class="p">}</span>
   <span class="k">virtual</span> <span class="n">Long64_t</span>        <span class="nf">GetReadEvent</span><span class="p">()</span>  <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">fReadEntry</span><span class="p">;</span> <span class="p">}</span>
   <span class="k">virtual</span> <span class="n">Int_t</span>           <span class="nf">GetScanField</span><span class="p">()</span>  <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">fScanField</span><span class="p">;</span> <span class="p">}</span>
   <span class="n">TTreeFormula</span>           <span class="o">*</span><span class="nf">GetSelect</span><span class="p">()</span>    <span class="p">{</span> <span class="k">return</span> <span class="n">GetPlayer</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">GetSelect</span><span class="p">();</span> <span class="p">}</span>
   <span class="k">virtual</span> <span class="n">Long64_t</span>        <span class="nf">GetSelectedRows</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="n">GetPlayer</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">GetSelectedRows</span><span class="p">();</span> <span class="p">}</span>
   <span class="k">virtual</span> <span class="n">Int_t</span>           <span class="nf">GetTimerInterval</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">fTimerInterval</span><span class="p">;</span> <span class="p">}</span>
           <span class="n">TBuffer</span><span class="o">*</span>        <span class="nf">GetTransientBuffer</span><span class="p">(</span><span class="n">Int_t</span> <span class="n">size</span><span class="p">);</span>
<span class="c1">/// Returns the transient buffer currently used by this TTree for reading/writing baskets.</span>

   <span class="k">virtual</span> <span class="n">Long64_t</span>        <span class="nf">GetTotBytes</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">fTotBytes</span><span class="p">;</span> <span class="p">}</span>
   <span class="k">virtual</span> <span class="n">TTree</span>          <span class="o">*</span><span class="nf">GetTree</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="k">const_cast</span><span class="o">&lt;</span><span class="n">TTree</span><span class="o">*&gt;</span><span class="p">(</span><span class="k">this</span><span class="p">);</span> <span class="p">}</span>
   <span class="k">virtual</span> <span class="n">TVirtualIndex</span>  <span class="o">*</span><span class="nf">GetTreeIndex</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">fTreeIndex</span><span class="p">;</span> <span class="p">}</span>
   <span class="k">virtual</span> <span class="n">Int_t</span>           <span class="nf">GetTreeNumber</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span> <span class="p">}</span>
   <span class="k">virtual</span> <span class="n">Int_t</span>           <span class="nf">GetUpdate</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">fUpdate</span><span class="p">;</span> <span class="p">}</span>
   <span class="k">virtual</span> <span class="n">TList</span>          <span class="o">*</span><span class="nf">GetUserInfo</span><span class="p">();</span>
<span class="c1">/// Return a pointer to the list containing user objects associated to this tree.</span>
<span class="c1">/// The list is automatically created if it does not exist.</span>
<span class="c1">/// WARNING: By default the TTree destructor will delete all objects added</span>
<span class="c1">/// to this list. If you do not want these objects to be deleted,</span>
<span class="c1">/// call:</span>
<span class="c1">///     mytree-&gt;GetUserInfo()-&gt;Clear();</span>
<span class="c1">/// before deleting the tree.</span>

   <span class="c1">// See TSelectorDraw::GetVar</span>
   <span class="n">TTreeFormula</span>           <span class="o">*</span><span class="nf">GetVar</span><span class="p">(</span><span class="n">Int_t</span> <span class="n">i</span><span class="p">)</span>  <span class="p">{</span> <span class="k">return</span> <span class="n">GetPlayer</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">GetVar</span><span class="p">(</span><span class="n">i</span><span class="p">);</span> <span class="p">}</span>
   <span class="c1">// See TSelectorDraw::GetVar</span>
   <span class="n">TTreeFormula</span>           <span class="o">*</span><span class="nf">GetVar1</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="n">GetPlayer</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">GetVar1</span><span class="p">();</span> <span class="p">}</span>
   <span class="c1">// See TSelectorDraw::GetVar</span>
   <span class="n">TTreeFormula</span>           <span class="o">*</span><span class="nf">GetVar2</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="n">GetPlayer</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">GetVar2</span><span class="p">();</span> <span class="p">}</span>
   <span class="c1">// See TSelectorDraw::GetVar</span>
   <span class="n">TTreeFormula</span>           <span class="o">*</span><span class="nf">GetVar3</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="n">GetPlayer</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">GetVar3</span><span class="p">();</span> <span class="p">}</span>
   <span class="c1">// See TSelectorDraw::GetVar</span>
   <span class="n">TTreeFormula</span>           <span class="o">*</span><span class="nf">GetVar4</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="n">GetPlayer</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">GetVar4</span><span class="p">();</span> <span class="p">}</span>
   <span class="c1">// See TSelectorDraw::GetVal</span>
   <span class="k">virtual</span> <span class="n">Double_t</span>       <span class="o">*</span><span class="nf">GetVal</span><span class="p">(</span><span class="n">Int_t</span> <span class="n">i</span><span class="p">)</span>   <span class="p">{</span> <span class="k">return</span> <span class="n">GetPlayer</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">GetVal</span><span class="p">(</span><span class="n">i</span><span class="p">);</span> <span class="p">}</span>
   <span class="c1">// See TSelectorDraw::GetVal</span>
   <span class="k">virtual</span> <span class="n">Double_t</span>       <span class="o">*</span><span class="nf">GetV1</span><span class="p">()</span>   <span class="p">{</span> <span class="k">return</span> <span class="n">GetPlayer</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">GetV1</span><span class="p">();</span> <span class="p">}</span>
   <span class="c1">// See TSelectorDraw::GetVal</span>
   <span class="k">virtual</span> <span class="n">Double_t</span>       <span class="o">*</span><span class="nf">GetV2</span><span class="p">()</span>   <span class="p">{</span> <span class="k">return</span> <span class="n">GetPlayer</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">GetV2</span><span class="p">();</span> <span class="p">}</span>
   <span class="c1">// See TSelectorDraw::GetVal</span>
   <span class="k">virtual</span> <span class="n">Double_t</span>       <span class="o">*</span><span class="nf">GetV3</span><span class="p">()</span>   <span class="p">{</span> <span class="k">return</span> <span class="n">GetPlayer</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">GetV3</span><span class="p">();</span> <span class="p">}</span>
   <span class="c1">// See TSelectorDraw::GetVal</span>
   <span class="k">virtual</span> <span class="n">Double_t</span>       <span class="o">*</span><span class="nf">GetV4</span><span class="p">()</span>   <span class="p">{</span> <span class="k">return</span> <span class="n">GetPlayer</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">GetV4</span><span class="p">();</span> <span class="p">}</span>
   <span class="k">virtual</span> <span class="n">Double_t</span>       <span class="o">*</span><span class="nf">GetW</span><span class="p">()</span>    <span class="p">{</span> <span class="k">return</span> <span class="n">GetPlayer</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">GetW</span><span class="p">();</span> <span class="p">}</span>
   <span class="k">virtual</span> <span class="n">Double_t</span>        <span class="nf">GetWeight</span><span class="p">()</span> <span class="k">const</span>   <span class="p">{</span> <span class="k">return</span> <span class="n">fWeight</span><span class="p">;</span> <span class="p">}</span>
   <span class="k">virtual</span> <span class="n">Long64_t</span>        <span class="nf">GetZipBytes</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">fZipBytes</span><span class="p">;</span> <span class="p">}</span>
   <span class="k">virtual</span> <span class="kt">void</span>            <span class="nf">IncrementTotalBuffers</span><span class="p">(</span><span class="n">Int_t</span> <span class="n">nbytes</span><span class="p">)</span> <span class="p">{</span> <span class="n">fTotalBuffers</span> <span class="o">+=</span> <span class="n">nbytes</span><span class="p">;</span> <span class="p">}</span>
   <span class="n">Bool_t</span>                  <span class="nf">IsFolder</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">kTRUE</span><span class="p">;</span> <span class="p">}</span>
   <span class="k">virtual</span> <span class="n">Int_t</span>           <span class="nf">LoadBaskets</span><span class="p">(</span><span class="n">Long64_t</span> <span class="n">maxmemory</span> <span class="o">=</span> <span class="mi">2000000000</span><span class="p">);</span>
<span class="c1">/// Read in memory all baskets from all branches up to the limit of maxmemory bytes.</span>
<span class="c1">/// If maxmemory is non null and positive SetMaxVirtualSize is called</span>
<span class="c1">/// with this value. Default for maxmemory is 2000000000 (2 Gigabytes).</span>
<span class="c1">/// The function returns the total number of baskets read into memory</span>
<span class="c1">/// if negative an error occurred while loading the branches.</span>
<span class="c1">/// This method may be called to force branch baskets in memory</span>
<span class="c1">/// when random access to branch entries is required.</span>
<span class="c1">/// If random access to only a few branches is required, you should</span>
<span class="c1">/// call directly TBranch::LoadBaskets.</span>

   <span class="k">virtual</span> <span class="n">Long64_t</span>        <span class="nf">LoadTree</span><span class="p">(</span><span class="n">Long64_t</span> <span class="n">entry</span><span class="p">);</span>
<span class="c1">/// Set current entry.</span>
<span class="c1">/// Returns -2 if entry does not exist (just as TChain::LoadTree()).</span>
<span class="c1">/// Note: This function is overloaded in TChain.</span>

   <span class="k">virtual</span> <span class="n">Long64_t</span>        <span class="nf">LoadTreeFriend</span><span class="p">(</span><span class="n">Long64_t</span> <span class="n">entry</span><span class="p">,</span> <span class="n">TTree</span><span class="o">*</span> <span class="n">T</span><span class="p">);</span>
<span class="c1">/// Load entry on behalf of our master tree, we may use an index.</span>
<span class="c1">/// Called by LoadTree() when the masterTree looks for the entry</span>
<span class="c1">/// number in a friend tree (us) corresponding to the passed entry</span>
<span class="c1">/// number in the masterTree.</span>
<span class="c1">/// If we have no index, our entry number and the masterTree entry</span>
<span class="c1">/// number are the same.</span>
<span class="c1">/// If we *do* have an index, we must find the (major, minor) value pair</span>
<span class="c1">/// in masterTree to locate our corresponding entry.</span>

   <span class="k">virtual</span> <span class="n">Int_t</span>           <span class="nf">MakeClass</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">classname</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">Option_t</span><span class="o">*</span> <span class="n">option</span> <span class="o">=</span> <span class="s">&quot;&quot;</span><span class="p">);</span>
<span class="c1">/// Generate a skeleton analysis class for this tree.</span>
<span class="c1">/// The following files are produced: classname.h and classname.C.</span>
<span class="c1">/// If classname is 0, classname will be called &quot;nameoftree&quot;.</span>
<span class="c1">/// The generated code in classname.h includes the following:</span>
<span class="c1">/// - Identification of the original tree and the input file name.</span>
<span class="c1">/// - Definition of an analysis class (data members and member functions).</span>
<span class="c1">/// - The following member functions:</span>
<span class="c1">///   - constructor (by default opening the tree file),</span>
<span class="c1">///   - GetEntry(Long64_t entry),</span>
<span class="c1">///   - Init(TTree* tree) to initialize a new TTree,</span>
<span class="c1">///   - Show(Long64_t entry) to read and dump entry.</span>
<span class="c1">/// The generated code in classname.C includes only the main</span>
<span class="c1">/// analysis function Loop.</span>
<span class="c1">/// NOTE: Do not use the code generated for a single TTree which is part</span>
<span class="c1">/// of a TChain to process that entire TChain.  The maximum dimensions</span>
<span class="c1">/// calculated for arrays on the basis of a single TTree from the TChain</span>
<span class="c1">/// might be (will be!) too small when processing all of the TTrees in</span>
<span class="c1">/// the TChain.  You must use myChain.MakeClass() to generate the code,</span>
<span class="c1">/// not myTree.MakeClass(...).</span>

   <span class="k">virtual</span> <span class="n">Int_t</span>           <span class="nf">MakeCode</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">filename</span> <span class="o">=</span> <span class="mi">0</span><span class="p">);</span>
<span class="c1">/// Generate a skeleton function for this tree.</span>
<span class="c1">/// The function code is written on filename.</span>
<span class="c1">/// If filename is 0, filename will be called nameoftree.C</span>
<span class="c1">/// The generated code includes the following:</span>
<span class="c1">/// - Identification of the original Tree and Input file name,</span>
<span class="c1">/// - Opening the Tree file,</span>
<span class="c1">/// - Declaration of Tree variables,</span>
<span class="c1">/// - Setting of branches addresses,</span>
<span class="c1">/// - A skeleton for the entry loop.</span>
<span class="c1">/// To use this function:</span>
<span class="c1">/// - Open your Tree file (eg: TFile f(&quot;myfile.root&quot;);)</span>
<span class="c1">/// - T-&gt;MakeCode(&quot;MyAnalysis.C&quot;);</span>
<span class="c1">/// where T is the name of the TTree in file myfile.root</span>
<span class="c1">/// and MyAnalysis.C the name of the file created by this function.</span>
<span class="c1">/// NOTE: Since the implementation of this function, a new and better</span>
<span class="c1">/// function TTree::MakeClass() has been developed.</span>

   <span class="k">virtual</span> <span class="n">Int_t</span>           <span class="nf">MakeProxy</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">classname</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">macrofilename</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">cutfilename</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">option</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">Int_t</span> <span class="n">maxUnrolling</span> <span class="o">=</span> <span class="mi">3</span><span class="p">);</span>
<span class="c1">/// Generate a skeleton analysis class for this Tree using TBranchProxy.</span>
<span class="c1">/// TBranchProxy is the base of a class hierarchy implementing an</span>
<span class="c1">/// indirect access to the content of the branches of a TTree.</span>
<span class="c1">/// &quot;proxyClassname&quot; is expected to be of the form:</span>
<span class="c1">///     [path/]fileprefix</span>
<span class="c1">/// The skeleton will then be generated in the file:</span>
<span class="c1">///     fileprefix.h</span>
<span class="c1">/// located in the current directory or in &#39;path/&#39; if it is specified.</span>
<span class="c1">/// The class generated will be named &#39;fileprefix&#39;</span>
<span class="c1">///</span>
<span class="c1">/// &quot;macrofilename&quot; and optionally &quot;cutfilename&quot; are expected to point</span>
<span class="c1">/// to source files which will be included by the generated skeleton.</span>
<span class="c1">/// Method of the same name as the file(minus the extension and path)</span>
<span class="c1">/// will be called by the generated skeleton&#39;s Process method as follow:</span>
<span class="c1">///     [if (cutfilename())] htemp-&gt;Fill(macrofilename());</span>
<span class="c1">/// &quot;option&quot; can be used select some of the optional features during</span>
<span class="c1">/// the code generation.  The possible options are:</span>
<span class="c1">/// - nohist : indicates that the generated ProcessFill should not fill the histogram.</span>
<span class="c1">/// &#39;maxUnrolling&#39; controls how deep in the class hierarchy does the</span>
<span class="c1">/// system &#39;unroll&#39; classes that are not split.  Unrolling a class</span>
<span class="c1">/// allows direct access to its data members (this emulates the behavior</span>
<span class="c1">/// of TTreeFormula).</span>
<span class="c1">///</span>
<span class="c1">/// The main features of this skeleton are:</span>
<span class="c1">/// * on-demand loading of branches</span>
<span class="c1">/// * ability to use the &#39;branchname&#39; as if it was a data member</span>
<span class="c1">/// * protection against array out-of-bounds errors</span>
<span class="c1">/// * ability to use the branch data as an object (when the user code is available)</span>
<span class="c1">/// If a file name macrofilename.h (or .hh, .hpp, .hxx, .hPP, .hXX) exist</span>
<span class="c1">/// it is included before the declaration of the proxy class.  This can</span>
<span class="c1">/// be used in particular to insure that the include files needed by</span>
<span class="c1">/// the macro file are properly loaded.</span>
<span class="c1">/// The default histogram is accessible via the variable named &#39;htemp&#39;.</span>
<span class="c1">/// If the library of the classes describing the data in the branch is</span>
<span class="c1">/// loaded, the skeleton will add the needed #include statements and</span>
<span class="c1">/// give the ability to access the object stored in the branches.</span>

   <span class="k">virtual</span> <span class="n">Int_t</span>           <span class="nf">MakeSelector</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">selector</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">Option_t</span><span class="o">*</span> <span class="n">option</span> <span class="o">=</span> <span class="s">&quot;&quot;</span><span class="p">);</span><span class="c1">//生成要Process()的文件</span>
<span class="c1">/// Generate skeleton selector class for this tree.</span>
<span class="c1">/// The following files are produced: selector.h and selector.C.</span>
<span class="c1">/// If selector is 0, the selector will be called &quot;nameoftree&quot;.</span>
<span class="c1">/// The option can be used to specify the branches that will have a data member.</span>
<span class="c1">///    - If option is &quot;=legacy&quot;, a pre-ROOT6 selector will be generated (data</span>
<span class="c1">///      members and branch pointers instead of TTreeReaders).</span>
<span class="c1">///    - If option is empty, readers will be generated for each leaf.</span>
<span class="c1">///    - If option is &quot;@&quot;, readers will be generated for the topmost branches.</span>
<span class="c1">///    - Individual branches can also be picked by their name:</span>
<span class="c1">///       - &quot;X&quot; generates readers for leaves of X.</span>
<span class="c1">///       - &quot;@X&quot; generates a reader for X as a whole.</span>
<span class="c1">///       - &quot;@X;Y&quot; generates a reader for X as a whole and also readers for the</span>
<span class="c1">///         leaves of Y.</span>
<span class="c1">///    - For further examples see the figure below.</span>
<span class="c1">/// The generated code in selector.h includes the following:</span>
<span class="c1">///    - Identification of the original Tree and Input file name</span>
<span class="c1">///    - Definition of selector class (data and functions)</span>
<span class="c1">///    - The following class functions:</span>
<span class="c1">///       - constructor and destructor</span>
<span class="c1">///       - void    Begin(TTree *tree)</span>
<span class="c1">///       - void    SlaveBegin(TTree *tree)</span>
<span class="c1">///       - void    Init(TTree *tree)</span>
<span class="c1">///       - Bool_t  Notify()</span>
<span class="c1">///       - Bool_t  Process(Long64_t entry)</span>
<span class="c1">///       - void    Terminate()</span>
<span class="c1">///       - void    SlaveTerminate()</span>
<span class="c1">/// The class selector derives from TSelector.</span>
<span class="c1">/// The generated code in selector.C includes empty functions defined above.</span>
<span class="c1">/// To use this function:</span>
<span class="c1">///    - connect your Tree file (eg: `TFile f(&quot;myfile.root&quot;);`)</span>
<span class="c1">///    - `T-&gt;MakeSelector(&quot;myselect&quot;);`</span>
<span class="c1">/// where T is the name of the Tree in file myfile.root</span>
<span class="c1">/// and myselect.h, myselect.C the name of the files created by this function.</span>
<span class="c1">/// In a ROOT session, you can do:</span>
<span class="c1">///     root &gt; T-&gt;Process(&quot;myselect.C&quot;)</span>

   <span class="n">Bool_t</span>                  <span class="nf">MemoryFull</span><span class="p">(</span><span class="n">Int_t</span> <span class="n">nbytes</span><span class="p">);</span><span class="c1">/// Check if adding nbytes to memory we are still below MaxVirtualsize.</span>
   <span class="k">virtual</span> <span class="n">Long64_t</span>        <span class="nf">Merge</span><span class="p">(</span><span class="n">TCollection</span><span class="o">*</span> <span class="n">list</span><span class="p">,</span> <span class="n">Option_t</span><span class="o">*</span> <span class="n">option</span> <span class="o">=</span> <span class="s">&quot;&quot;</span><span class="p">);</span>
<span class="c1">/// Merge the trees in the TList into this tree.</span>
<span class="c1">/// Returns the total number of entries in the merged tree.</span>

   <span class="k">virtual</span> <span class="n">Long64_t</span>        <span class="nf">Merge</span><span class="p">(</span><span class="n">TCollection</span><span class="o">*</span> <span class="n">list</span><span class="p">,</span> <span class="n">TFileMergeInfo</span> <span class="o">*</span><span class="n">info</span><span class="p">);</span>
<span class="c1">/// Merge the trees in the TList into this tree.</span>
<span class="c1">/// If info-&gt;fIsFirst is true, first we clone this TTree info the directory</span>
<span class="c1">/// info-&gt;fOutputDirectory and then overlay the new TTree information onto</span>
<span class="c1">/// this TTree object (so that this TTree object is now the appropriate to</span>
<span class="c1">/// use for further merging).</span>
<span class="c1">/// Returns the total number of entries in the merged tree.</span>

   <span class="k">static</span>  <span class="n">TTree</span>          <span class="o">*</span><span class="nf">MergeTrees</span><span class="p">(</span><span class="n">TList</span><span class="o">*</span> <span class="n">list</span><span class="p">,</span> <span class="n">Option_t</span><span class="o">*</span> <span class="n">option</span> <span class="o">=</span> <span class="s">&quot;&quot;</span><span class="p">);</span>
<span class="c1">/// Static function merging the trees in the TList into a new tree.</span>
<span class="c1">/// Trees in the list can be memory or disk-resident trees.</span>
<span class="c1">/// The new tree is created in the current directory (memory if gROOT).</span>

   <span class="k">virtual</span> <span class="n">Bool_t</span>          <span class="nf">Notify</span><span class="p">();</span><span class="c1">/// Function called when loading a new class library.</span>
   <span class="k">virtual</span> <span class="kt">void</span>            <span class="nf">OptimizeBaskets</span><span class="p">(</span><span class="n">ULong64_t</span> <span class="n">maxMemory</span><span class="o">=</span><span class="mi">10000000</span><span class="p">,</span> <span class="n">Float_t</span> <span class="n">minComp</span><span class="o">=</span><span class="mf">1.1</span><span class="p">,</span> <span class="n">Option_t</span> <span class="o">*</span><span class="n">option</span><span class="o">=</span><span class="s">&quot;&quot;</span><span class="p">);</span>
<span class="c1">/// This function may be called after having filled some entries in a Tree</span>
<span class="c1">/// Using the information in the existing branch buffers, it will reassign</span>
<span class="c1">/// new branch buffer sizes to optimize time and memory.</span>
<span class="c1">/// The function computes the best values for branch buffer sizes such that</span>
<span class="c1">/// the total buffer sizes is less than maxMemory and nearby entries written</span>
<span class="c1">/// at the same time.</span>
<span class="c1">/// In case the branch compression factor for the data written so far is less</span>
<span class="c1">/// than compMin, the compression is disabled.</span>
<span class="c1">/// if option =&quot;d&quot; an analysis report is printed.</span>

   <span class="n">TPrincipal</span>             <span class="o">*</span><span class="nf">Principal</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">varexp</span> <span class="o">=</span> <span class="s">&quot;&quot;</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">selection</span> <span class="o">=</span> <span class="s">&quot;&quot;</span><span class="p">,</span> <span class="n">Option_t</span><span class="o">*</span> <span class="n">option</span> <span class="o">=</span> <span class="s">&quot;np&quot;</span><span class="p">,</span> <span class="n">Long64_t</span> <span class="n">nentries</span> <span class="o">=</span> <span class="n">kMaxEntries</span><span class="p">,</span> <span class="n">Long64_t</span> <span class="n">firstentry</span> <span class="o">=</span> <span class="mi">0</span><span class="p">);</span>
<span class="c1">/// Interface to the Principal Components Analysis class.</span>
<span class="c1">/// Create an instance of TPrincipal</span>
<span class="c1">/// Fill it with the selected variables</span>
<span class="c1">/// - if option &quot;n&quot; is specified, the TPrincipal object is filled with</span>
<span class="c1">///                 normalized variables.</span>
<span class="c1">/// - If option &quot;p&quot; is specified, compute the principal components</span>
<span class="c1">/// - If option &quot;p&quot; and &quot;d&quot; print results of analysis</span>
<span class="c1">/// - If option &quot;p&quot; and &quot;h&quot; generate standard histograms</span>
<span class="c1">/// - If option &quot;p&quot; and &quot;c&quot; generate code of conversion functions</span>
<span class="c1">/// - return a pointer to the TPrincipal object. It is the user responsibility</span>
<span class="c1">/// - to delete this object.</span>
<span class="c1">/// - The option default value is &quot;np&quot;</span>
<span class="c1">/// see TTree::Draw for explanation of the other parameters.</span>
<span class="c1">/// The created object is  named &quot;principal&quot; and a reference to it</span>
<span class="c1">/// is added to the list of specials Root objects.</span>

   <span class="k">virtual</span> <span class="kt">void</span>            <span class="nf">Print</span><span class="p">(</span><span class="n">Option_t</span><span class="o">*</span> <span class="n">option</span> <span class="o">=</span> <span class="s">&quot;&quot;</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span> <span class="c1">// *MENU*</span>
<span class="c1">/// Print a summary of the tree contents.</span>
<span class="c1">/// -  If option contains &quot;all&quot; friend trees are also printed.</span>
<span class="c1">/// -  If option contains &quot;toponly&quot; only the top level branches are printed.</span>
<span class="c1">/// -  If option contains &quot;clusters&quot; information about the cluster of baskets is printed.</span>
<span class="c1">/// Wildcarding can be used to print only a subset of the branches, e.g.,</span>
<span class="c1">/// T.Print(&quot;Elec*&quot;) will print all branches with name starting with &quot;Elec&quot;.</span>

   <span class="k">virtual</span> <span class="kt">void</span>            <span class="nf">PrintCacheStats</span><span class="p">(</span><span class="n">Option_t</span><span class="o">*</span> <span class="n">option</span> <span class="o">=</span> <span class="s">&quot;&quot;</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
<span class="c1">/// print statistics about the TreeCache for this tree, like</span>
<span class="c1">/// if option = &quot;a&quot; the list of blocks in the cache is printed</span>

   <span class="k">virtual</span> <span class="n">Long64_t</span>        <span class="nf">Process</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">filename</span><span class="p">,</span> <span class="n">Option_t</span><span class="o">*</span> <span class="n">option</span> <span class="o">=</span> <span class="s">&quot;&quot;</span><span class="p">,</span> <span class="n">Long64_t</span> <span class="n">nentries</span> <span class="o">=</span> <span class="n">kMaxEntries</span><span class="p">,</span> <span class="n">Long64_t</span> <span class="n">firstentry</span> <span class="o">=</span> <span class="mi">0</span><span class="p">);</span> <span class="c1">// *MENU*</span>
<span class="c1">/// Process this tree executing the TSelector code in the specified filename.</span>
<span class="c1">/// The return value is -1 in case of error and TSelector::GetStatus() in</span>
<span class="c1">/// in case of success.</span>
<span class="c1">/// The code in filename is loaded (interpreted or compiled, see below),</span>
<span class="c1">/// filename must contain a valid class implementation derived from TSelector,</span>
<span class="c1">/// where TSelector has the following member functions:</span>
<span class="c1">/// - `Begin()`:         called every time a loop on the tree starts,</span>
<span class="c1">///                      a convenient place to create your histograms.</span>
<span class="c1">/// - `SlaveBegin()`:    called after Begin(), when on PROOF called only on the</span>
<span class="c1">///                      slave servers.</span>
<span class="c1">/// - `Process()`:       called for each event, in this function you decide what</span>
<span class="c1">///                      to read and fill your histograms.</span>
<span class="c1">/// - `SlaveTerminate`:  called at the end of the loop on the tree, when on PROOF</span>
<span class="c1">///                      called only on the slave servers.</span>
<span class="c1">/// - `Terminate()`:     called at the end of the loop on the tree,</span>
<span class="c1">///                      a convenient place to draw/fit your histograms.</span>
<span class="c1">/// If filename is of the form file.C, the file will be interpreted.</span>
<span class="c1">/// If filename is of the form file.C++, the file file.C will be compiled</span>
<span class="c1">/// and dynamically loaded.</span>
<span class="c1">/// If filename is of the form file.C+, the file file.C will be compiled</span>
<span class="c1">/// and dynamically loaded. At next call, if file.C is older than file.o</span>
<span class="c1">/// and file.so, the file.C is not compiled, only file.so is loaded.</span>

<span class="cp">#if defined(__CINT__)</span>
<span class="cp">#if defined(R__MANUAL_DICT)</span>
   <span class="k">virtual</span> <span class="n">Long64_t</span>        <span class="nf">Process</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span> <span class="n">selector</span><span class="p">,</span> <span class="n">Option_t</span><span class="o">*</span> <span class="n">option</span> <span class="o">=</span> <span class="s">&quot;&quot;</span><span class="p">,</span> <span class="n">Long64_t</span> <span class="n">nentries</span> <span class="o">=</span> <span class="n">kMaxEntries</span><span class="p">,</span> <span class="n">Long64_t</span> <span class="n">firstentry</span> <span class="o">=</span> <span class="mi">0</span><span class="p">);</span>
<span class="cp">#endif</span>
<span class="cp">#else</span>
   <span class="k">virtual</span> <span class="n">Long64_t</span>        <span class="nf">Process</span><span class="p">(</span><span class="n">TSelector</span><span class="o">*</span> <span class="n">selector</span><span class="p">,</span> <span class="n">Option_t</span><span class="o">*</span> <span class="n">option</span> <span class="o">=</span> <span class="s">&quot;&quot;</span><span class="p">,</span> <span class="n">Long64_t</span> <span class="n">nentries</span> <span class="o">=</span> <span class="n">kMaxEntries</span><span class="p">,</span> <span class="n">Long64_t</span> <span class="n">firstentry</span> <span class="o">=</span> <span class="mi">0</span><span class="p">);</span>
<span class="c1">/// Process this tree executing the code in the specified selector.</span>
<span class="c1">/// The return value is -1 in case of error and TSelector::GetStatus() in</span>
<span class="c1">/// in case of success.</span>
<span class="c1">///   The TSelector class has the following member functions:</span>
<span class="c1">/// - `Begin()`:        called every time a loop on the tree starts,</span>
<span class="c1">///                     a convenient place to create your histograms.</span>
<span class="c1">/// - `SlaveBegin()`:   called after Begin(), when on PROOF called only on the</span>
<span class="c1">///                     slave servers.</span>
<span class="c1">/// - `Process()`:      called for each event, in this function you decide what</span>
<span class="c1">///                     to read and fill your histograms.</span>
<span class="c1">/// - `SlaveTerminate`: called at the end of the loop on the tree, when on PROOF</span>
<span class="c1">///                     called only on the slave servers.</span>
<span class="c1">/// - `Terminate()`:    called at the end of the loop on the tree,</span>
<span class="c1">///                     a convenient place to draw/fit your histograms.</span>
<span class="c1">///  If the Tree (Chain) has an associated EventList, the loop is on the nentries</span>
<span class="c1">///  of the EventList, starting at firstentry, otherwise the loop is on the</span>
<span class="c1">///  specified Tree entries.</span>
<span class="cp">#endif</span>
   <span class="k">virtual</span> <span class="n">Long64_t</span>        <span class="nf">Project</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">hname</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">varexp</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">selection</span> <span class="o">=</span> <span class="s">&quot;&quot;</span><span class="p">,</span> <span class="n">Option_t</span><span class="o">*</span> <span class="n">option</span> <span class="o">=</span> <span class="s">&quot;&quot;</span><span class="p">,</span> <span class="n">Long64_t</span> <span class="n">nentries</span> <span class="o">=</span> <span class="n">kMaxEntries</span><span class="p">,</span> <span class="n">Long64_t</span> <span class="n">firstentry</span> <span class="o">=</span> <span class="mi">0</span><span class="p">);</span>
<span class="c1">/// Make a projection of a tree using selections.</span>
<span class="c1">/// Depending on the value of varexp (described in Draw) a 1-D, 2-D, etc.,</span>
<span class="c1">/// projection of the tree will be filled in histogram hname.</span>
<span class="c1">/// Note that the dimension of hname must match with the dimension of varexp.</span>

   <span class="k">virtual</span> <span class="n">TSQLResult</span>     <span class="o">*</span><span class="nf">Query</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">varexp</span> <span class="o">=</span> <span class="s">&quot;&quot;</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">selection</span> <span class="o">=</span> <span class="s">&quot;&quot;</span><span class="p">,</span> <span class="n">Option_t</span><span class="o">*</span> <span class="n">option</span> <span class="o">=</span> <span class="s">&quot;&quot;</span><span class="p">,</span> <span class="n">Long64_t</span> <span class="n">nentries</span> <span class="o">=</span> <span class="n">kMaxEntries</span><span class="p">,</span> <span class="n">Long64_t</span> <span class="n">firstentry</span> <span class="o">=</span> <span class="mi">0</span><span class="p">);</span><span class="c1">/// Loop over entries and return a TSQLResult object containing entries following selection.</span>
   <span class="k">virtual</span> <span class="n">Long64_t</span>        <span class="nf">ReadFile</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">filename</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">branchDescriptor</span> <span class="o">=</span> <span class="s">&quot;&quot;</span><span class="p">,</span> <span class="kt">char</span> <span class="n">delimiter</span> <span class="o">=</span> <span class="sc">&#39; &#39;</span><span class="p">);</span>
<span class="c1">/// Create or simply read branches from filename.</span>
<span class="c1">/// if branchDescriptor = &quot;&quot; (default), it is assumed that the Tree descriptor</span>
<span class="c1">/// is given in the first line of the file with a syntax like</span>
<span class="c1">///     A/D:Table[2]/F:Ntracks/I:astring/C</span>
<span class="c1">/// otherwise branchDescriptor must be specified with the above syntax.</span>
<span class="c1">/// - If the type of the first variable is not specified, it is assumed to be &quot;/F&quot;</span>
<span class="c1">/// - If the type of any other variable is not specified, the type of the previous</span>
<span class="c1">///   variable is assumed. eg</span>
<span class="c1">///     - `x:y:z`      (all variables are assumed of type &quot;F&quot;</span>
<span class="c1">///     - `x/D:y:z`    (all variables are of type &quot;D&quot;</span>
<span class="c1">///     - `x:y/D:z`    (x is type &quot;F&quot;, y and z of type &quot;D&quot;</span>
<span class="c1">/// delimiter allows for the use of another delimiter besides whitespace.</span>
<span class="c1">/// This provides support for direct import of common data file formats</span>
<span class="c1">/// like csv.  If delimiter != &#39; &#39; and branchDescriptor == &quot;&quot;, then the</span>
<span class="c1">/// branch description is taken from the first line in the file, but</span>
<span class="c1">/// delimiter is used for the branch names tokenization rather than &#39;:&#39;.</span>
<span class="c1">/// Note however that if the values in the first line do not use the</span>
<span class="c1">/// /[type] syntax, all variables are assumed to be of type &quot;F&quot;.</span>
<span class="c1">/// If the filename ends with extensions .csv or .CSV and a delimiter is</span>
<span class="c1">/// not specified (besides &#39; &#39;), the delimiter is automatically set to &#39;,&#39;.</span>
<span class="c1">/// Lines in the input file starting with &quot;#&quot; are ignored. Leading whitespace</span>
<span class="c1">/// for each column data is skipped. Empty lines are skipped.</span>
<span class="c1">/// A TBranch object is created for each variable in the expression.</span>
<span class="c1">/// The total number of rows read from the file is returned.</span>

   <span class="k">virtual</span> <span class="n">Long64_t</span>        <span class="nf">ReadStream</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">istream</span><span class="o">&amp;</span> <span class="n">inputStream</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">branchDescriptor</span> <span class="o">=</span> <span class="s">&quot;&quot;</span><span class="p">,</span> <span class="kt">char</span> <span class="n">delimiter</span> <span class="o">=</span> <span class="sc">&#39; &#39;</span><span class="p">);</span>
<span class="c1">/// Create or simply read branches from an input stream.</span>
<span class="c1">/// See reference information for TTree::ReadFile</span>

   <span class="k">virtual</span> <span class="kt">void</span>            <span class="nf">Refresh</span><span class="p">();</span>
<span class="c1">///  Refresh contents of this tree and its branches from the current status on disk.</span>
<span class="c1">///  One can call this function in case the tree file is being</span>
<span class="c1">///  updated by another process.</span>

   <span class="k">virtual</span> <span class="kt">void</span>            <span class="nf">RecursiveRemove</span><span class="p">(</span><span class="n">TObject</span> <span class="o">*</span><span class="n">obj</span><span class="p">);</span>
<span class="c1">/// Make sure that obj (which is being deleted or will soon be) is no</span>
<span class="c1">/// longer referenced by this TTree.</span>

   <span class="k">virtual</span> <span class="kt">void</span>            <span class="nf">RemoveFriend</span><span class="p">(</span><span class="n">TTree</span><span class="o">*</span><span class="p">);</span><span class="c1">/// Remove a friend from the list of friends.</span>
   <span class="k">virtual</span> <span class="kt">void</span>            <span class="nf">Reset</span><span class="p">(</span><span class="n">Option_t</span><span class="o">*</span> <span class="n">option</span> <span class="o">=</span> <span class="s">&quot;&quot;</span><span class="p">);</span><span class="c1">// Reset baskets, buffers and entries count in all branches and leaves.</span>
   <span class="k">virtual</span> <span class="kt">void</span>            <span class="nf">ResetAfterMerge</span><span class="p">(</span><span class="n">TFileMergeInfo</span> <span class="o">*</span><span class="p">);</span><span class="c1">/// Resets the state of this TTree after a merge (keep the customization but forget the data).</span>
   <span class="k">virtual</span> <span class="kt">void</span>            <span class="nf">ResetBranchAddress</span><span class="p">(</span><span class="n">TBranch</span> <span class="o">*</span><span class="p">);</span>
<span class="c1">/// Tell all of our branches to set their addresses to zero.</span>
<span class="c1">/// Note: If any of our branches own any objects, they are deleted.</span>

   <span class="k">virtual</span> <span class="kt">void</span>            <span class="nf">ResetBranchAddresses</span><span class="p">();</span><span class="c1">/// Tell all of our branches to drop their current objects and allocate new ones.</span>
   <span class="k">virtual</span> <span class="n">Long64_t</span>        <span class="nf">Scan</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">varexp</span> <span class="o">=</span> <span class="s">&quot;&quot;</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">selection</span> <span class="o">=</span> <span class="s">&quot;&quot;</span><span class="p">,</span> <span class="n">Option_t</span><span class="o">*</span> <span class="n">option</span> <span class="o">=</span> <span class="s">&quot;&quot;</span><span class="p">,</span> <span class="n">Long64_t</span> <span class="n">nentries</span> <span class="o">=</span> <span class="n">kMaxEntries</span><span class="p">,</span> <span class="n">Long64_t</span> <span class="n">firstentry</span> <span class="o">=</span> <span class="mi">0</span><span class="p">);</span> <span class="c1">// *MENU*</span>
<span class="c1">// Loop over tree entries and print entries passing selection.</span>
<span class="c1">// If varexp is 0 (or &quot;&quot;) then print only first 8 columns.</span>
<span class="c1">// If varexp = &quot;*&quot; print all columns.</span>
<span class="c1">// Otherwise a columns selection can be made using &quot;var1:var2:var3&quot;.</span>
<span class="c1">// See TTreePlayer::Scan for more information</span>

   <span class="k">virtual</span> <span class="n">Bool_t</span>          <span class="nf">SetAlias</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">aliasName</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">aliasFormula</span><span class="p">);</span>
<span class="c1">/// Set a tree variable alias.</span>
<span class="c1">/// Set an alias for an expression/formula based on the tree &#39;variables&#39;.</span>
<span class="c1">/// The content of &#39;aliasName&#39; can be used in TTreeFormula (i.e. TTree::Draw,</span>
<span class="c1">/// TTree::Scan, TTreeViewer) and will be evaluated as the content of</span>
<span class="c1">/// &#39;aliasFormula&#39;.</span>
<span class="c1">/// If the content of &#39;aliasFormula&#39; only contains symbol names, periods and</span>
<span class="c1">/// array index specification (for example event.fTracks[3]), then</span>
<span class="c1">/// the content of &#39;aliasName&#39; can be used as the start of symbol.</span>
<span class="c1">/// If the alias &#39;aliasName&#39; already existed, it is replaced by the new value.</span>
<span class="c1">/// When being used, the alias can be preceded by an eventual &#39;Friend Alias&#39;</span>
<span class="c1">/// (see TTree::GetFriendAlias)</span>
<span class="c1">/// Return true if it was added properly.</span>

   <span class="k">virtual</span> <span class="kt">void</span>            <span class="nf">SetAutoSave</span><span class="p">(</span><span class="n">Long64_t</span> <span class="n">autos</span> <span class="o">=</span> <span class="o">-</span><span class="mi">300000000</span><span class="p">);</span>
<span class="c1">/// This function may be called at the start of a program to change</span>
<span class="c1">/// the default value for fAutoSave (and for SetAutoSave) is -300000000, ie 300 MBytes</span>
<span class="c1">/// When filling the Tree the branch buffers as well as the Tree header</span>
<span class="c1">/// will be flushed to disk when the watermark is reached.</span>
<span class="c1">/// If fAutoSave is positive the watermark is reached when a multiple of fAutoSave</span>
<span class="c1">/// entries have been written.</span>
<span class="c1">/// If fAutoSave is negative the watermark is reached when -fAutoSave bytes</span>
<span class="c1">/// have been written to the file.</span>
<span class="c1">/// In case of a program crash, it will be possible to recover the data in the Tree</span>
<span class="c1">/// up to the last AutoSave point.</span>

   <span class="k">virtual</span> <span class="kt">void</span>            <span class="nf">SetAutoFlush</span><span class="p">(</span><span class="n">Long64_t</span> <span class="n">autof</span> <span class="o">=</span> <span class="o">-</span><span class="mi">30000000</span><span class="p">);</span>
<span class="c1">/// This function may be called at the start of a program to change</span>
<span class="c1">/// the default value for fAutoFlush.</span>
<span class="c1">/// ### CASE 1 : autof &gt; 0</span>
<span class="c1">/// autof is the number of consecutive entries after which TTree::Fill will</span>
<span class="c1">/// flush all branch buffers to disk.</span>
<span class="c1">/// ### CASE 2 : autof &lt; 0</span>
<span class="c1">/// When filling the Tree the branch buffers will be flushed to disk when</span>
<span class="c1">/// more than autof bytes have been written to the file. At the first FlushBaskets</span>
<span class="c1">/// TTree::Fill will replace fAutoFlush by the current value of fEntries.</span>
<span class="c1">/// Calling this function with autof&lt;0 is interesting when it is hard to estimate</span>
<span class="c1">/// the size of one entry. This value is also independent of the Tree.</span>
<span class="c1">/// The Tree is initialized with fAutoFlush=-30000000, ie that, by default,</span>
<span class="c1">/// the first AutoFlush will be done when 30 MBytes of data are written to the file.</span>
<span class="c1">/// ### CASE 3 : autof = 0</span>
<span class="c1">/// The AutoFlush mechanism is disabled.</span>
<span class="c1">/// Flushing the buffers at regular intervals optimize the location of</span>
<span class="c1">/// consecutive entries on the disk by creating clusters of baskets.</span>
<span class="c1">/// A cluster of baskets is a set of baskets that contains all</span>
<span class="c1">/// the data for a (consecutive) set of entries and that is stored</span>
<span class="c1">/// consecutively on the disk.   When reading all the branches, this</span>
<span class="c1">/// is the minimum set of baskets that the TTreeCache will read.</span>

   <span class="k">virtual</span> <span class="kt">void</span>            <span class="nf">SetBasketSize</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">bname</span><span class="p">,</span> <span class="n">Int_t</span> <span class="n">buffsize</span> <span class="o">=</span> <span class="mi">16000</span><span class="p">);</span>
<span class="c1">/// Set a branch&#39;s basket size.</span>
<span class="c1">/// bname is the name of a branch.</span>
<span class="c1">/// - if bname=&quot;*&quot;, apply to all branches.</span>
<span class="c1">/// - if bname=&quot;xxx*&quot;, apply to all branches with name starting with xxx</span>
<span class="c1">/// see TRegexp for wildcarding options</span>
<span class="c1">/// buffsize = branc basket size</span>

<span class="cp">#if !defined(__CINT__)</span>
   <span class="k">virtual</span> <span class="n">Int_t</span>           <span class="nf">SetBranchAddress</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">bname</span><span class="p">,</span><span class="kt">void</span> <span class="o">*</span><span class="n">add</span><span class="p">,</span> <span class="n">TBranch</span> <span class="o">**</span><span class="n">ptr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">);</span>
<span class="c1">/// Change branch address, dealing with clone trees properly.</span>
<span class="c1">/// See TTree::CheckBranchAddressType for the semantic of the return value.</span>
<span class="c1">/// Note: See the comments in TBranchElement::SetAddress() for the</span>
<span class="c1">/// meaning of the addr parameter and the object ownership policy.</span>
<span class="cp">#endif</span>
   <span class="k">virtual</span> <span class="n">Int_t</span>           <span class="nf">SetBranchAddress</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">bname</span><span class="p">,</span><span class="kt">void</span> <span class="o">*</span><span class="n">add</span><span class="p">,</span> <span class="n">TClass</span> <span class="o">*</span><span class="n">realClass</span><span class="p">,</span> <span class="n">EDataType</span> <span class="n">datatype</span><span class="p">,</span> <span class="n">Bool_t</span> <span class="n">isptr</span><span class="p">);</span>
<span class="c1">/// Verify the validity of the type of addr before calling SetBranchAddress.</span>
<span class="c1">/// See TTree::CheckBranchAddressType for the semantic of the return value.</span>
<span class="c1">/// Note: See the comments in TBranchElement::SetAddress() for the</span>
<span class="c1">/// meaning of the addr parameter and the object ownership policy.</span>

   <span class="k">virtual</span> <span class="n">Int_t</span>           <span class="nf">SetBranchAddress</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">bname</span><span class="p">,</span><span class="kt">void</span> <span class="o">*</span><span class="n">add</span><span class="p">,</span> <span class="n">TBranch</span> <span class="o">**</span><span class="n">ptr</span><span class="p">,</span> <span class="n">TClass</span> <span class="o">*</span><span class="n">realClass</span><span class="p">,</span> <span class="n">EDataType</span> <span class="n">datatype</span><span class="p">,</span> <span class="n">Bool_t</span> <span class="n">isptr</span><span class="p">);</span>
<span class="c1">/// Verify the validity of the type of addr before calling SetBranchAddress.</span>
<span class="c1">/// See TTree::CheckBranchAddressType for the semantic of the return value.</span>
<span class="c1">/// Note: See the comments in TBranchElement::SetAddress() for the</span>
<span class="c1">/// meaning of the addr parameter and the object ownership policy.</span>

   <span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span> <span class="n">Int_t</span> <span class="n">SetBranchAddress</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">bname</span><span class="p">,</span> <span class="n">T</span> <span class="o">**</span><span class="n">add</span><span class="p">,</span> <span class="n">TBranch</span> <span class="o">**</span><span class="n">ptr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">TClass</span> <span class="o">*</span><span class="n">cl</span> <span class="o">=</span> <span class="n">TClass</span><span class="o">::</span><span class="n">GetClass</span><span class="p">(</span><span class="k">typeid</span><span class="p">(</span><span class="n">T</span><span class="p">));</span>
      <span class="n">EDataType</span> <span class="n">type</span> <span class="o">=</span> <span class="n">kOther_t</span><span class="p">;</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">cl</span><span class="o">==</span><span class="mi">0</span><span class="p">)</span> <span class="n">type</span> <span class="o">=</span> <span class="n">TDataType</span><span class="o">::</span><span class="n">GetType</span><span class="p">(</span><span class="k">typeid</span><span class="p">(</span><span class="n">T</span><span class="p">));</span>
      <span class="k">return</span> <span class="nf">SetBranchAddress</span><span class="p">(</span><span class="n">bname</span><span class="p">,</span><span class="n">add</span><span class="p">,</span><span class="n">ptr</span><span class="p">,</span><span class="n">cl</span><span class="p">,</span><span class="n">type</span><span class="p">,</span><span class="nb">true</span><span class="p">);</span>
   <span class="p">}</span>
<span class="cp">#ifndef R__NO_CLASS_TEMPLATE_SPECIALIZATION</span>
   <span class="c1">// This can only be used when the template overload resolution can distringuish between</span>
   <span class="c1">// T* and T**</span>
   <span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span> <span class="n">Int_t</span> <span class="n">SetBranchAddress</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">bname</span><span class="p">,</span> <span class="n">T</span> <span class="o">*</span><span class="n">add</span><span class="p">,</span> <span class="n">TBranch</span> <span class="o">**</span><span class="n">ptr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">TClass</span> <span class="o">*</span><span class="n">cl</span> <span class="o">=</span> <span class="n">TClass</span><span class="o">::</span><span class="n">GetClass</span><span class="p">(</span><span class="k">typeid</span><span class="p">(</span><span class="n">T</span><span class="p">));</span>
      <span class="n">EDataType</span> <span class="n">type</span> <span class="o">=</span> <span class="n">kOther_t</span><span class="p">;</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">cl</span><span class="o">==</span><span class="mi">0</span><span class="p">)</span> <span class="n">type</span> <span class="o">=</span> <span class="n">TDataType</span><span class="o">::</span><span class="n">GetType</span><span class="p">(</span><span class="k">typeid</span><span class="p">(</span><span class="n">T</span><span class="p">));</span>
      <span class="k">return</span> <span class="nf">SetBranchAddress</span><span class="p">(</span><span class="n">bname</span><span class="p">,</span><span class="n">add</span><span class="p">,</span><span class="n">ptr</span><span class="p">,</span><span class="n">cl</span><span class="p">,</span><span class="n">type</span><span class="p">,</span><span class="nb">false</span><span class="p">);</span>
   <span class="p">}</span>
<span class="cp">#endif</span>
   <span class="k">virtual</span> <span class="kt">void</span>            <span class="n">SetBranchStatus</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">bname</span><span class="p">,</span> <span class="n">Bool_t</span> <span class="n">status</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">UInt_t</span><span class="o">*</span> <span class="n">found</span> <span class="o">=</span> <span class="mi">0</span><span class="p">);</span>
<span class="c1">/// Set branch status to Process or DoNotProcess.</span>
<span class="c1">/// When reading a Tree, by default, all branches are read.</span>
<span class="c1">/// One can speed up considerably the analysis phase by activating</span>
<span class="c1">/// only the branches that hold variables involved in a query.</span>
<span class="c1">/// bname is the name of a branch.</span>
<span class="c1">/// - if bname=&quot;*&quot;, apply to all branches.</span>
<span class="c1">/// - if bname=&quot;xxx*&quot;, apply to all branches with name starting with xxx</span>
<span class="c1">/// see TRegexp for wildcarding options</span>
<span class="c1">/// - status = 1  branch will be processed</span>
<span class="c1">/// - = 0  branch will not be processed</span>
<span class="c1">/// __WARNING! WARNING! WARNING!__</span>
<span class="c1">/// SetBranchStatus is matching the branch based on match of the branch</span>
<span class="c1">/// &#39;name&#39; and not on the branch hierarchy! In order to be able to</span>
<span class="c1">/// selectively enable a top level object that is &#39;split&#39; you need to make</span>
<span class="c1">/// sure the name of the top level branch is prefixed to the sub-branches&#39;</span>
<span class="c1">/// name (by adding a dot (&#39;.&#39;) at the end of the Branch creation and use the</span>
<span class="c1">/// corresponding bname.</span>
<span class="c1">/// If found is not 0, the number of branch(es) found matching the regular</span>
<span class="c1">/// expression is returned in *found AND the error message &#39;unknown branch&#39;</span>
<span class="c1">/// is suppressed.</span>

   <span class="k">static</span>  <span class="kt">void</span>            <span class="nf">SetBranchStyle</span><span class="p">(</span><span class="n">Int_t</span> <span class="n">style</span> <span class="o">=</span> <span class="mi">1</span><span class="p">);</span>  <span class="c1">//style=0 for old branch, =1 for new branch style</span>
   <span class="k">virtual</span> <span class="n">Int_t</span>           <span class="nf">SetCacheSize</span><span class="p">(</span><span class="n">Long64_t</span> <span class="n">cachesize</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>
<span class="c1">/// Set maximum size of the file cache .</span>
<span class="c1">/// - if cachesize = 0 the existing cache (if any) is deleted.</span>
<span class="c1">/// - if cachesize = -1 (default) it is set to the AutoFlush value when writing</span>
<span class="c1">///    the Tree (default is 30 MBytes).</span>
<span class="c1">/// Returns:</span>
<span class="c1">/// - 0 size set, cache was created if possible</span>
<span class="c1">/// - -1 on error</span>

   <span class="k">virtual</span> <span class="n">Int_t</span>           <span class="nf">SetCacheEntryRange</span><span class="p">(</span><span class="n">Long64_t</span> <span class="n">first</span><span class="p">,</span> <span class="n">Long64_t</span> <span class="n">last</span><span class="p">);</span>
<span class="c1">///interface to TTreeCache to set the cache entry range</span>
<span class="c1">/// Returns:</span>
<span class="c1">/// - 0 entry range set</span>
<span class="c1">/// - -1 on error</span>

   <span class="k">virtual</span> <span class="kt">void</span>            <span class="nf">SetCacheLearnEntries</span><span class="p">(</span><span class="n">Int_t</span> <span class="n">n</span><span class="o">=</span><span class="mi">10</span><span class="p">);</span><span class="c1">/// Interface to TTreeCache to set the number of entries for the learning phase</span>
   <span class="k">virtual</span> <span class="kt">void</span>            <span class="nf">SetChainOffset</span><span class="p">(</span><span class="n">Long64_t</span> <span class="n">offset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span> <span class="n">fChainOffset</span><span class="o">=</span><span class="n">offset</span><span class="p">;</span> <span class="p">}</span>
   <span class="k">virtual</span> <span class="kt">void</span>            <span class="nf">SetCircular</span><span class="p">(</span><span class="n">Long64_t</span> <span class="n">maxEntries</span><span class="p">);</span>
<span class="c1">/// Enable/Disable circularity for this tree.</span>
<span class="c1">/// if maxEntries &gt; 0 a maximum of maxEntries is kept in one buffer/basket</span>
<span class="c1">/// per branch in memory.</span>
<span class="c1">///   Note that when this function is called (maxEntries&gt;0) the Tree</span>
<span class="c1">///   must be empty or having only one basket per branch.</span>
<span class="c1">/// if maxEntries &lt;= 0 the tree circularity is disabled.</span>
<span class="c1">/// #### NOTE 1:</span>
<span class="c1">///  Circular Trees are interesting in online real time environments</span>
<span class="c1">///  to store the results of the last maxEntries events.</span>
<span class="c1">/// #### NOTE 2:</span>
<span class="c1">///  Calling SetCircular with maxEntries &lt;= 0 is necessary before</span>
<span class="c1">///  merging circular Trees that have been saved on files.</span>
<span class="c1">/// #### NOTE 3:</span>
<span class="c1">///  SetCircular with maxEntries &lt;= 0 is automatically called</span>
<span class="c1">///  by TChain::Merge</span>
<span class="c1">/// #### NOTE 4:</span>
<span class="c1">///  A circular Tree can still be saved in a file. When read back,</span>
<span class="c1">///  it is still a circular Tree and can be filled again.</span>

   <span class="k">virtual</span> <span class="kt">void</span>            <span class="nf">SetDebug</span><span class="p">(</span><span class="n">Int_t</span> <span class="n">level</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">Long64_t</span> <span class="n">min</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">Long64_t</span> <span class="n">max</span> <span class="o">=</span> <span class="mi">9999999</span><span class="p">);</span> <span class="c1">// *MENU*</span>
<span class="c1">/// Set the debug level and the debug range.</span>
<span class="c1">/// For entries in the debug range, the functions TBranchElement::Fill</span>
<span class="c1">/// and TBranchElement::GetEntry will print the number of bytes filled</span>
<span class="c1">/// or read for each branch.</span>

   <span class="k">virtual</span> <span class="kt">void</span>            <span class="nf">SetDefaultEntryOffsetLen</span><span class="p">(</span><span class="n">Int_t</span> <span class="n">newdefault</span><span class="p">,</span> <span class="n">Bool_t</span> <span class="n">updateExisting</span> <span class="o">=</span> <span class="n">kFALSE</span><span class="p">);</span>
<span class="c1">/// Update the default value for the branch&#39;s fEntryOffsetLen.</span>
<span class="c1">/// If updateExisting is true, also update all the existing branches.</span>
<span class="c1">/// If newdefault is less than 10, the new default value will be 10.</span>

   <span class="k">virtual</span> <span class="kt">void</span>            <span class="nf">SetDirectory</span><span class="p">(</span><span class="n">TDirectory</span><span class="o">*</span> <span class="n">dir</span><span class="p">);</span>
<span class="c1">/// Change the tree&#39;s directory.</span>
<span class="c1">/// Remove reference to this tree from current directory and</span>
<span class="c1">/// add reference to new directory dir.  The dir parameter can</span>
<span class="c1">/// be 0 in which case the tree does not belong to any directory.</span>

   <span class="k">virtual</span> <span class="n">Long64_t</span>        <span class="nf">SetEntries</span><span class="p">(</span><span class="n">Long64_t</span> <span class="n">n</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>
<span class="c1">/// Change number of entries in the tree.</span>
<span class="c1">/// If n &gt;= 0, set number of entries in the tree = n.</span>
<span class="c1">/// If n &lt; 0, set number of entries in the tree to match the</span>
<span class="c1">/// number of entries in each branch. (default for n is -1)</span>
<span class="c1">/// This function should be called only when one fills each branch</span>
<span class="c1">/// independently via TBranch::Fill without calling TTree::Fill.</span>
<span class="c1">/// Calling TTree::SetEntries() make sense only if the number of entries</span>
<span class="c1">/// in each branch is identical, a warning is issued otherwise.</span>
<span class="c1">/// The function returns the number of entries.</span>

   <span class="k">virtual</span> <span class="kt">void</span>            <span class="nf">SetEstimate</span><span class="p">(</span><span class="n">Long64_t</span> <span class="n">nentries</span> <span class="o">=</span> <span class="mi">1000000</span><span class="p">);</span>
<span class="c1">/// Set number of entries to estimate variable limits.</span>
<span class="c1">/// If n is -1, the estimate is set to be the current maximum</span>
<span class="c1">/// for the tree (i.e. GetEntries() + 1)</span>
<span class="c1">/// If n is less than -1, the behavior is undefined.</span>

   <span class="k">virtual</span> <span class="kt">void</span>            <span class="nf">SetFileNumber</span><span class="p">(</span><span class="n">Int_t</span> <span class="n">number</span> <span class="o">=</span> <span class="mi">0</span><span class="p">);</span>
<span class="c1">/// Set fFileNumber to number.</span>
<span class="c1">/// fFileNumber is used by TTree::Fill to set the file name</span>
<span class="c1">/// for a new file to be created when the current file exceeds fgTreeMaxSize.</span>
<span class="c1">///    (see TTree::ChangeFile)</span>
<span class="c1">/// if fFileNumber=10, the new file name will have a suffix &quot;_11&quot;,</span>
<span class="c1">/// ie, fFileNumber is incremented before setting the file name</span>

   <span class="k">virtual</span> <span class="kt">void</span>            <span class="nf">SetEventList</span><span class="p">(</span><span class="n">TEventList</span><span class="o">*</span> <span class="n">list</span><span class="p">);</span>
<span class="c1">/// This function transfroms the given TEventList into a TEntryList</span>
<span class="c1">/// The new TEntryList is owned by the TTree and gets deleted when the tree</span>
<span class="c1">/// is deleted. This TEntryList can be returned by GetEntryList() function.</span>

   <span class="k">virtual</span> <span class="kt">void</span>            <span class="nf">SetEntryList</span><span class="p">(</span><span class="n">TEntryList</span><span class="o">*</span> <span class="n">list</span><span class="p">,</span> <span class="n">Option_t</span> <span class="o">*</span><span class="n">opt</span><span class="o">=</span><span class="s">&quot;&quot;</span><span class="p">);</span><span class="c1">/// Set an EntryList</span>
   <span class="k">virtual</span> <span class="kt">void</span>            <span class="nf">SetMakeClass</span><span class="p">(</span><span class="n">Int_t</span> <span class="n">make</span><span class="p">);</span>
<span class="c1">/// Set all the branches in this TTree to be in decomposed object mode</span>
<span class="c1">/// (also known as MakeClass mode).</span>

   <span class="k">virtual</span> <span class="kt">void</span>            <span class="nf">SetMaxEntryLoop</span><span class="p">(</span><span class="n">Long64_t</span> <span class="n">maxev</span> <span class="o">=</span> <span class="n">kMaxEntries</span><span class="p">)</span> <span class="p">{</span> <span class="n">fMaxEntryLoop</span> <span class="o">=</span> <span class="n">maxev</span><span class="p">;</span> <span class="p">}</span> <span class="c1">// *MENU*</span>
   <span class="k">static</span>  <span class="kt">void</span>            <span class="nf">SetMaxTreeSize</span><span class="p">(</span><span class="n">Long64_t</span> <span class="n">maxsize</span> <span class="o">=</span> <span class="mi">1900000000</span><span class="p">);</span>
<span class="c1">/// Set the maximum size in bytes of a Tree file (static function).</span>
<span class="c1">/// The default size is 100000000000LL, ie 100 Gigabytes.</span>
<span class="c1">/// In TTree::Fill, when the file has a size &gt; fgMaxTreeSize,</span>
<span class="c1">/// the function closes the current file and starts writing into</span>
<span class="c1">/// a new file with a name of the style &quot;file_1.root&quot; if the original</span>
<span class="c1">/// requested file name was &quot;file.root&quot;.</span>

   <span class="k">virtual</span> <span class="kt">void</span>            <span class="nf">SetMaxVirtualSize</span><span class="p">(</span><span class="n">Long64_t</span> <span class="n">size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span> <span class="n">fMaxVirtualSize</span> <span class="o">=</span> <span class="n">size</span><span class="p">;</span> <span class="p">}</span> <span class="c1">// *MENU*</span>
   <span class="k">virtual</span> <span class="kt">void</span>            <span class="nf">SetName</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">name</span><span class="p">);</span> <span class="c1">// *MENU* /// Change the name of this tree.</span>
   <span class="k">virtual</span> <span class="kt">void</span>            <span class="nf">SetNotify</span><span class="p">(</span><span class="n">TObject</span><span class="o">*</span> <span class="n">obj</span><span class="p">)</span> <span class="p">{</span> <span class="n">fNotify</span> <span class="o">=</span> <span class="n">obj</span><span class="p">;</span> <span class="p">}</span>
   <span class="k">virtual</span> <span class="kt">void</span>            <span class="nf">SetObject</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">name</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">title</span><span class="p">);</span><span class="c1">/// Change the name and title of this tree.</span>
   <span class="k">virtual</span> <span class="kt">void</span>            <span class="nf">SetParallelUnzip</span><span class="p">(</span><span class="n">Bool_t</span> <span class="n">opt</span><span class="o">=</span><span class="n">kTRUE</span><span class="p">,</span> <span class="n">Float_t</span> <span class="n">RelSize</span><span class="o">=-</span><span class="mi">1</span><span class="p">);</span><span class="c1">/// Enable or disable parallel unzipping of Tree buffers.</span>
   <span class="k">virtual</span> <span class="kt">void</span>            <span class="nf">SetPerfStats</span><span class="p">(</span><span class="n">TVirtualPerfStats</span><span class="o">*</span> <span class="n">perf</span><span class="p">);</span><span class="c1">/// Set perf stats</span>
   <span class="k">virtual</span> <span class="kt">void</span>            <span class="nf">SetScanField</span><span class="p">(</span><span class="n">Int_t</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">50</span><span class="p">)</span> <span class="p">{</span> <span class="n">fScanField</span> <span class="o">=</span> <span class="n">n</span><span class="p">;</span> <span class="p">}</span> <span class="c1">// *MENU*</span>
   <span class="k">virtual</span> <span class="kt">void</span>            <span class="nf">SetTimerInterval</span><span class="p">(</span><span class="n">Int_t</span> <span class="n">msec</span> <span class="o">=</span> <span class="mi">333</span><span class="p">)</span> <span class="p">{</span> <span class="n">fTimerInterval</span><span class="o">=</span><span class="n">msec</span><span class="p">;</span> <span class="p">}</span>
   <span class="k">virtual</span> <span class="kt">void</span>            <span class="nf">SetTreeIndex</span><span class="p">(</span><span class="n">TVirtualIndex</span><span class="o">*</span> <span class="n">index</span><span class="p">);</span>
<span class="c1">/// The current TreeIndex is replaced by the new index.</span>
<span class="c1">/// Note that this function does not delete the previous index.</span>

   <span class="k">virtual</span> <span class="kt">void</span>            <span class="nf">SetWeight</span><span class="p">(</span><span class="n">Double_t</span> <span class="n">w</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">Option_t</span><span class="o">*</span> <span class="n">option</span> <span class="o">=</span> <span class="s">&quot;&quot;</span><span class="p">);</span>
<span class="c1">/// Set tree weight.</span>
<span class="c1">/// The weight is used by TTree::Draw to automatically weight each</span>
<span class="c1">/// selected entry in the resulting histogram.</span>
<span class="c1">/// This function is redefined by TChain::SetWeight. In case of a</span>
<span class="c1">/// TChain, an option &quot;global&quot; may be specified to set the same weight</span>
<span class="c1">/// for all trees in the TChain instead of the default behaviour</span>
<span class="c1">/// using the weights of each tree in the chain (see TChain::SetWeight).</span>

   <span class="k">virtual</span> <span class="kt">void</span>            <span class="nf">SetUpdate</span><span class="p">(</span><span class="n">Int_t</span> <span class="n">freq</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span> <span class="n">fUpdate</span> <span class="o">=</span> <span class="n">freq</span><span class="p">;</span> <span class="p">}</span>
   <span class="k">virtual</span> <span class="kt">void</span>            <span class="nf">Show</span><span class="p">(</span><span class="n">Long64_t</span> <span class="n">entry</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">Int_t</span> <span class="n">lenmax</span> <span class="o">=</span> <span class="mi">20</span><span class="p">);</span>
<span class="c1">/// Print values of all active leaves for entry.</span>
<span class="c1">/// - if entry==-1, print current entry (default)</span>
<span class="c1">/// - if a leaf is an array, a maximum of lenmax elements is printed.</span>

   <span class="k">virtual</span> <span class="kt">void</span>            <span class="nf">StartViewer</span><span class="p">();</span> <span class="c1">// *MENU*</span>
<span class="c1">/// Start the TTreeViewer on this tree.</span>
<span class="c1">/// - ww is the width of the canvas in pixels</span>
<span class="c1">/// - wh is the height of the canvas in pixels</span>

   <span class="k">virtual</span> <span class="n">Int_t</span>           <span class="nf">StopCacheLearningPhase</span><span class="p">();</span>
<span class="c1">/// Stop the cache learning phase</span>
<span class="c1">/// Returns:</span>
<span class="c1">/// - 0 learning phase stopped or not active</span>
<span class="c1">/// - -1 on error</span>

   <span class="k">virtual</span> <span class="n">Int_t</span>           <span class="nf">UnbinnedFit</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">funcname</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">varexp</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">selection</span> <span class="o">=</span> <span class="s">&quot;&quot;</span><span class="p">,</span> <span class="n">Option_t</span><span class="o">*</span> <span class="n">option</span> <span class="o">=</span> <span class="s">&quot;&quot;</span><span class="p">,</span> <span class="n">Long64_t</span> <span class="n">nentries</span> <span class="o">=</span> <span class="n">kMaxEntries</span><span class="p">,</span> <span class="n">Long64_t</span> <span class="n">firstentry</span> <span class="o">=</span> <span class="mi">0</span><span class="p">);</span>
<span class="c1">/// Unbinned fit of one or more variable(s) from a tree.</span>
<span class="c1">/// funcname is a TF1 function.</span>
<span class="c1">/// See TTree::Draw for explanations of the other parameters.</span>
<span class="c1">/// Fit the variable varexp using the function funcname using the</span>
<span class="c1">/// selection cuts given by selection.</span>
<span class="c1">/// The list of fit options is given in parameter option.</span>
<span class="c1">/// - option = &quot;Q&quot; Quiet mode (minimum printing)</span>
<span class="c1">/// - option = &quot;V&quot; Verbose mode (default is between Q and V)</span>
<span class="c1">/// - option = &quot;E&quot; Perform better Errors estimation using Minos technique</span>
<span class="c1">/// - option = &quot;M&quot; More. Improve fit results</span>
<span class="c1">/// With this setup:</span>
<span class="c1">/// - Parameters 0-&gt;3 can vary freely</span>
<span class="c1">/// - Parameter 4 has boundaries [-10,-4] with initial value -8</span>
<span class="c1">/// - Parameter 5 is fixed to 100.</span>
<span class="c1">/// For the fit to be meaningful, the function must be self-normalized.</span>
<span class="c1">/// 1, 2 and 3 Dimensional fits are supported. See also TTree::Fit</span>
<span class="c1">/// Return status:</span>
<span class="c1">/// - The function return the status of the fit in the following form</span>
<span class="c1">///   fitResult = migradResult + 10*minosResult + 100*hesseResult + 1000*improveResult</span>
<span class="c1">/// - The fitResult is 0 is the fit is OK.</span>
<span class="c1">/// - The fitResult is negative in case of an error not connected with the fit.</span>
<span class="c1">/// - The number of entries used in the fit can be obtained via mytree.GetSelectedRows();</span>
<span class="c1">/// - If the number of selected entries is null the function returns -1</span>

   <span class="kt">void</span>                    <span class="nf">UseCurrentStyle</span><span class="p">();</span><span class="c1">/// Replace current attributes by current style.</span>
   <span class="k">virtual</span> <span class="n">Int_t</span>           <span class="nf">Write</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">Int_t</span> <span class="n">option</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">Int_t</span> <span class="n">bufsize</span><span class="o">=</span><span class="mi">0</span><span class="p">);</span>
<span class="c1">/// Write this object to the current directory. For more see TObject::Write</span>
<span class="c1">/// If option &amp; kFlushBasket, call FlushBasket before writing the tree.</span>

   <span class="k">virtual</span> <span class="n">Int_t</span>           <span class="nf">Write</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">Int_t</span> <span class="n">option</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">Int_t</span> <span class="n">bufsize</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
<span class="c1">/// Write this object to the current directory. For more see TObject::Write</span>
<span class="c1">/// Write calls TTree::FlushBaskets before writing the tree.</span>
</pre></div>
</div>
</div>
<div class="section" id="code">
<h2>code<a class="headerlink" href="#code" title="永久链接至标题">¶</a></h2>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">/// You can specify boundary limits for some or all parameters via</span>

<span class="n">func</span><span class="o">-&gt;</span><span class="n">SetParLimits</span><span class="p">(</span><span class="n">p_number</span><span class="p">,</span> <span class="n">parmin</span><span class="p">,</span> <span class="n">parmax</span><span class="p">);</span>

<span class="c1">/// if parmin&gt;=parmax, the parameter is fixed</span>

<span class="c1">/// Note that you are not forced to fix the limits for all parameters.</span>
<span class="c1">/// For example, if you fit a function with 6 parameters, you can do:</span>

<span class="n">func</span><span class="o">-&gt;</span><span class="n">SetParameters</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mf">3.1</span><span class="p">,</span><span class="mf">1.e-6</span><span class="p">,</span><span class="mf">0.1</span><span class="p">,</span><span class="o">-</span><span class="mi">8</span><span class="p">,</span><span class="mi">100</span><span class="p">);</span>
<span class="n">func</span><span class="o">-&gt;</span><span class="n">SetParLimits</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="o">-</span><span class="mi">10</span><span class="p">,</span><span class="o">-</span><span class="mi">4</span><span class="p">);</span>
<span class="n">func</span><span class="o">-&gt;</span><span class="n">SetParLimits</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span>

<span class="c1">/// i.e. It must have the same integral regardless of the parameter</span>
<span class="c1">/// settings.  Otherwise the fit will effectively just maximize the</span>
<span class="c1">/// area.</span>

<span class="c1">/// It is mandatory to have a normalization variable</span>
<span class="c1">/// which is fixed for the fit.  e.g.</span>

<span class="n">TF1</span><span class="o">*</span> <span class="n">f1</span> <span class="o">=</span> <span class="k">new</span> <span class="n">TF1</span><span class="p">(</span><span class="s">&quot;f1&quot;</span><span class="p">,</span> <span class="s">&quot;gaus(0)/sqrt(2*3.14159)/[2]&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">5</span><span class="p">);</span>
<span class="n">f1</span><span class="o">-&gt;</span><span class="n">SetParameters</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mf">3.1</span><span class="p">,</span> <span class="mf">0.01</span><span class="p">);</span>
<span class="n">f1</span><span class="o">-&gt;</span><span class="n">SetParLimits</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span> <span class="c1">// fix the normalization parameter to 1</span>
<span class="n">data</span><span class="o">-&gt;</span><span class="n">UnbinnedFit</span><span class="p">(</span><span class="s">&quot;f1&quot;</span><span class="p">,</span> <span class="s">&quot;jpsimass&quot;</span><span class="p">,</span> <span class="s">&quot;jpsipt&gt;3.0&quot;</span><span class="p">);</span>
</pre></div>
</div>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// This gives the possibility to play with more than one index, e.g.,</span>

<span class="n">TVirtualIndex</span><span class="o">*</span> <span class="n">oldIndex</span> <span class="o">=</span> <span class="n">tree</span><span class="p">.</span><span class="n">GetTreeIndex</span><span class="p">();</span>
<span class="n">tree</span><span class="p">.</span><span class="n">SetTreeIndex</span><span class="p">(</span><span class="n">newIndex</span><span class="p">);</span>
<span class="n">tree</span><span class="p">.</span><span class="n">Draw</span><span class="p">();</span>
<span class="n">tree</span><span class="p">.</span><span class="n">SetTreeIndex</span><span class="p">(</span><span class="n">oldIndex</span><span class="p">);</span>
<span class="n">tree</span><span class="p">.</span><span class="n">Draw</span><span class="p">();</span> <span class="n">etc</span>
</pre></div>
</div>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">/// Assume a tree T with sub-branches a,b,c,d,e,f,g,etc..</span>
<span class="c1">/// when doing T.GetEntry(i) all branches are read for entry i.</span>
<span class="c1">/// to read only the branches c and e, one can do</span>

<span class="n">T</span><span class="p">.</span><span class="n">SetBranchStatus</span><span class="p">(</span><span class="s">&quot;*&quot;</span><span class="p">,</span><span class="mi">0</span><span class="p">);</span> <span class="c1">//disable all branches</span>
<span class="n">T</span><span class="p">.</span><span class="n">SetBranchStatus</span><span class="p">(</span><span class="s">&quot;c&quot;</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span>
<span class="n">T</span><span class="p">.</span><span class="n">setBranchStatus</span><span class="p">(</span><span class="s">&quot;e&quot;</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span>
<span class="n">T</span><span class="p">.</span><span class="n">GetEntry</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>

<span class="c1">/// bname is interpreted as a wildcarded TRegexp (see TRegexp::MakeWildcard).</span>
<span class="c1">/// Thus, &quot;a*b&quot; or &quot;a.*b&quot; matches branches starting with &quot;a&quot; and ending with</span>
<span class="c1">/// &quot;b&quot;, but not any other branch with an &quot;a&quot; followed at some point by a</span>
<span class="c1">/// &quot;b&quot;. For this second behavior, use &quot;*a*b*&quot;. Note that TRegExp does not</span>
<span class="c1">/// support &#39;|&#39;, and so you cannot select, e.g. track and shower branches</span>
<span class="c1">/// with &quot;track|shower&quot;.</span>

<span class="c1">/// I.e If your Tree has been created in split mode with a parent branch &quot;parent.&quot;</span>
<span class="c1">/// (note the trailing dot).</span>

<span class="n">T</span><span class="p">.</span><span class="n">SetBranchStatus</span><span class="p">(</span><span class="s">&quot;parent&quot;</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span>

<span class="c1">/// will not activate the sub-branches of &quot;parent&quot;. You should do:</span>

<span class="n">T</span><span class="p">.</span><span class="n">SetBranchStatus</span><span class="p">(</span><span class="s">&quot;parent*&quot;</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span>

<span class="c1">/// Without the trailing dot in the branch creation you have no choice but to</span>
<span class="c1">/// call SetBranchStatus explicitly for each of the sub branches.</span>

<span class="c1">/// An alternative to this function is to read directly and only</span>
<span class="c1">/// the interesting branches. Example:</span>

<span class="n">TBranch</span> <span class="o">*</span><span class="n">brc</span> <span class="o">=</span> <span class="n">T</span><span class="p">.</span><span class="n">GetBranch</span><span class="p">(</span><span class="s">&quot;c&quot;</span><span class="p">);</span>
<span class="n">TBranch</span> <span class="o">*</span><span class="n">bre</span> <span class="o">=</span> <span class="n">T</span><span class="p">.</span><span class="n">GetBranch</span><span class="p">(</span><span class="s">&quot;e&quot;</span><span class="p">);</span>
<span class="n">brc</span><span class="o">-&gt;</span><span class="n">GetEntry</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
<span class="n">bre</span><span class="o">-&gt;</span><span class="n">GetEntry</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
</pre></div>
</div>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">tree</span><span class="o">-&gt;</span><span class="n">SetAlias</span><span class="p">(</span><span class="s">&quot;x1&quot;</span><span class="p">,</span><span class="s">&quot;(tdc1[1]-tdc1[0])/49&quot;</span><span class="p">);</span>
<span class="n">tree</span><span class="o">-&gt;</span><span class="n">SetAlias</span><span class="p">(</span><span class="s">&quot;y1&quot;</span><span class="p">,</span><span class="s">&quot;(tdc1[3]-tdc1[2])/47&quot;</span><span class="p">);</span>
<span class="n">tree</span><span class="o">-&gt;</span><span class="n">SetAlias</span><span class="p">(</span><span class="s">&quot;x2&quot;</span><span class="p">,</span><span class="s">&quot;(tdc2[1]-tdc2[0])/49&quot;</span><span class="p">);</span>
<span class="n">tree</span><span class="o">-&gt;</span><span class="n">SetAlias</span><span class="p">(</span><span class="s">&quot;y2&quot;</span><span class="p">,</span><span class="s">&quot;(tdc2[3]-tdc2[2])/47&quot;</span><span class="p">);</span>
<span class="n">tree</span><span class="o">-&gt;</span><span class="n">Draw</span><span class="p">(</span><span class="s">&quot;y2-y1:x2-x1&quot;</span><span class="p">);</span>

<span class="n">tree</span><span class="o">-&gt;</span><span class="n">SetAlias</span><span class="p">(</span><span class="s">&quot;theGoodTrack&quot;</span><span class="p">,</span><span class="s">&quot;event.fTracks[3]&quot;</span><span class="p">);</span>
<span class="n">tree</span><span class="o">-&gt;</span><span class="n">Draw</span><span class="p">(</span><span class="s">&quot;theGoodTrack.fPx&quot;</span><span class="p">);</span> <span class="c1">// same as &quot;event.fTracks[3].fPx&quot;</span>
</pre></div>
</div>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">/// To fill a TTree with multiple input text files, proceed as indicated above</span>
<span class="c1">/// for the first input file and omit the second argument for subsequent calls</span>

<span class="n">T</span><span class="p">.</span><span class="n">ReadFile</span><span class="p">(</span><span class="s">&quot;file1.dat&quot;</span><span class="p">,</span><span class="s">&quot;branch descriptor&quot;</span><span class="p">);</span>
<span class="n">T</span><span class="p">.</span><span class="n">ReadFile</span><span class="p">(</span><span class="s">&quot;file2.dat&quot;</span><span class="p">);</span>
</pre></div>
</div>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">/// ## NOTE1</span>
<span class="c1">/// It may be more interesting to invoke directly the other Process function</span>
<span class="c1">/// accepting a TSelector* as argument.eg</span>

<span class="n">MySelector</span> <span class="o">*</span><span class="n">selector</span> <span class="o">=</span> <span class="p">(</span><span class="n">MySelector</span><span class="o">*</span><span class="p">)</span><span class="n">TSelector</span><span class="o">::</span><span class="n">GetSelector</span><span class="p">(</span><span class="n">filename</span><span class="p">);</span>
<span class="n">selector</span><span class="o">-&gt;</span><span class="n">CallSomeFunction</span><span class="p">(..);</span>
<span class="n">mytree</span><span class="p">.</span><span class="n">Process</span><span class="p">(</span><span class="n">selector</span><span class="p">,..);</span>

<span class="c1">/// ## NOTE2</span>
<span class="c1">/// One should not call this function twice with the same selector file</span>
<span class="c1">/// in the same script. If this is required, proceed as indicated in NOTE1,</span>
<span class="c1">/// by getting a pointer to the corresponding TSelector,eg</span>

<span class="kt">void</span> <span class="nf">stubs1</span><span class="p">()</span> <span class="p">{</span>
   <span class="n">TSelector</span> <span class="o">*</span><span class="n">selector</span> <span class="o">=</span> <span class="n">TSelector</span><span class="o">::</span><span class="n">GetSelector</span><span class="p">(</span><span class="s">&quot;h1test.C&quot;</span><span class="p">);</span>
   <span class="n">TFile</span> <span class="o">*</span><span class="n">f1</span> <span class="o">=</span> <span class="k">new</span> <span class="n">TFile</span><span class="p">(</span><span class="s">&quot;stubs_nood_le1.root&quot;</span><span class="p">);</span>
   <span class="n">TTree</span> <span class="o">*</span><span class="n">h1</span> <span class="o">=</span> <span class="p">(</span><span class="n">TTree</span><span class="o">*</span><span class="p">)</span><span class="n">f1</span><span class="o">-&gt;</span><span class="n">Get</span><span class="p">(</span><span class="s">&quot;h1&quot;</span><span class="p">);</span>
   <span class="n">h1</span><span class="o">-&gt;</span><span class="n">Process</span><span class="p">(</span><span class="n">selector</span><span class="p">);</span>
   <span class="n">TFile</span> <span class="o">*</span><span class="n">f2</span> <span class="o">=</span> <span class="k">new</span> <span class="n">TFile</span><span class="p">(</span><span class="s">&quot;stubs_nood_le1_coarse.root&quot;</span><span class="p">);</span>
    <span class="n">TTree</span> <span class="o">*</span><span class="n">h2</span> <span class="o">=</span> <span class="p">(</span><span class="n">TTree</span><span class="o">*</span><span class="p">)</span><span class="n">f2</span><span class="o">-&gt;</span><span class="n">Get</span><span class="p">(</span><span class="s">&quot;h1&quot;</span><span class="p">);</span>
    <span class="n">h2</span><span class="o">-&gt;</span><span class="n">Process</span><span class="p">(</span><span class="n">selector</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">/// or use ACLIC to compile the selector</span>

<span class="kt">void</span> <span class="nf">stubs2</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">TFile</span> <span class="o">*</span><span class="n">f1</span> <span class="o">=</span> <span class="k">new</span> <span class="n">TFile</span><span class="p">(</span><span class="s">&quot;stubs_nood_le1.root&quot;</span><span class="p">);</span>
    <span class="n">TTree</span> <span class="o">*</span><span class="n">h1</span> <span class="o">=</span> <span class="p">(</span><span class="n">TTree</span><span class="o">*</span><span class="p">)</span><span class="n">f1</span><span class="o">-&gt;</span><span class="n">Get</span><span class="p">(</span><span class="s">&quot;h1&quot;</span><span class="p">);</span>
    <span class="n">h1</span><span class="o">-&gt;</span><span class="n">Process</span><span class="p">(</span><span class="s">&quot;h1test.C+&quot;</span><span class="p">);</span>
   <span class="n">TFile</span> <span class="o">*</span><span class="n">f2</span> <span class="o">=</span> <span class="k">new</span> <span class="n">TFile</span><span class="p">(</span><span class="s">&quot;stubs_nood_le1_coarse.root&quot;</span><span class="p">);</span>
   <span class="n">TTree</span> <span class="o">*</span><span class="n">h2</span> <span class="o">=</span> <span class="p">(</span><span class="n">TTree</span><span class="o">*</span><span class="p">)</span><span class="n">f2</span><span class="o">-&gt;</span><span class="n">Get</span><span class="p">(</span><span class="s">&quot;h1&quot;</span><span class="p">);</span>
   <span class="n">h2</span><span class="o">-&gt;</span><span class="n">Process</span><span class="p">(</span><span class="s">&quot;h1test.C+&quot;</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">/// you can retrieve a pointer to the created object via:</span>

<span class="n">TPrincipal</span> <span class="o">*</span><span class="n">principal</span> <span class="o">=</span> <span class="p">(</span><span class="n">TPrincipal</span><span class="o">*</span><span class="p">)</span><span class="n">gROOT</span><span class="o">-&gt;</span><span class="n">GetListOfSpecials</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">FindObject</span><span class="p">(</span><span class="s">&quot;principal&quot;</span><span class="p">);</span>
</pre></div>
</div>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">/// For example with Event.root, if</span>

<span class="n">Double_t</span> <span class="n">somePx</span> <span class="o">=</span> <span class="n">fTracks</span><span class="p">.</span><span class="n">fPx</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>

<span class="c1">/// is executed by one of the method of the skeleton,</span>
<span class="c1">/// somePx will updated with the current value of fPx of the 3rd track.</span>

<span class="c1">/// Both macrofilename and the optional cutfilename are expected to be</span>
<span class="c1">/// the name of source files which contain at least a free standing</span>
<span class="c1">/// function with the signature:</span>

<span class="n">x_t</span> <span class="nf">macrofilename</span><span class="p">();</span> <span class="c1">// i.e function with the same name as the file</span>

<span class="c1">/// and</span>

<span class="n">y_t</span> <span class="nf">cutfilename</span><span class="p">();</span>   <span class="c1">// i.e function with the same name as the file</span>

<span class="c1">/// x_t and y_t needs to be types that can convert respectively to a double</span>
<span class="c1">/// and a bool (because the skeleton uses:</span>

<span class="k">if</span> <span class="p">(</span><span class="n">cutfilename</span><span class="p">())</span> <span class="n">htemp</span><span class="o">-&gt;</span><span class="n">Fill</span><span class="p">(</span><span class="n">macrofilename</span><span class="p">());</span>

<span class="c1">/// These two functions are run in a context such that the branch names are</span>
<span class="c1">/// available as local variables of the correct (read-only) type.</span>

<span class="c1">/// Note that if you use the same &#39;variable&#39; twice, it is more efficient</span>
<span class="c1">/// to &#39;cache&#39; the value. For example:</span>

<span class="n">Int_t</span> <span class="n">n</span> <span class="o">=</span> <span class="n">fEventNumber</span><span class="p">;</span> <span class="c1">// Read fEventNumber</span>
<span class="k">if</span> <span class="p">(</span><span class="n">n</span><span class="o">&lt;</span><span class="mi">10</span> <span class="o">||</span> <span class="n">n</span><span class="o">&gt;</span><span class="mi">10</span><span class="p">)</span> <span class="p">{</span> <span class="p">...</span> <span class="p">}</span>

<span class="c1">/// is more efficient than</span>

<span class="k">if</span> <span class="p">(</span><span class="n">fEventNumber</span><span class="o">&lt;</span><span class="mi">10</span> <span class="o">||</span> <span class="n">fEventNumber</span><span class="o">&gt;</span><span class="mi">10</span><span class="p">)</span>

<span class="c1">/// Also, optionally, the generated selector will also call methods named</span>
<span class="c1">/// macrofilename_methodname in each of 6 main selector methods if the method</span>
<span class="c1">/// macrofilename_methodname exist (Where macrofilename is stripped of its</span>
<span class="c1">/// extension).</span>

<span class="c1">/// To draw px using the file hsimple.root (generated by the</span>
<span class="c1">/// hsimple.C tutorial), we need a file named hsimple.cxx:</span>

<span class="kt">double</span> <span class="n">hsimple</span><span class="p">()</span> <span class="p">{</span>
   <span class="k">return</span> <span class="n">px</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">/// MakeProxy can then be used indirectly via the TTree::Draw interface</span>
<span class="c1">/// as follow:</span>

<span class="k">new</span> <span class="n">TFile</span><span class="p">(</span><span class="s">&quot;hsimple.root&quot;</span><span class="p">)</span>
<span class="n">ntuple</span><span class="o">-&gt;</span><span class="n">Draw</span><span class="p">(</span><span class="s">&quot;hsimple.cxx&quot;</span><span class="p">);</span>
</pre></div>
</div>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">/// To use this function:</span>
<span class="c1">/// - Open your tree file (eg: TFile f(&quot;myfile.root&quot;);)</span>
<span class="c1">/// - T-&gt;MakeClass(&quot;MyClass&quot;);</span>

<span class="c1">/// where T is the name of the TTree in file myfile.root,</span>
<span class="c1">/// and MyClass.h, MyClass.C the name of the files created by this function.</span>
<span class="c1">/// In a ROOT session, you can do:</span>

<span class="n">root</span> <span class="o">&gt;</span> <span class="p">.</span><span class="n">L</span> <span class="n">MyClass</span><span class="p">.</span><span class="n">C</span>
<span class="n">root</span> <span class="o">&gt;</span> <span class="n">MyClass</span><span class="o">*</span> <span class="n">t</span> <span class="o">=</span> <span class="k">new</span> <span class="n">MyClass</span><span class="p">;</span>
<span class="n">root</span> <span class="o">&gt;</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">GetEntry</span><span class="p">(</span><span class="mi">12</span><span class="p">);</span> <span class="c1">// Fill data members of t with entry number 12.</span>
<span class="n">root</span> <span class="o">&gt;</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">Show</span><span class="p">();</span>       <span class="c1">// Show values of entry 12.</span>
<span class="n">root</span> <span class="o">&gt;</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">Show</span><span class="p">(</span><span class="mi">16</span><span class="p">);</span>     <span class="c1">// Read and show values of entry 16.</span>
<span class="n">root</span> <span class="o">&gt;</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">Loop</span><span class="p">();</span>       <span class="c1">// Loop on all entries.</span>
</pre></div>
</div>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">/// To activate/deactivate one or more branches, use TBranch::SetBranchStatus</span>
<span class="c1">/// For example, if you have a Tree with several hundred branches, and you</span>
<span class="c1">/// are interested only by branches named &quot;a&quot; and &quot;b&quot;, do</span>

<span class="n">mytree</span><span class="p">.</span><span class="n">SetBranchStatus</span><span class="p">(</span><span class="s">&quot;*&quot;</span><span class="p">,</span><span class="mi">0</span><span class="p">);</span> <span class="c1">//disable all branches</span>
<span class="n">mytree</span><span class="p">.</span><span class="n">SetBranchStatus</span><span class="p">(</span><span class="s">&quot;a&quot;</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span>
<span class="n">mytree</span><span class="p">.</span><span class="n">SetBranchStatus</span><span class="p">(</span><span class="s">&quot;b&quot;</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span>

<span class="c1">/// when calling mytree.GetEntry(i); only branches &quot;a&quot; and &quot;b&quot; will be read.</span>

<span class="c1">/// __WARNING!!__</span>
<span class="c1">/// If your Tree has been created in split mode with a parent branch &quot;parent.&quot;,</span>

<span class="n">mytree</span><span class="p">.</span><span class="n">SetBranchStatus</span><span class="p">(</span><span class="s">&quot;parent&quot;</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span>

<span class="c1">/// will not activate the sub-branches of &quot;parent&quot;. You should do:</span>

<span class="n">mytree</span><span class="p">.</span><span class="n">SetBranchStatus</span><span class="p">(</span><span class="s">&quot;parent*&quot;</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span>

<span class="c1">/// Without the trailing dot in the branch creation you have no choice but to</span>
<span class="c1">/// call SetBranchStatus explicitly for each of the sub branches.</span>

<span class="c1">/// An alternative is to call directly</span>

<span class="n">brancha</span><span class="p">.</span><span class="n">GetEntry</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
<span class="n">branchb</span><span class="p">.</span><span class="n">GetEntry</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>


<span class="c1">/// Consider the example in $ROOTSYS/test/Event.h</span>
<span class="c1">/// The top level branch in the tree T is declared with:</span>

<span class="n">Event</span> <span class="o">*</span><span class="n">event</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>  <span class="c1">//event must be null or point to a valid object</span>
                   <span class="c1">//it must be initialized</span>
<span class="n">T</span><span class="p">.</span><span class="n">SetBranchAddress</span><span class="p">(</span><span class="s">&quot;event&quot;</span><span class="p">,</span><span class="o">&amp;</span><span class="n">event</span><span class="p">);</span>

<span class="c1">/// When reading the Tree, one can choose one of these 3 options:</span>
<span class="c1">///</span>
<span class="c1">/// ## OPTION 1</span>

<span class="k">for</span> <span class="p">(</span><span class="n">Long64_t</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">nentries</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
   <span class="n">T</span><span class="p">.</span><span class="n">GetEntry</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
   <span class="c1">// the object event has been filled at this point</span>
<span class="p">}</span>

<span class="c1">/// The default (recommended). At the first entry an object of the class</span>
<span class="c1">/// Event will be created and pointed by event. At the following entries,</span>
<span class="c1">/// event will be overwritten by the new data. All internal members that are</span>
<span class="c1">/// TObject* are automatically deleted. It is important that these members</span>
<span class="c1">/// be in a valid state when GetEntry is called. Pointers must be correctly</span>
<span class="c1">/// initialized. However these internal members will not be deleted if the</span>
<span class="c1">/// characters &quot;-&gt;&quot; are specified as the first characters in the comment</span>
<span class="c1">/// field of the data member declaration.</span>
<span class="c1">///</span>
<span class="c1">/// If &quot;-&gt;&quot; is specified, the pointer member is read via pointer-&gt;Streamer(buf).</span>
<span class="c1">/// In this case, it is assumed that the pointer is never null (case of</span>
<span class="c1">/// pointer TClonesArray *fTracks in the Event example). If &quot;-&gt;&quot; is not</span>
<span class="c1">/// specified, the pointer member is read via buf &gt;&gt; pointer. In this case</span>
<span class="c1">/// the pointer may be null. Note that the option with &quot;-&gt;&quot; is faster to</span>
<span class="c1">/// read or write and it also consumes less space in the file.</span>
<span class="c1">///</span>
<span class="c1">/// ## OPTION 2</span>
<span class="c1">///</span>
<span class="c1">/// The option AutoDelete is set</span>

<span class="n">TBranch</span> <span class="o">*</span><span class="n">branch</span> <span class="o">=</span> <span class="n">T</span><span class="p">.</span><span class="n">GetBranch</span><span class="p">(</span><span class="s">&quot;event&quot;</span><span class="p">);</span>
<span class="n">branch</span><span class="o">-&gt;</span><span class="n">SetAddress</span><span class="p">(</span><span class="o">&amp;</span><span class="n">event</span><span class="p">);</span>
<span class="n">branch</span><span class="o">-&gt;</span><span class="n">SetAutoDelete</span><span class="p">(</span><span class="n">kTRUE</span><span class="p">);</span>
<span class="k">for</span> <span class="p">(</span><span class="n">Long64_t</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">nentries</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
   <span class="n">T</span><span class="p">.</span><span class="n">GetEntry</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
   <span class="c1">// the object event has been filled at this point</span>
<span class="p">}</span>

<span class="c1">/// In this case, at each iteration, the object event is deleted by GetEntry</span>
<span class="c1">/// and a new instance of Event is created and filled.</span>

<span class="c1">/// ## OPTION 3</span>

<span class="c1">/// Same as option 1, but you delete yourself the event.</span>

<span class="k">for</span> <span class="p">(</span><span class="n">Long64_t</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">nentries</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
   <span class="k">delete</span> <span class="n">event</span><span class="p">;</span>
   <span class="n">event</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>  <span class="c1">// EXTREMELY IMPORTANT</span>
   <span class="n">T</span><span class="p">.</span><span class="n">GetEntry</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
    <span class="c1">// the object event has been filled at this point</span>
<span class="p">}</span>

<span class="c1">/// It is strongly recommended to use the default option 1. It has the</span>
<span class="c1">/// additional advantage that functions like TTree::Draw (internally calling</span>
<span class="c1">/// TTree::GetEntry) will be functional even when the classes in the file are</span>
<span class="c1">/// not available.</span>

<span class="c1">/// Note: See the comments in TBranchElement::SetAddress() for the</span>
<span class="c1">/// object ownership policy of the underlying (user) data.</span>
</pre></div>
</div>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">TTree</span><span class="o">::</span><span class="n">TClusterIterator</span> <span class="n">clusterIter</span> <span class="o">=</span> <span class="n">tree</span><span class="o">-&gt;</span><span class="n">GetClusterIterator</span><span class="p">(</span><span class="n">entry</span><span class="p">);</span>
<span class="n">Long64_t</span> <span class="n">clusterStart</span><span class="p">;</span>
<span class="k">while</span><span class="p">(</span> <span class="p">(</span><span class="n">clusterStart</span> <span class="o">=</span> <span class="n">clusterIter</span><span class="p">())</span> <span class="o">&lt;</span> <span class="n">tree</span><span class="o">-&gt;</span><span class="n">GetEntries</span><span class="p">()</span> <span class="p">)</span> <span class="p">{</span>
   <span class="n">printf</span><span class="p">(</span><span class="s">&quot;The cluster starts at %lld and ends at %lld (inclusive)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="n">clusterStart</span><span class="p">,</span><span class="n">clusterIter</span><span class="p">.</span><span class="n">GetNextEntry</span><span class="p">()</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">tree</span><span class="p">.</span><span class="n">Fit</span><span class="p">(</span><span class="n">pol4</span><span class="p">,</span><span class="n">sqrt</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">&gt;&gt;</span><span class="n">hsqrt</span><span class="p">,</span><span class="n">y</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">)</span>

<span class="c1">/// will fit sqrt(x) and save the histogram as &quot;hsqrt&quot; in the current</span>
<span class="c1">/// directory.</span>

<span class="c1">/// See also TTree::UnbinnedFit</span>
</pre></div>
</div>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// virtual Int_t           Branch(TCollection* list, Int_t bufsize = 32000, Int_t splitlevel = 99, const char* name = &quot;&quot;);</span>

<span class="p">{</span>
      <span class="n">TTree</span> <span class="n">T</span><span class="p">(</span><span class="s">&quot;T&quot;</span><span class="p">,</span><span class="s">&quot;test list&quot;</span><span class="p">);</span>
      <span class="n">TList</span> <span class="o">*</span><span class="n">list</span> <span class="o">=</span> <span class="k">new</span> <span class="n">TList</span><span class="p">();</span>

      <span class="n">TObjArray</span> <span class="o">*</span><span class="n">a1</span> <span class="o">=</span> <span class="k">new</span> <span class="n">TObjArray</span><span class="p">();</span>
      <span class="n">a1</span><span class="o">-&gt;</span><span class="n">SetName</span><span class="p">(</span><span class="s">&quot;a1&quot;</span><span class="p">);</span>
      <span class="n">list</span><span class="o">-&gt;</span><span class="n">Add</span><span class="p">(</span><span class="n">a1</span><span class="p">);</span>
      <span class="n">TH1F</span> <span class="o">*</span><span class="n">ha1a</span> <span class="o">=</span> <span class="k">new</span> <span class="n">TH1F</span><span class="p">(</span><span class="s">&quot;ha1a&quot;</span><span class="p">,</span><span class="s">&quot;ha1&quot;</span><span class="p">,</span><span class="mi">100</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span>
      <span class="n">TH1F</span> <span class="o">*</span><span class="n">ha1b</span> <span class="o">=</span> <span class="k">new</span> <span class="n">TH1F</span><span class="p">(</span><span class="s">&quot;ha1b&quot;</span><span class="p">,</span><span class="s">&quot;ha1&quot;</span><span class="p">,</span><span class="mi">100</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span>
      <span class="n">a1</span><span class="o">-&gt;</span><span class="n">Add</span><span class="p">(</span><span class="n">ha1a</span><span class="p">);</span>
      <span class="n">a1</span><span class="o">-&gt;</span><span class="n">Add</span><span class="p">(</span><span class="n">ha1b</span><span class="p">);</span>
      <span class="n">TObjArray</span> <span class="o">*</span><span class="n">b1</span> <span class="o">=</span> <span class="k">new</span> <span class="n">TObjArray</span><span class="p">();</span>
      <span class="n">b1</span><span class="o">-&gt;</span><span class="n">SetName</span><span class="p">(</span><span class="s">&quot;b1&quot;</span><span class="p">);</span>
      <span class="n">list</span><span class="o">-&gt;</span><span class="n">Add</span><span class="p">(</span><span class="n">b1</span><span class="p">);</span>
      <span class="n">TH1F</span> <span class="o">*</span><span class="n">hb1a</span> <span class="o">=</span> <span class="k">new</span> <span class="n">TH1F</span><span class="p">(</span><span class="s">&quot;hb1a&quot;</span><span class="p">,</span><span class="s">&quot;hb1&quot;</span><span class="p">,</span><span class="mi">100</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span>
      <span class="n">TH1F</span> <span class="o">*</span><span class="n">hb1b</span> <span class="o">=</span> <span class="k">new</span> <span class="n">TH1F</span><span class="p">(</span><span class="s">&quot;hb1b&quot;</span><span class="p">,</span><span class="s">&quot;hb1&quot;</span><span class="p">,</span><span class="mi">100</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span>
      <span class="n">b1</span><span class="o">-&gt;</span><span class="n">Add</span><span class="p">(</span><span class="n">hb1a</span><span class="p">);</span>
      <span class="n">b1</span><span class="o">-&gt;</span><span class="n">Add</span><span class="p">(</span><span class="n">hb1b</span><span class="p">);</span>

      <span class="n">TObjArray</span> <span class="o">*</span><span class="n">a2</span> <span class="o">=</span> <span class="k">new</span> <span class="n">TObjArray</span><span class="p">();</span>
      <span class="n">a2</span><span class="o">-&gt;</span><span class="n">SetName</span><span class="p">(</span><span class="s">&quot;a2&quot;</span><span class="p">);</span>
      <span class="n">list</span><span class="o">-&gt;</span><span class="n">Add</span><span class="p">(</span><span class="n">a2</span><span class="p">);</span>
      <span class="n">TH1S</span> <span class="o">*</span><span class="n">ha2a</span> <span class="o">=</span> <span class="k">new</span> <span class="n">TH1S</span><span class="p">(</span><span class="s">&quot;ha2a&quot;</span><span class="p">,</span><span class="s">&quot;ha2&quot;</span><span class="p">,</span><span class="mi">100</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span>
      <span class="n">TH1S</span> <span class="o">*</span><span class="n">ha2b</span> <span class="o">=</span> <span class="k">new</span> <span class="n">TH1S</span><span class="p">(</span><span class="s">&quot;ha2b&quot;</span><span class="p">,</span><span class="s">&quot;ha2&quot;</span><span class="p">,</span><span class="mi">100</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span>
      <span class="n">a2</span><span class="o">-&gt;</span><span class="n">Add</span><span class="p">(</span><span class="n">ha2a</span><span class="p">);</span>
      <span class="n">a2</span><span class="o">-&gt;</span><span class="n">Add</span><span class="p">(</span><span class="n">ha2b</span><span class="p">);</span>

      <span class="n">T</span><span class="p">.</span><span class="n">Branch</span><span class="p">(</span><span class="n">list</span><span class="p">,</span><span class="mi">16000</span><span class="p">,</span><span class="mi">2</span><span class="p">);</span>
      <span class="n">T</span><span class="p">.</span><span class="n">Print</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// virtual Long64_t        AutoSave(Option_t* option = &quot;&quot;);</span>

<span class="kt">void</span> <span class="nf">treew</span><span class="p">()</span> <span class="p">{</span>
   <span class="n">TFile</span> <span class="n">f</span><span class="p">(</span><span class="s">&quot;test.root&quot;</span><span class="p">,</span><span class="s">&quot;recreate&quot;</span><span class="p">);</span>
   <span class="n">TNtuple</span> <span class="o">*</span><span class="n">ntuple</span> <span class="o">=</span> <span class="k">new</span> <span class="n">TNtuple</span><span class="p">(</span><span class="s">&quot;ntuple&quot;</span><span class="p">,</span><span class="s">&quot;Demo&quot;</span><span class="p">,</span><span class="s">&quot;px:py:pz:random:i&quot;</span><span class="p">);</span>
   <span class="n">Float_t</span> <span class="n">px</span><span class="p">,</span> <span class="n">py</span><span class="p">,</span> <span class="n">pz</span><span class="p">;</span>
   <span class="k">for</span> <span class="p">(</span> <span class="n">Int_t</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="mi">10000000</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">gRandom</span><span class="o">-&gt;</span><span class="n">Rannor</span><span class="p">(</span><span class="n">px</span><span class="p">,</span><span class="n">py</span><span class="p">);</span>
      <span class="n">pz</span> <span class="o">=</span> <span class="n">px</span><span class="o">*</span><span class="n">px</span> <span class="o">+</span> <span class="n">py</span><span class="o">*</span><span class="n">py</span><span class="p">;</span>
      <span class="n">Float_t</span> <span class="n">random</span> <span class="o">=</span> <span class="n">gRandom</span><span class="o">-&gt;</span><span class="n">Rndm</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
      <span class="n">ntuple</span><span class="o">-&gt;</span><span class="n">Fill</span><span class="p">(</span><span class="n">px</span><span class="p">,</span><span class="n">py</span><span class="p">,</span><span class="n">pz</span><span class="p">,</span><span class="n">random</span><span class="p">,</span><span class="n">i</span><span class="p">);</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">i</span><span class="o">%</span><span class="mi">1000</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="n">ntuple</span><span class="o">-&gt;</span><span class="n">AutoSave</span><span class="p">(</span><span class="s">&quot;SaveSelf&quot;</span><span class="p">);</span>
   <span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">treer</span><span class="p">()</span> <span class="p">{</span>
   <span class="n">TFile</span> <span class="n">f</span><span class="p">(</span><span class="s">&quot;test.root&quot;</span><span class="p">);</span>
   <span class="n">TTree</span> <span class="o">*</span><span class="n">ntuple</span> <span class="o">=</span> <span class="p">(</span><span class="n">TTree</span><span class="o">*</span><span class="p">)</span><span class="n">f</span><span class="p">.</span><span class="n">Get</span><span class="p">(</span><span class="s">&quot;ntuple&quot;</span><span class="p">);</span>
   <span class="n">TCanvas</span> <span class="n">c1</span><span class="p">;</span>
   <span class="n">Int_t</span> <span class="n">first</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
   <span class="k">while</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">first</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="n">ntuple</span><span class="o">-&gt;</span><span class="n">Draw</span><span class="p">(</span><span class="s">&quot;px&gt;&gt;hpx&quot;</span><span class="p">,</span> <span class="s">&quot;&quot;</span><span class="p">,</span><span class="s">&quot;&quot;</span><span class="p">,</span><span class="mi">10000000</span><span class="p">,</span><span class="n">first</span><span class="p">);</span>
      <span class="k">else</span>            <span class="n">ntuple</span><span class="o">-&gt;</span><span class="n">Draw</span><span class="p">(</span><span class="s">&quot;px&gt;&gt;+hpx&quot;</span><span class="p">,</span><span class="s">&quot;&quot;</span><span class="p">,</span><span class="s">&quot;&quot;</span><span class="p">,</span><span class="mi">10000000</span><span class="p">,</span><span class="n">first</span><span class="p">);</span>
      <span class="n">first</span> <span class="o">=</span> <span class="p">(</span><span class="n">Int_t</span><span class="p">)</span><span class="n">ntuple</span><span class="o">-&gt;</span><span class="n">GetEntries</span><span class="p">();</span>
      <span class="n">c1</span><span class="p">.</span><span class="n">Update</span><span class="p">();</span>
      <span class="n">gSystem</span><span class="o">-&gt;</span><span class="n">Sleep</span><span class="p">(</span><span class="mi">1000</span><span class="p">);</span> <span class="c1">//sleep 1 second</span>
      <span class="n">ntuple</span><span class="o">-&gt;</span><span class="n">Refresh</span><span class="p">();</span>
   <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// You may want to add a branch to an existing tree. For example,</span>
<span class="c1">// if one variable in the tree was computed with a certain algorithm,</span>
<span class="c1">// you may want to try another algorithm and compare the results.</span>
<span class="c1">// One solution is to add a new branch, fill it, and save the tree.</span>
<span class="c1">// The code below adds a simple branch to an existing tree.</span>
<span class="c1">// Note the kOverwrite option in the Write method, it overwrites the</span>
<span class="c1">// existing tree. If it is not specified, two copies of the tree headers</span>
<span class="c1">// are saved.</span>

<span class="kt">void</span> <span class="nf">tree3AddBranch</span><span class="p">()</span> <span class="p">{</span>
<span class="n">TFile</span> <span class="n">f</span><span class="p">(</span><span class="s">&quot;tree3.root&quot;</span><span class="p">,</span> <span class="s">&quot;update&quot;</span><span class="p">);</span>

<span class="n">Float_t</span> <span class="n">new_v</span><span class="p">;</span>
<span class="n">TTree</span> <span class="o">*</span><span class="n">t3</span> <span class="o">=</span> <span class="p">(</span><span class="n">TTree</span><span class="o">*</span><span class="p">)</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">Get</span><span class="p">(</span><span class="s">&quot;t3&quot;</span><span class="p">);</span>
<span class="n">TBranch</span> <span class="o">*</span><span class="n">newBranch</span> <span class="o">=</span> <span class="n">t3</span><span class="o">-&gt;</span><span class="n">Branch</span><span class="p">(</span><span class="s">&quot;new_v&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">new_v</span><span class="p">,</span> <span class="s">&quot;new_v/F&quot;</span><span class="p">);</span>

<span class="n">Long64_t</span> <span class="n">nentries</span> <span class="o">=</span> <span class="n">t3</span><span class="o">-&gt;</span><span class="n">GetEntries</span><span class="p">();</span> <span class="c1">// read the number of entries in the t3</span>

<span class="k">for</span> <span class="p">(</span><span class="n">Long64_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nentries</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
<span class="n">new_v</span><span class="o">=</span> <span class="n">gRandom</span><span class="o">-&gt;</span><span class="n">Gaus</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="n">newBranch</span><span class="o">-&gt;</span><span class="n">Fill</span><span class="p">();</span>
<span class="p">}</span>

<span class="n">t3</span><span class="o">-&gt;</span><span class="n">Write</span><span class="p">(</span><span class="s">&quot;&quot;</span><span class="p">,</span> <span class="n">TObject</span><span class="o">::</span><span class="n">kOverwrite</span><span class="p">);</span> <span class="c1">// save only the new version of the tree</span>
<span class="p">}</span>

<span class="c1">// Adding a branch is often not possible because the tree is in a read-only</span>
<span class="c1">// file and you do not have permission to save the modified tree with the</span>
<span class="c1">// new branch. Even if you do have the permission, you risk losing the</span>
<span class="c1">// original tree with an unsuccessful attempt to save  the modification.</span>
<span class="c1">// Since trees are usually large, adding a branch could extend it over the</span>
<span class="c1">// 2GB limit. In this case, the attempt to write the tree fails, and the</span>
<span class="c1">// original data is erased.</span>
<span class="c1">// In addition, adding a branch to a tree enlarges the tree and increases</span>
<span class="c1">// the amount of memory needed to read an entry, and therefore decreases</span>
<span class="c1">// the performance.</span>
</pre></div>
</div>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// Store data from tree to vector</span>
<span class="n">t</span><span class="o">-&gt;</span><span class="n">SetEstimate</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
<span class="n">t</span><span class="o">-&gt;</span><span class="n">Draw</span><span class="p">(</span><span class="s">&quot;energy&quot;</span><span class="p">);</span>
<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Double_t</span><span class="o">&gt;</span> <span class="n">Vals</span><span class="p">(</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">GetV1</span><span class="p">(),</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">GetV1</span><span class="p">()</span> <span class="o">+</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">GetSelectedRows</span><span class="p">());</span>
</pre></div>
</div>
<p>写数据的同时另一个程序读取</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// The use of the non-default TObject::kOverwrite is fatal in this case. TObject::kOverwrite is an explicit to first remove the previous copy and then write the new copy (lightly in place of the hold one) into the file. This significantly increase the risk that the writing happens while the reader in not yet done reading.</span>
<span class="c1">// If you want the write the object safely while still disabling the keeping of cycle (backup copy) use TObject::kWriteDelete (which write then deletes).</span>
<span class="c1">// You can also use SaveSelf rather than Flush but then need to explicitly store each historgram.</span>
<span class="cp">#include</span> <span class="cpf">&quot;TFile.h&quot;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&quot;TH1F.h&quot;</span><span class="cp"></span>

<span class="kt">void</span> <span class="nf">writer</span><span class="p">()</span> <span class="p">{</span>
   <span class="n">TFile</span> <span class="o">*</span><span class="n">f</span> <span class="o">=</span> <span class="k">new</span> <span class="n">TFile</span><span class="p">(</span><span class="s">&quot;test.root&quot;</span><span class="p">,</span><span class="s">&quot;RECREATE&quot;</span><span class="p">);</span>
   <span class="n">TH1F</span> <span class="o">*</span><span class="n">h</span> <span class="o">=</span> <span class="k">new</span> <span class="n">TH1F</span><span class="p">(</span><span class="s">&quot;h&quot;</span><span class="p">,</span><span class="s">&quot;h&quot;</span><span class="p">,</span><span class="mi">100</span><span class="p">,</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">);</span>
   <span class="n">f</span><span class="o">-&gt;</span><span class="n">Write</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">TObject</span><span class="o">::</span><span class="n">kReadWrite</span><span class="p">);</span>
   <span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
   <span class="k">while</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">printf</span><span class="p">(</span><span class="s">&quot;Loop %d</span><span class="se">\r</span><span class="s">&quot;</span><span class="p">,</span><span class="n">count</span><span class="o">++</span><span class="p">);</span>
      <span class="n">fflush</span><span class="p">(</span><span class="n">stdout</span><span class="p">);</span>
      <span class="n">h</span><span class="o">-&gt;</span><span class="n">FillRandom</span><span class="p">(</span><span class="s">&quot;gaus&quot;</span><span class="p">,</span><span class="mi">100</span><span class="p">);</span>
      <span class="n">h</span><span class="o">-&gt;</span><span class="n">Write</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">TObject</span><span class="o">::</span><span class="n">kReadWrite</span><span class="p">);</span>
      <span class="n">f</span><span class="o">-&gt;</span><span class="n">SaveSelf</span><span class="p">();</span>
      <span class="n">sleep</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
   <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// To refresh the information on the reader side, use ReadKeys:</span>

<span class="kt">void</span> <span class="nf">reading</span><span class="p">(</span><span class="k">const</span> <span class="n">TFile</span> <span class="o">*</span><span class="n">f</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="o">=</span><span class="s">&quot;gaus&quot;</span><span class="p">)</span> <span class="p">{</span>
   <span class="n">f</span><span class="o">-&gt;</span><span class="n">ReadKeys</span><span class="p">();</span>
   <span class="k">delete</span> <span class="n">f</span><span class="o">-&gt;</span><span class="n">FindObject</span><span class="p">(</span><span class="n">name</span><span class="p">);</span>
   <span class="n">TH1F</span> <span class="o">*</span><span class="n">h</span><span class="p">;</span>  <span class="n">f</span><span class="o">-&gt;</span><span class="n">GetObject</span><span class="p">(</span><span class="n">name</span><span class="p">,</span><span class="n">h</span><span class="p">);</span>
   <span class="n">h</span><span class="o">-&gt;</span><span class="n">Draw</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="example">
<h2>example<a class="headerlink" href="#example" title="永久链接至标题">¶</a></h2>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span>    <span class="c1">// A simple example with histograms and a tree</span>
    <span class="c1">//</span>
    <span class="c1">// This program creates :</span>
    <span class="c1">//    - a one dimensional histogram</span>
    <span class="c1">//    - a two dimensional histogram</span>
    <span class="c1">//    - a profile histogram</span>
    <span class="c1">//    - a tree</span>
    <span class="c1">//</span>
    <span class="c1">// These objects are filled with some random numbers and saved on a file.</span>

    <span class="cp">#include</span> <span class="cpf">&quot;TFile.h&quot;</span><span class="cp"></span>
    <span class="cp">#include</span> <span class="cpf">&quot;TH1.h&quot;</span><span class="cp"></span>
    <span class="cp">#include</span> <span class="cpf">&quot;TH2.h&quot;</span><span class="cp"></span>
    <span class="cp">#include</span> <span class="cpf">&quot;TProfile.h&quot;</span><span class="cp"></span>
    <span class="cp">#include</span> <span class="cpf">&quot;TRandom.h&quot;</span><span class="cp"></span>
    <span class="cp">#include</span> <span class="cpf">&quot;TTree.h&quot;</span><span class="cp"></span>

    <span class="c1">//__________________________________________________________________________</span>
    <span class="n">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">argv</span><span class="p">)</span>
    <span class="p">{</span>
    <span class="c1">// Create a new ROOT binary machine independent file.</span>
    <span class="c1">// Note that this file may contain any kind of ROOT objects, histograms,trees</span>
    <span class="c1">// pictures, graphics objects, detector geometries, tracks, events, etc..</span>
    <span class="c1">// This file is now becoming the current directory.</span>
    <span class="n">TFile</span> <span class="n">hfile</span><span class="p">(</span><span class="s">&quot;htree.root&quot;</span><span class="p">,</span><span class="s">&quot;RECREATE&quot;</span><span class="p">,</span><span class="s">&quot;Demo ROOT file with histograms &amp; trees&quot;</span><span class="p">);</span>

    <span class="c1">// Create some histograms and a profile histogram</span>
    <span class="n">TH1F</span> <span class="o">*</span><span class="n">hpx</span>   <span class="o">=</span> <span class="k">new</span> <span class="n">TH1F</span><span class="p">(</span><span class="s">&quot;hpx&quot;</span><span class="p">,</span><span class="s">&quot;This is the px distribution&quot;</span><span class="p">,</span><span class="mi">100</span><span class="p">,</span><span class="o">-</span><span class="mi">4</span><span class="p">,</span><span class="mi">4</span><span class="p">);</span>
    <span class="n">TH2F</span> <span class="o">*</span><span class="n">hpxpy</span> <span class="o">=</span> <span class="k">new</span> <span class="n">TH2F</span><span class="p">(</span><span class="s">&quot;hpxpy&quot;</span><span class="p">,</span><span class="s">&quot;py ps px&quot;</span><span class="p">,</span><span class="mi">40</span><span class="p">,</span><span class="o">-</span><span class="mi">4</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">40</span><span class="p">,</span><span class="o">-</span><span class="mi">4</span><span class="p">,</span><span class="mi">4</span><span class="p">);</span>
    <span class="n">TProfile</span> <span class="o">*</span><span class="n">hprof</span> <span class="o">=</span> <span class="k">new</span> <span class="n">TProfile</span><span class="p">(</span><span class="s">&quot;hprof&quot;</span><span class="p">,</span><span class="s">&quot;Profile of pz versus px&quot;</span><span class="p">,</span><span class="mi">100</span><span class="p">,</span><span class="o">-</span><span class="mi">4</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">20</span><span class="p">);</span>

    <span class="c1">// Define some simple structures</span>
    <span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span><span class="n">Float_t</span> <span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">;}</span> <span class="n">POINT</span><span class="p">;</span>
    <span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
       <span class="n">Int_t</span> <span class="n">ntrack</span><span class="p">,</span><span class="n">nseg</span><span class="p">,</span><span class="n">nvertex</span><span class="p">;</span>
       <span class="n">UInt_t</span> <span class="n">flag</span><span class="p">;</span>
       <span class="n">Float_t</span> <span class="n">temperature</span><span class="p">;</span>
    <span class="p">}</span> <span class="n">EVENTN</span><span class="p">;</span>
    <span class="k">static</span> <span class="n">POINT</span> <span class="n">point</span><span class="p">;</span>
    <span class="k">static</span> <span class="n">EVENTN</span> <span class="n">eventn</span><span class="p">;</span>

    <span class="c1">// Create a ROOT Tree</span>
    <span class="n">TTree</span> <span class="o">*</span><span class="n">tree</span> <span class="o">=</span> <span class="k">new</span> <span class="n">TTree</span><span class="p">(</span><span class="s">&quot;T&quot;</span><span class="p">,</span><span class="s">&quot;An example of ROOT tree with a few branches&quot;</span><span class="p">);</span>
    <span class="n">tree</span><span class="o">-&gt;</span><span class="n">Branch</span><span class="p">(</span><span class="s">&quot;point&quot;</span><span class="p">,</span><span class="o">&amp;</span><span class="n">point</span><span class="p">,</span><span class="s">&quot;x:y:z&quot;</span><span class="p">);</span>
    <span class="n">tree</span><span class="o">-&gt;</span><span class="n">Branch</span><span class="p">(</span><span class="s">&quot;eventn&quot;</span><span class="p">,</span><span class="o">&amp;</span><span class="n">eventn</span><span class="p">,</span><span class="s">&quot;ntrack/I:nseg:nvertex:flag/i:temperature/F&quot;</span><span class="p">);</span>
    <span class="n">tree</span><span class="o">-&gt;</span><span class="n">Branch</span><span class="p">(</span><span class="s">&quot;hpx&quot;</span><span class="p">,</span><span class="s">&quot;TH1F&quot;</span><span class="p">,</span><span class="o">&amp;</span><span class="n">hpx</span><span class="p">,</span><span class="mi">128000</span><span class="p">,</span><span class="mi">0</span><span class="p">);</span>

    <span class="n">Float_t</span> <span class="n">px</span><span class="p">,</span><span class="n">py</span><span class="p">,</span><span class="n">pz</span><span class="p">;</span>
    <span class="k">static</span> <span class="n">Float_t</span> <span class="n">p</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>

    <span class="c1">// Here we start a loop on 1000 events</span>
    <span class="k">for</span> <span class="p">(</span> <span class="n">Int_t</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="mi">1000</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
       <span class="n">gRandom</span><span class="o">-&gt;</span><span class="n">Rannor</span><span class="p">(</span><span class="n">px</span><span class="p">,</span><span class="n">py</span><span class="p">);</span>
       <span class="n">pz</span> <span class="o">=</span> <span class="n">px</span><span class="o">*</span><span class="n">px</span> <span class="o">+</span> <span class="n">py</span><span class="o">*</span><span class="n">py</span><span class="p">;</span>
       <span class="n">Float_t</span> <span class="n">random</span> <span class="o">=</span> <span class="n">gRandom</span><span class="o">-&gt;::</span><span class="n">Rndm</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>

       <span class="c1">// Fill histograms</span>
       <span class="n">hpx</span><span class="o">-&gt;</span><span class="n">Fill</span><span class="p">(</span><span class="n">px</span><span class="p">);</span>
       <span class="n">hpxpy</span><span class="o">-&gt;</span><span class="n">Fill</span><span class="p">(</span><span class="n">px</span><span class="p">,</span><span class="n">py</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span>
       <span class="n">hprof</span><span class="o">-&gt;</span><span class="n">Fill</span><span class="p">(</span><span class="n">px</span><span class="p">,</span><span class="n">pz</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span>

       <span class="c1">// Fill structures</span>
       <span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">px</span><span class="p">;</span>
       <span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">py</span><span class="p">;</span>
       <span class="n">p</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">pz</span><span class="p">;</span>
       <span class="n">point</span><span class="p">.</span><span class="n">x</span> <span class="o">=</span> <span class="mi">10</span><span class="o">*</span><span class="p">(</span><span class="n">random</span><span class="o">-</span><span class="mi">1</span><span class="p">);;</span>
       <span class="n">point</span><span class="p">.</span><span class="n">y</span> <span class="o">=</span> <span class="mi">5</span><span class="o">*</span><span class="n">random</span><span class="p">;</span>
       <span class="n">point</span><span class="p">.</span><span class="n">z</span> <span class="o">=</span> <span class="mi">20</span><span class="o">*</span><span class="n">random</span><span class="p">;</span>
       <span class="n">eventn</span><span class="p">.</span><span class="n">ntrack</span>  <span class="o">=</span> <span class="n">Int_t</span><span class="p">(</span><span class="mi">100</span><span class="o">*</span><span class="n">random</span><span class="p">);</span>
       <span class="n">eventn</span><span class="p">.</span><span class="n">nseg</span>    <span class="o">=</span> <span class="n">Int_t</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">eventn</span><span class="p">.</span><span class="n">ntrack</span><span class="p">);</span>
       <span class="n">eventn</span><span class="p">.</span><span class="n">nvertex</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
       <span class="n">eventn</span><span class="p">.</span><span class="n">flag</span>    <span class="o">=</span> <span class="n">Int_t</span><span class="p">(</span><span class="n">random</span><span class="o">+</span><span class="mf">0.5</span><span class="p">);</span>
       <span class="n">eventn</span><span class="p">.</span><span class="n">temperature</span> <span class="o">=</span> <span class="mi">20</span><span class="o">+</span><span class="n">random</span><span class="p">;</span>

       <span class="c1">// Fill the tree. For each event, save the 2 structures and 3 objects</span>
       <span class="c1">// In this simple example, the objects hpx, hprof and hpxpy are slightly</span>
       <span class="c1">// different from event to event. We expect a big compression factor!</span>
       <span class="n">tree</span><span class="o">-&gt;</span><span class="n">Fill</span><span class="p">();</span>
    <span class="p">}</span>
    <span class="c1">// End of the loop</span>

    <span class="n">tree</span><span class="o">-&gt;</span><span class="n">Print</span><span class="p">();</span>

    <span class="c1">// Save all objects in this file</span>
    <span class="n">hfile</span><span class="p">.</span><span class="n">Write</span><span class="p">();</span>

    <span class="c1">// Close the file. Note that this is automatically done when you leave</span>
    <span class="c1">// the application.</span>
    <span class="n">hfile</span><span class="p">.</span><span class="n">Close</span><span class="p">();</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<!-- TTree.md ends here --></div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="TCut.html" class="btn btn-neutral float-right" title="TCut" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="TXMLFile.html" class="btn btn-neutral float-left" title="TXMLFile" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2020, Hongyi Wu(吴鸿毅)

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>