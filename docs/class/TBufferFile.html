

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="zh-CN" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="zh-CN" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>TBufferFile &mdash; ROOT Note 1 文档</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script type="text/javascript" src="../_static/jquery.js"></script>
        <script type="text/javascript" src="../_static/underscore.js"></script>
        <script type="text/javascript" src="../_static/doctools.js"></script>
        <script type="text/javascript" src="../_static/language_data.js"></script>
        <script type="text/javascript" src="../_static/translations.js"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/graphviz.css" type="text/css" />
    <link rel="index" title="索引" href="../genindex.html" />
    <link rel="search" title="搜索" href="../search.html" />
    <link rel="next" title="TBufferJSON" href="TBufferJSON.html" />
    <link rel="prev" title="TBuffer" href="TBuffer.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html" class="icon icon-home"> ROOT Note
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">简介</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../README.html">简介</a></li>
</ul>
<p class="caption"><span class="caption-text">base类的使用</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="README.html">类的使用</a></li>
<li class="toctree-l1"><a class="reference internal" href="TObject.html">TObject</a></li>
<li class="toctree-l1"><a class="reference internal" href="TTask.html">TTask</a></li>
<li class="toctree-l1"><a class="reference internal" href="Buttons.html">Buttons</a></li>
<li class="toctree-l1"><a class="reference internal" href="TNamed.html">TNamed</a></li>
<li class="toctree-l1"><a class="reference internal" href="TStyle.html">TStyle</a></li>
<li class="toctree-l1"><a class="reference internal" href="TSystem.html">TSystem</a></li>
<li class="toctree-l1"><a class="reference internal" href="TROOT.html">TROOT</a></li>
<li class="toctree-l1"><a class="reference internal" href="TFolder.html">TFolder</a></li>
<li class="toctree-l1"><a class="reference internal" href="TEnv.html">TEnv</a></li>
<li class="toctree-l1"><a class="reference internal" href="TMacro.html">TMacro</a></li>
<li class="toctree-l1"><a class="reference internal" href="TApplication.html">TApplication</a></li>
<li class="toctree-l1"><a class="reference internal" href="TProcessID.html">TProcessID</a></li>
<li class="toctree-l1"><a class="reference internal" href="TProcessUUID.html">TProcessUUID</a></li>
<li class="toctree-l1"><a class="reference internal" href="TString.html">TString</a></li>
<li class="toctree-l1"><a class="reference internal" href="TColor.html">TColor</a></li>
<li class="toctree-l1"><a class="reference internal" href="TBase64.html">TBase64</a></li>
<li class="toctree-l1"><a class="reference internal" href="TMD5.html">TMD5</a></li>
</ul>
<p class="caption"><span class="caption-text">IO类的使用</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="README.html">类的使用</a></li>
<li class="toctree-l1"><a class="reference internal" href="TKey.html">TKey</a></li>
<li class="toctree-l1"><a class="reference internal" href="TDirectory.html">TDirectory</a></li>
<li class="toctree-l1"><a class="reference internal" href="TDirectoryFile.html">TDirectoryFile</a></li>
<li class="toctree-l1"><a class="reference internal" href="TSystemFile.html">TSystemFile</a></li>
<li class="toctree-l1"><a class="reference internal" href="TSystemDirectory.html">TSystemDirectory</a></li>
<li class="toctree-l1"><a class="reference internal" href="TFile.html">TFile</a></li>
<li class="toctree-l1"><a class="reference internal" href="TFileCacheWrite.html">TFileCacheWrite</a></li>
<li class="toctree-l1"><a class="reference internal" href="TFileCacheRead.html">TFileCacheRead</a></li>
<li class="toctree-l1"><a class="reference internal" href="TFileMerger.html">TFileMerger</a></li>
<li class="toctree-l1"><a class="reference internal" href="TMemFile.html">TMemFile</a></li>
<li class="toctree-l1"><a class="reference internal" href="TKeyMapFile.html">TKeyMapFile</a></li>
<li class="toctree-l1"><a class="reference internal" href="TMapFile.html">TMapFile</a></li>
<li class="toctree-l1"><a class="reference internal" href="TArchiveFile.html">TArchiveFile</a></li>
<li class="toctree-l1"><a class="reference internal" href="TZIPFile.html">TZIPFile</a></li>
<li class="toctree-l1"><a class="reference internal" href="TFilePrefetch.html">TFilePrefetch</a></li>
<li class="toctree-l1"><a class="reference internal" href="TFPBlock.html">TFPBlock</a></li>
<li class="toctree-l1"><a class="reference internal" href="THDFSFile.html">THDFSFile</a></li>
<li class="toctree-l1"><a class="reference internal" href="TBuffer.html">TBuffer</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">TBufferFile</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#class">class</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="TBufferJSON.html">TBufferJSON</a></li>
<li class="toctree-l1"><a class="reference internal" href="TKeySQL.html">TKeySQL</a></li>
<li class="toctree-l1"><a class="reference internal" href="TSQLObjectData.html">TSQLObjectData</a></li>
<li class="toctree-l1"><a class="reference internal" href="TSQLStructure.html">TSQLStructure</a></li>
<li class="toctree-l1"><a class="reference internal" href="TSQLClassInfo.html">TSQLClassInfo</a></li>
<li class="toctree-l1"><a class="reference internal" href="TBufferSQL2.html">TBufferSQL2</a></li>
<li class="toctree-l1"><a class="reference internal" href="TSQLFile.html">TSQLFile</a></li>
<li class="toctree-l1"><a class="reference internal" href="TXMLEngine.html">TXMLEngine</a></li>
<li class="toctree-l1"><a class="reference internal" href="TBufferXML.html">TBufferXML</a></li>
<li class="toctree-l1"><a class="reference internal" href="TXMLSetup.html">TXMLSetup</a></li>
<li class="toctree-l1"><a class="reference internal" href="TKeyXML.html">TKeyXML</a></li>
<li class="toctree-l1"><a class="reference internal" href="TXMLPlayer.html">TXMLPlayer</a></li>
<li class="toctree-l1"><a class="reference internal" href="TXMLFile.html">TXMLFile</a></li>
</ul>
<p class="caption"><span class="caption-text">常用类的使用</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="README.html">类的使用</a></li>
<li class="toctree-l1"><a class="reference internal" href="TTree.html">TTree</a></li>
<li class="toctree-l1"><a class="reference internal" href="TCut.html">TCut</a></li>
<li class="toctree-l1"><a class="reference internal" href="TTreePlayer.html">TTreePlayer</a></li>
<li class="toctree-l1"><a class="reference internal" href="TChain.html">TChain</a></li>
<li class="toctree-l1"><a class="reference internal" href="TEventList.html">TEventList</a></li>
<li class="toctree-l1"><a class="reference internal" href="TBranch.html">TBranch</a></li>
<li class="toctree-l1"><a class="reference internal" href="TNtuple.html">TNtuple</a></li>
<li class="toctree-l1"><a class="reference internal" href="TNtupleD.html">TNtupleD</a></li>
<li class="toctree-l1"><a class="reference internal" href="TNtupleD.html#example">example</a></li>
<li class="toctree-l1"><a class="reference internal" href="TCollection.html">TCollection</a></li>
<li class="toctree-l1"><a class="reference internal" href="TSeqCollection.html">TSeqCollection</a></li>
<li class="toctree-l1"><a class="reference internal" href="TList.html">TList</a></li>
<li class="toctree-l1"><a class="reference internal" href="TVirtualFitter.html">TVirtualFitter</a></li>
<li class="toctree-l1"><a class="reference internal" href="TBackCompFitter.html">TBackCompFitter</a></li>
<li class="toctree-l1"><a class="reference internal" href="FitResult.html">FitResult</a></li>
<li class="toctree-l1"><a class="reference internal" href="TFitter.html">TFitter</a></li>
<li class="toctree-l1"><a class="reference internal" href="TFitResult.html">TFitResult</a></li>
<li class="toctree-l1"><a class="reference internal" href="TFitResultPtr.html">TFitResultPtr</a></li>
<li class="toctree-l1"><a class="reference internal" href="TFractionFitter.html">TFractionFitter</a></li>
<li class="toctree-l1"><a class="reference internal" href="TLinearFitter.html">TLinearFitter</a></li>
<li class="toctree-l1"><a class="reference internal" href="TAttAxis.html">TAttAxis</a></li>
<li class="toctree-l1"><a class="reference internal" href="TAxis.html">TAxis</a></li>
<li class="toctree-l1"><a class="reference internal" href="TGaxis.html">TGaxis</a></li>
<li class="toctree-l1"><a class="reference internal" href="TGaxis.html#example">example</a></li>
<li class="toctree-l1"><a class="reference internal" href="TText.html">TText</a></li>
<li class="toctree-l1"><a class="reference internal" href="TPaveStats.html">TPaveStats</a></li>
<li class="toctree-l1"><a class="reference internal" href="TPolyMarker.html">TPolyMarker</a></li>
<li class="toctree-l1"><a class="reference internal" href="TPaveText.html">TPaveText</a></li>
<li class="toctree-l1"><a class="reference internal" href="TPolyMarker3D.html">TPolyMarker3D</a></li>
<li class="toctree-l1"><a class="reference internal" href="TLatex.html">TLatex</a></li>
<li class="toctree-l1"><a class="reference internal" href="TLegend.html">TLegend</a></li>
<li class="toctree-l1"><a class="reference internal" href="TLegendEntry.html">TLegendEntry</a></li>
<li class="toctree-l1"><a class="reference internal" href="TLine.html">TLine</a></li>
<li class="toctree-l1"><a class="reference internal" href="TVirtualPad.html">TVirtualPad</a></li>
<li class="toctree-l1"><a class="reference internal" href="TPad.html">TPad</a></li>
<li class="toctree-l1"><a class="reference internal" href="TCanvas.html">TCanvas</a></li>
<li class="toctree-l1"><a class="reference internal" href="TF1.html">TF1</a></li>
<li class="toctree-l1"><a class="reference internal" href="TF2.html">TF2</a></li>
<li class="toctree-l1"><a class="reference internal" href="TF3.html">TF3</a></li>
<li class="toctree-l1"><a class="reference internal" href="TGraph.html">TGraph</a></li>
<li class="toctree-l1"><a class="reference internal" href="TCutG.html">TCutG</a></li>
<li class="toctree-l1"><a class="reference internal" href="TMultiGraph.html">TMultiGraph</a></li>
<li class="toctree-l1"><a class="reference internal" href="TGraph2D.html">TGraph2D</a></li>
<li class="toctree-l1"><a class="reference internal" href="TGraph2DErrors.html">TGraph2DErrors</a></li>
<li class="toctree-l1"><a class="reference internal" href="TGraphErrors.html">TGraphErrors</a></li>
<li class="toctree-l1"><a class="reference internal" href="TGraphPolar.html">TGraphPolar</a></li>
<li class="toctree-l1"><a class="reference internal" href="TH1.html">TH1</a></li>
<li class="toctree-l1"><a class="reference internal" href="TH2.html">TH2</a></li>
<li class="toctree-l1"><a class="reference internal" href="TH2Poly.html">TH2Poly</a></li>
<li class="toctree-l1"><a class="reference internal" href="TH3.html">TH3</a></li>
<li class="toctree-l1"><a class="reference internal" href="TProfile.html">TProfile</a></li>
<li class="toctree-l1"><a class="reference internal" href="TProfile2D.html">TProfile2D</a></li>
<li class="toctree-l1"><a class="reference internal" href="TProfile3D.html">TProfile3D</a></li>
<li class="toctree-l1"><a class="reference internal" href="TMath.html">TMath</a></li>
<li class="toctree-l1"><a class="reference internal" href="TMathBase.html">TMathBase</a></li>
<li class="toctree-l1"><a class="reference internal" href="TMatrixT.html">TMatrixT</a></li>
<li class="toctree-l1"><a class="reference internal" href="TMatrixTBase.html">TMatrixTBase</a></li>
<li class="toctree-l1"><a class="reference internal" href="TMatrixTSparse.html">TMatrixTSparse</a></li>
<li class="toctree-l1"><a class="reference internal" href="TMatrixTSym.html">TMatrixTSym</a></li>
<li class="toctree-l1"><a class="reference internal" href="TSpline.html">TSpline</a></li>
<li class="toctree-l1"><a class="reference internal" href="TMinuit.html">TMinuit</a></li>
<li class="toctree-l1"><a class="reference internal" href="TMinuitMinimizer.html">TMinuitMinimizer</a></li>
<li class="toctree-l1"><a class="reference internal" href="TRandom.html">TRandom</a></li>
<li class="toctree-l1"><a class="reference internal" href="TRandom1.html">TRandom1</a></li>
<li class="toctree-l1"><a class="reference internal" href="TRandom2.html">TRandom2</a></li>
<li class="toctree-l1"><a class="reference internal" href="TRandom3.html">TRandom3</a></li>
<li class="toctree-l1"><a class="reference internal" href="TSelector.html">TSelector</a></li>
<li class="toctree-l1"><a class="reference internal" href="TSelectorCint.html">TSelectorCint</a></li>
<li class="toctree-l1"><a class="reference internal" href="TSelectorDraw.html">TSelectorDraw</a></li>
<li class="toctree-l1"><a class="reference internal" href="TSelectorEntries.html">TSelectorEntries</a></li>
<li class="toctree-l1"><a class="reference internal" href="TSelectorList.html">TSelectorList</a></li>
<li class="toctree-l1"><a class="reference internal" href="TSelectorScalar.html">TSelectorScalar</a></li>
<li class="toctree-l1"><a class="reference internal" href="TSpectrum.html">TSpectrum</a></li>
<li class="toctree-l1"><a class="reference internal" href="TSpectrum2.html">TSpectrum2</a></li>
<li class="toctree-l1"><a class="reference internal" href="TSpectrum2Fit.html">TSpectrum2Fit</a></li>
<li class="toctree-l1"><a class="reference internal" href="TSpectrum2Painter.html">TSpectrum2Painter</a></li>
<li class="toctree-l1"><a class="reference internal" href="TSpectrum2Transform.html">TSpectrum2Transform</a></li>
<li class="toctree-l1"><a class="reference internal" href="TSpectrum3.html">TSpectrum3</a></li>
<li class="toctree-l1"><a class="reference internal" href="TSpectrumFit.html">TSpectrumFit</a></li>
<li class="toctree-l1"><a class="reference internal" href="TSpectrumTransform.html">TSpectrumTransform</a></li>
<li class="toctree-l1"><a class="reference internal" href="TTime.html">TTime</a></li>
<li class="toctree-l1"><a class="reference internal" href="TTimer.html">TTimer</a></li>
<li class="toctree-l1"><a class="reference internal" href="TTimeStamp.html">TTimeStamp</a></li>
<li class="toctree-l1"><a class="reference internal" href="TStopwatch.html">TStopwatch</a></li>
<li class="toctree-l1"><a class="reference internal" href="TBenchmark.html">TBenchmark</a></li>
<li class="toctree-l1"><a class="reference internal" href="TThread.html">TThread</a></li>
<li class="toctree-l1"><a class="reference internal" href="TThreadFactory.html">TThreadFactory</a></li>
<li class="toctree-l1"><a class="reference internal" href="TThreadImp.html">TThreadImp</a></li>
<li class="toctree-l1"><a class="reference internal" href="TServerSocket.html">TServerSocket</a></li>
<li class="toctree-l1"><a class="reference internal" href="TSocket.html">TSocket</a></li>
<li class="toctree-l1"><a class="reference internal" href="TPServerSocket.html">TPServerSocket</a></li>
<li class="toctree-l1"><a class="reference internal" href="TPSocket.html">TPSocket</a></li>
<li class="toctree-l1"><a class="reference internal" href="TEllipse.html">TEllipse</a></li>
<li class="toctree-l1"><a class="reference internal" href="TNeuron.html">TNeuron</a></li>
<li class="toctree-l1"><a class="reference internal" href="TMLPAnalyzer.html">TMLPAnalyzer</a></li>
<li class="toctree-l1"><a class="reference internal" href="TMonitor.html">TMonitor</a></li>
<li class="toctree-l1"><a class="reference internal" href="TMultiLayerPerceptron.html">TMultiLayerPerceptron</a></li>
</ul>
<p class="caption"><span class="caption-text">图形界面的使用</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="gui/README.html">README</a></li>
<li class="toctree-l1"><a class="reference internal" href="gui/GuiTypes.html">GuiTypes</a></li>
<li class="toctree-l1"><a class="reference internal" href="gui/TGButton.html">TGButton</a></li>
<li class="toctree-l1"><a class="reference internal" href="gui/TGButtonGroup.html">TGButtonGroup</a></li>
<li class="toctree-l1"><a class="reference internal" href="gui/TGCanvas.html">TGCanvas</a></li>
<li class="toctree-l1"><a class="reference internal" href="gui/TGClient.html">TGClient</a></li>
<li class="toctree-l1"><a class="reference internal" href="gui/TGColorDialog.html">TGColorDialog</a></li>
<li class="toctree-l1"><a class="reference internal" href="gui/TGColorSelect.html">TGColorSelect</a></li>
<li class="toctree-l1"><a class="reference internal" href="gui/TGComboBox.html">TGComboBox</a></li>
<li class="toctree-l1"><a class="reference internal" href="gui/TGCommandPlugin.html">TGCommandPlugin</a></li>
<li class="toctree-l1"><a class="reference internal" href="gui/TGDimension.html">TGDimension</a></li>
<li class="toctree-l1"><a class="reference internal" href="gui/TGDNDManager.html">TGDNDManager</a></li>
<li class="toctree-l1"><a class="reference internal" href="gui/TGDockableFrame.html">TGDockableFrame</a></li>
<li class="toctree-l1"><a class="reference internal" href="gui/TGDoubleSlider.html">TGDoubleSlider</a></li>
<li class="toctree-l1"><a class="reference internal" href="gui/TGEventHandler.html">TGEventHandler</a></li>
<li class="toctree-l1"><a class="reference internal" href="gui/TGFileBrowser.html">TGFileBrowser</a></li>
<li class="toctree-l1"><a class="reference internal" href="gui/TGFileDialog.html">TGFileDialog</a></li>
<li class="toctree-l1"><a class="reference internal" href="gui/TGFont.html">TGFont</a></li>
<li class="toctree-l1"><a class="reference internal" href="gui/TGFontDialog.html">TGFontDialog</a></li>
<li class="toctree-l1"><a class="reference internal" href="gui/TGFrame.html">TGFrame</a></li>
<li class="toctree-l1"><a class="reference internal" href="gui/TGFSComboBox.html">TGFSComboBox</a></li>
<li class="toctree-l1"><a class="reference internal" href="gui/TGFSContainer.html">TGFSContainer</a></li>
<li class="toctree-l1"><a class="reference internal" href="gui/TGGC.html">TGGC</a></li>
<li class="toctree-l1"><a class="reference internal" href="gui/TGIcon.html">TGIcon</a></li>
<li class="toctree-l1"><a class="reference internal" href="gui/TGIdleHandler.html">TGIdleHandler</a></li>
<li class="toctree-l1"><a class="reference internal" href="gui/TGImageMap.html">TGImageMap</a></li>
<li class="toctree-l1"><a class="reference internal" href="gui/TGInputDialog.html">TGInputDialog</a></li>
<li class="toctree-l1"><a class="reference internal" href="gui/TGLabel.html">TGLabel</a></li>
<li class="toctree-l1"><a class="reference internal" href="gui/TGLayout.html">TGLayout</a></li>
<li class="toctree-l1"><a class="reference internal" href="gui/TGListBox.html">TGListBox</a></li>
<li class="toctree-l1"><a class="reference internal" href="gui/TGListTree.html">TGListTree</a></li>
<li class="toctree-l1"><a class="reference internal" href="gui/TGListView.html">TGListView</a></li>
<li class="toctree-l1"><a class="reference internal" href="gui/TGMdiDecorFrame.html">TGMdiDecorFrame</a></li>
<li class="toctree-l1"><a class="reference internal" href="gui/TGMdiFrame.html">TGMdiFrame</a></li>
<li class="toctree-l1"><a class="reference internal" href="gui/TGMdiMainFrame.html">TGMdiMainFrame</a></li>
<li class="toctree-l1"><a class="reference internal" href="gui/TGMdiMenu.html">TGMdiMenu</a></li>
<li class="toctree-l1"><a class="reference internal" href="gui/TGMenu.html">TGMenu</a></li>
<li class="toctree-l1"><a class="reference internal" href="gui/TGMimeTypes.html">TGMimeTypes</a></li>
<li class="toctree-l1"><a class="reference internal" href="gui/TGMsgBox.html">TGMsgBox</a></li>
<li class="toctree-l1"><a class="reference internal" href="gui/TGNumberEntry.html">TGNumberEntry</a></li>
<li class="toctree-l1"><a class="reference internal" href="gui/TGObject.html">TGObject</a></li>
<li class="toctree-l1"><a class="reference internal" href="gui/TGPack.html">TGPack</a></li>
<li class="toctree-l1"><a class="reference internal" href="gui/TGPasswdDialog.html">TGPasswdDialog</a></li>
<li class="toctree-l1"><a class="reference internal" href="gui/TGPicture.html">TGPicture</a></li>
<li class="toctree-l1"><a class="reference internal" href="gui/TGProgressBar.html">TGProgressBar</a></li>
<li class="toctree-l1"><a class="reference internal" href="gui/TGRedirectOutputGuard.html">TGRedirectOutputGuard</a></li>
<li class="toctree-l1"><a class="reference internal" href="gui/TGResourcePool.html">TGResourcePool</a></li>
<li class="toctree-l1"><a class="reference internal" href="gui/TGScrollBar.html">TGScrollBar</a></li>
<li class="toctree-l1"><a class="reference internal" href="gui/TGShapedFrame.html">TGShapedFrame</a></li>
<li class="toctree-l1"><a class="reference internal" href="gui/TGShutter.html">TGShutter</a></li>
<li class="toctree-l1"><a class="reference internal" href="gui/TGSimpleTable.html">TGSimpleTable</a></li>
<li class="toctree-l1"><a class="reference internal" href="gui/TGSimpleTableInterface.html">TGSimpleTableInterface</a></li>
<li class="toctree-l1"><a class="reference internal" href="gui/TGSlider.html">TGSlider</a></li>
<li class="toctree-l1"><a class="reference internal" href="gui/TGSpeedo.html">TGSpeedo</a></li>
<li class="toctree-l1"><a class="reference internal" href="gui/TGSplitFrame.html">TGSplitFrame</a></li>
<li class="toctree-l1"><a class="reference internal" href="gui/TGSplitter.html">TGSplitter</a></li>
<li class="toctree-l1"><a class="reference internal" href="gui/TGStatusBar.html">TGStatusBar</a></li>
<li class="toctree-l1"><a class="reference internal" href="gui/TGString.html">TGString</a></li>
<li class="toctree-l1"><a class="reference internal" href="gui/TGTab.html">TGTab</a></li>
<li class="toctree-l1"><a class="reference internal" href="gui/TGTable.html">TGTable</a></li>
<li class="toctree-l1"><a class="reference internal" href="gui/TGTableCell.html">TGTableCell</a></li>
<li class="toctree-l1"><a class="reference internal" href="gui/TGTableContainer.html">TGTableContainer</a></li>
<li class="toctree-l1"><a class="reference internal" href="gui/TGTableHeader.html">TGTableHeader</a></li>
<li class="toctree-l1"><a class="reference internal" href="gui/TGTableLayout.html">TGTableLayout</a></li>
<li class="toctree-l1"><a class="reference internal" href="gui/TGText.html">TGText</a></li>
<li class="toctree-l1"><a class="reference internal" href="gui/TGTextBuffer.html">TGTextBuffer</a></li>
<li class="toctree-l1"><a class="reference internal" href="gui/TGTextEdit.html">TGTextEdit</a></li>
<li class="toctree-l1"><a class="reference internal" href="gui/TGTextEditDialogs.html">TGTextEditDialogs</a></li>
<li class="toctree-l1"><a class="reference internal" href="gui/TGTextEditor.html">TGTextEditor</a></li>
<li class="toctree-l1"><a class="reference internal" href="gui/TGTextEntry.html">TGTextEntry</a></li>
<li class="toctree-l1"><a class="reference internal" href="gui/TGTextView.html">TGTextView</a></li>
<li class="toctree-l1"><a class="reference internal" href="gui/TGTextViewStream.html">TGTextViewStream</a></li>
<li class="toctree-l1"><a class="reference internal" href="gui/TGToolBar.html">TGToolBar</a></li>
<li class="toctree-l1"><a class="reference internal" href="gui/TGToolTip.html">TGToolTip</a></li>
<li class="toctree-l1"><a class="reference internal" href="gui/TGTripleSlider.html">TGTripleSlider</a></li>
<li class="toctree-l1"><a class="reference internal" href="gui/TGuiBuilder.html">TGuiBuilder</a></li>
<li class="toctree-l1"><a class="reference internal" href="gui/TGView.html">TGView</a></li>
<li class="toctree-l1"><a class="reference internal" href="gui/TGWidget.html">TGWidget</a></li>
<li class="toctree-l1"><a class="reference internal" href="gui/TGWindow.html">TGWindow</a></li>
<li class="toctree-l1"><a class="reference internal" href="gui/TGXYLayout.html">TGXYLayout</a></li>
<li class="toctree-l1"><a class="reference internal" href="gui/TQObject.html">TQObject</a></li>
<li class="toctree-l1"><a class="reference internal" href="gui/TRootEmbeddedCanvas.html">TRootEmbeddedCanvas</a></li>
</ul>
<p class="caption"><span class="caption-text">GRAF3D</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="graf3d/README.html">README</a></li>
<li class="toctree-l1"><a class="reference internal" href="graf3d/TAxis3D.html">TAxis3D</a></li>
<li class="toctree-l1"><a class="reference internal" href="graf3d/TBRIK.html">TBRIK</a></li>
<li class="toctree-l1"><a class="reference internal" href="graf3d/TCONE.html">TCONE</a></li>
<li class="toctree-l1"><a class="reference internal" href="graf3d/TCONS.html">TCONS</a></li>
<li class="toctree-l1"><a class="reference internal" href="graf3d/TCTUB.html">TCTUB</a></li>
<li class="toctree-l1"><a class="reference internal" href="graf3d/TELTU.html">TELTU</a></li>
<li class="toctree-l1"><a class="reference internal" href="graf3d/TGeometry.html">TGeometry</a></li>
<li class="toctree-l1"><a class="reference internal" href="graf3d/TGTRA.html">TGTRA</a></li>
<li class="toctree-l1"><a class="reference internal" href="graf3d/THelix.html">THelix</a></li>
<li class="toctree-l1"><a class="reference internal" href="graf3d/THYPE.html">THYPE</a></li>
<li class="toctree-l1"><a class="reference internal" href="graf3d/TMarker3DBox.html">TMarker3DBox</a></li>
<li class="toctree-l1"><a class="reference internal" href="graf3d/TMaterial.html">TMaterial</a></li>
<li class="toctree-l1"><a class="reference internal" href="graf3d/TMixture.html">TMixture</a></li>
<li class="toctree-l1"><a class="reference internal" href="graf3d/TNodeDiv.html">TNodeDiv</a></li>
<li class="toctree-l1"><a class="reference internal" href="graf3d/TNode.html">TNode</a></li>
<li class="toctree-l1"><a class="reference internal" href="graf3d/TPARA.html">TPARA</a></li>
<li class="toctree-l1"><a class="reference internal" href="graf3d/TPCON.html">TPCON</a></li>
<li class="toctree-l1"><a class="reference internal" href="graf3d/TPGON.html">TPGON</a></li>
<li class="toctree-l1"><a class="reference internal" href="graf3d/TPoints3DABC.html">TPoints3DABC</a></li>
<li class="toctree-l1"><a class="reference internal" href="graf3d/TPointSet3D.html">TPointSet3D</a></li>
<li class="toctree-l1"><a class="reference internal" href="graf3d/TPolyLine3D.html">TPolyLine3D</a></li>
<li class="toctree-l1"><a class="reference internal" href="graf3d/TPolyMarker3D.html">TPolyMarker3D</a></li>
<li class="toctree-l1"><a class="reference internal" href="graf3d/TRotMatrix.html">TRotMatrix</a></li>
<li class="toctree-l1"><a class="reference internal" href="graf3d/TShape.html">TShape</a></li>
<li class="toctree-l1"><a class="reference internal" href="graf3d/TSPHE.html">TSPHE</a></li>
<li class="toctree-l1"><a class="reference internal" href="graf3d/TTRAP.html">TTRAP</a></li>
<li class="toctree-l1"><a class="reference internal" href="graf3d/TTRD1.html">TTRD1</a></li>
<li class="toctree-l1"><a class="reference internal" href="graf3d/TTRD2.html">TTRD2</a></li>
<li class="toctree-l1"><a class="reference internal" href="graf3d/TTUBE.html">TTUBE</a></li>
<li class="toctree-l1"><a class="reference internal" href="graf3d/TTUBS.html">TTUBS</a></li>
<li class="toctree-l1"><a class="reference internal" href="graf3d/TView3D.html">TView3D</a></li>
<li class="toctree-l1"><a class="reference internal" href="graf3d/TXTRU.html">TXTRU</a></li>
<li class="toctree-l1"><a class="reference internal" href="graf3d/X3DBuffer.html">X3DBuffer</a></li>
</ul>
<p class="caption"><span class="caption-text">physics</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="math/README.html">README</a></li>
<li class="toctree-l1"><a class="reference internal" href="math/TFeldmanCousins.html">TFeldmanCousins</a></li>
<li class="toctree-l1"><a class="reference internal" href="math/TGenPhaseSpace.html">TGenPhaseSpace</a></li>
<li class="toctree-l1"><a class="reference internal" href="math/TLorentzRotation.html">TLorentzRotation</a></li>
<li class="toctree-l1"><a class="reference internal" href="math/TLorentzVector.html">TLorentzVector</a></li>
<li class="toctree-l1"><a class="reference internal" href="math/TQuaternion.html">TQuaternion</a></li>
<li class="toctree-l1"><a class="reference internal" href="math/TRobustEstimator.html">TRobustEstimator</a></li>
<li class="toctree-l1"><a class="reference internal" href="math/TRolke.html">TRolke</a></li>
<li class="toctree-l1"><a class="reference internal" href="math/TRotation.html">TRotation</a></li>
<li class="toctree-l1"><a class="reference internal" href="math/TVectorT.html">TVectorT</a></li>
<li class="toctree-l1"><a class="reference internal" href="math/TVector2.html">TVector2</a></li>
<li class="toctree-l1"><a class="reference internal" href="math/TVector3.html">TVector3</a></li>
</ul>
<p class="caption"><span class="caption-text">net</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="net/README.html">README</a></li>
<li class="toctree-l1"><a class="reference internal" href="net/TCivetweb.html">TCivetweb</a></li>
<li class="toctree-l1"><a class="reference internal" href="net/TFastCgi.html">TFastCgi</a></li>
<li class="toctree-l1"><a class="reference internal" href="net/THttpCallArg.html">THttpCallArg</a></li>
<li class="toctree-l1"><a class="reference internal" href="net/THttpEngine.html">THttpEngine</a></li>
<li class="toctree-l1"><a class="reference internal" href="net/THttpServer.html">THttpServer</a></li>
<li class="toctree-l1"><a class="reference internal" href="net/THttpWSEngine.html">THttpWSEngine</a></li>
<li class="toctree-l1"><a class="reference internal" href="net/THttpWSHandler.html">THttpWSHandler</a></li>
<li class="toctree-l1"><a class="reference internal" href="net/TRootSniffer.html">TRootSniffer</a></li>
<li class="toctree-l1"><a class="reference internal" href="net/TRootSnifferStore.html">TRootSnifferStore</a></li>
</ul>
<p class="caption"><span class="caption-text">数据结构</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../structure/README.html">数据结构</a></li>
<li class="toctree-l1"><a class="reference internal" href="../structure/datarecord.html">datarecord</a></li>
<li class="toctree-l1"><a class="reference internal" href="../structure/dobject.html">dataobject</a></li>
<li class="toctree-l1"><a class="reference internal" href="../structure/freesegments.html">FreeSegments</a></li>
<li class="toctree-l1"><a class="reference internal" href="../structure/gap.html">gap</a></li>
<li class="toctree-l1"><a class="reference internal" href="../structure/header.html">header</a></li>
<li class="toctree-l1"><a class="reference internal" href="../structure/keyslist.html">KeysList</a></li>
<li class="toctree-l1"><a class="reference internal" href="../structure/StreamerInfo.html">StreamerInfo</a></li>
<li class="toctree-l1"><a class="reference internal" href="../structure/TClonesArray.html">TClonesArray</a></li>
<li class="toctree-l1"><a class="reference internal" href="../structure/TDirectory.html">TDirectory</a></li>
<li class="toctree-l1"><a class="reference internal" href="../structure/TFile.html">TFile</a></li>
<li class="toctree-l1"><a class="reference internal" href="../structure/TObject.html">TObject</a></li>
<li class="toctree-l1"><a class="reference internal" href="../structure/TProcessID.html">TProcessID</a></li>
<li class="toctree-l1"><a class="reference internal" href="../structure/TRefArray.html">TRefArray</a></li>
<li class="toctree-l1"><a class="reference internal" href="../structure/TRef.html">TRef</a></li>
<li class="toctree-l1"><a class="reference internal" href="../structure/TTree.html">TTree</a></li>
</ul>
<p class="caption"><span class="caption-text">预定义</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../define/README.html">预定义</a></li>
<li class="toctree-l1"><a class="reference internal" href="../define/RVersion.html">RVersion</a></li>
</ul>
<p class="caption"><span class="caption-text">文件版本</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../version/version.html">文件更新版本</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">ROOT Note</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html">Docs</a> &raquo;</li>
        
      <li>TBufferFile</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../_sources/class/TBufferFile.md.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <!-- TBufferFile.md --- 
;; 
;; Description: 
;; Author: Hongyi Wu(吴鸿毅)
;; Email: wuhongyi@qq.com 
;; Created: 日 1月  6 12:10:43 2019 (+0800)
;; Last-Updated: 日 1月  6 12:53:51 2019 (+0800)
;;           By: Hongyi Wu(吴鸿毅)
;;     Update #: 1
;; URL: http://wuhongyi.cn --><div class="section" id="tbufferfile">
<h1>TBufferFile<a class="headerlink" href="#tbufferfile" title="永久链接至标题">¶</a></h1>
<p>The concrete implementation of TBuffer for writing/reading to/from a ROOT file or socket.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">TBufferFile</span> <span class="o">:</span> <span class="k">public</span> <span class="n">TBuffer</span>
</pre></div>
</div>
<div class="section" id="class">
<h2>class<a class="headerlink" href="#class" title="永久链接至标题">¶</a></h2>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">protected</span><span class="o">:</span>
   <span class="k">typedef</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">TStreamerInfo</span><span class="o">*&gt;</span> <span class="n">InfoList_t</span><span class="p">;</span>

   <span class="n">Int_t</span>           <span class="n">fMapCount</span><span class="p">;</span>      <span class="c1">///&lt; Number of objects or classes in map</span>
   <span class="n">Int_t</span>           <span class="n">fMapSize</span><span class="p">;</span>       <span class="c1">///&lt; Default size of map</span>
   <span class="n">Int_t</span>           <span class="n">fDisplacement</span><span class="p">;</span>  <span class="c1">///&lt; Value to be added to the map offsets</span>
   <span class="n">UShort_t</span>        <span class="n">fPidOffset</span><span class="p">;</span>     <span class="c1">///&lt; Offset to be added to the pid index in this key/buffer.</span>
   <span class="n">TExMap</span>         <span class="o">*</span><span class="n">fMap</span><span class="p">;</span>           <span class="c1">///&lt; Map containing object,offset pairs for reading/writing</span>
   <span class="n">TExMap</span>         <span class="o">*</span><span class="n">fClassMap</span><span class="p">;</span>      <span class="c1">///&lt; Map containing object,class pairs for reading</span>
   <span class="n">TStreamerInfo</span>  <span class="o">*</span><span class="n">fInfo</span><span class="p">;</span>          <span class="c1">///&lt; Pointer to TStreamerInfo object writing/reading the buffer</span>
   <span class="n">InfoList_t</span>      <span class="n">fInfoStack</span><span class="p">;</span>     <span class="c1">///&lt; Stack of pointers to the TStreamerInfos</span>

   <span class="k">static</span> <span class="n">Int_t</span>    <span class="n">fgMapSize</span><span class="p">;</span>      <span class="c1">///&lt; Default map size for all TBuffer objects</span>

   <span class="c1">// Default ctor</span>
   <span class="n">TBufferFile</span><span class="p">()</span> <span class="o">:</span> <span class="n">TBuffer</span><span class="p">(),</span> <span class="n">fMapCount</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">fMapSize</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span>
               <span class="n">fDisplacement</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span><span class="n">fPidOffset</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">fMap</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">fClassMap</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span>
     <span class="n">fInfo</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">fInfoStack</span><span class="p">()</span> <span class="p">{}</span>

   <span class="c1">// TBuffer objects cannot be copied or assigned</span>
   <span class="n">TBufferFile</span><span class="p">(</span><span class="k">const</span> <span class="n">TBufferFile</span> <span class="o">&amp;</span><span class="p">);</span>       <span class="c1">///&lt;  not implemented</span>
   <span class="kt">void</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">TBufferFile</span> <span class="o">&amp;</span><span class="p">);</span>    <span class="c1">///&lt;  not implemented</span>

   <span class="n">Int_t</span>  <span class="nf">CheckByteCount</span><span class="p">(</span><span class="n">UInt_t</span> <span class="n">startpos</span><span class="p">,</span> <span class="n">UInt_t</span> <span class="n">bcnt</span><span class="p">,</span> <span class="k">const</span> <span class="n">TClass</span> <span class="o">*</span><span class="n">clss</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">classname</span><span class="p">);</span>
<span class="c1">/// Check byte count with current buffer position. They should</span>
<span class="c1">/// match. If not print warning and position buffer in correct</span>
<span class="c1">/// place determined by the byte count. Startpos is position of</span>
<span class="c1">/// first byte where the byte count is written in buffer.</span>
<span class="c1">/// Returns 0 if everything is ok, otherwise the bytecount offset</span>
<span class="c1">/// (&lt; 0 when read too little, &gt;0 when read too much).   </span>
   
   <span class="kt">void</span>   <span class="nf">CheckCount</span><span class="p">(</span><span class="n">UInt_t</span> <span class="n">offset</span><span class="p">);</span>
<span class="c1">/// Check if offset is not too large (&lt; kMaxMapCount) when writing.   </span>
   
   <span class="n">UInt_t</span> <span class="nf">CheckObject</span><span class="p">(</span><span class="n">UInt_t</span> <span class="n">offset</span><span class="p">,</span> <span class="k">const</span> <span class="n">TClass</span> <span class="o">*</span><span class="n">cl</span><span class="p">,</span> <span class="n">Bool_t</span> <span class="n">readClass</span> <span class="o">=</span> <span class="n">kFALSE</span><span class="p">);</span>
<span class="c1">/// Check for object in the read map. If the object is 0 it still has to be</span>
<span class="c1">/// read. Try to read it from the buffer starting at location offset. If the</span>
<span class="c1">/// object is -1 then it really does not exist and we return 0. If the object</span>
<span class="c1">/// exists just return the offset.</span>

   <span class="k">virtual</span>  <span class="kt">void</span>  <span class="nf">WriteObjectClass</span><span class="p">(</span><span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">actualObjStart</span><span class="p">,</span> <span class="k">const</span> <span class="n">TClass</span> <span class="o">*</span><span class="n">actualClass</span><span class="p">,</span> <span class="n">Bool_t</span> <span class="n">cacheReuse</span><span class="p">);</span>
<span class="c1">/// Write object to I/O buffer.</span>
<span class="c1">/// This function assumes that the value of &#39;actualObjectStart&#39; is the actual start of</span>
<span class="c1">/// the object of class &#39;actualClass&#39;</span>
<span class="c1">/// If &#39;cacheReuse&#39; is true (default) upon seeing an object address a second time,</span>
<span class="c1">/// we record the offset where its was written the first time rather than streaming</span>
<span class="c1">/// the object a second time.</span>
<span class="c1">/// If &#39;cacheReuse&#39; is false, we always stream the object.  This allows the (re)use</span>
<span class="c1">/// of temporary object to store different data in the same buffer.</span>

<span class="k">public</span><span class="o">:</span>
   <span class="k">enum</span> <span class="p">{</span> <span class="n">kMapSize</span> <span class="o">=</span> <span class="mi">503</span> <span class="p">};</span>
   <span class="k">enum</span> <span class="p">{</span> <span class="n">kStreamedMemberWise</span> <span class="o">=</span> <span class="n">BIT</span><span class="p">(</span><span class="mi">14</span><span class="p">)</span> <span class="p">};</span> <span class="c1">//added to version number to know if a collection has been stored member-wise</span>
   <span class="k">enum</span> <span class="n">EStatusBits</span> <span class="p">{</span>
     <span class="n">kNotDecompressed</span>    <span class="o">=</span> <span class="n">BIT</span><span class="p">(</span><span class="mi">15</span><span class="p">),</span>    <span class="c1">//indicates a weird buffer, used by TBasket</span>
     <span class="n">kTextBasedStreaming</span> <span class="o">=</span> <span class="n">BIT</span><span class="p">(</span><span class="mi">18</span><span class="p">),</span> <span class="c1">//indicates if buffer used for XML/SQL object streaming</span>

     <span class="n">kUser1</span> <span class="o">=</span> <span class="n">BIT</span><span class="p">(</span><span class="mi">21</span><span class="p">),</span> <span class="c1">//free for user</span>
     <span class="n">kUser2</span> <span class="o">=</span> <span class="n">BIT</span><span class="p">(</span><span class="mi">22</span><span class="p">),</span> <span class="c1">//free for user</span>
     <span class="n">kUser3</span> <span class="o">=</span> <span class="n">BIT</span><span class="p">(</span><span class="mi">23</span><span class="p">)</span>  <span class="c1">//free for user</span>
   <span class="p">};</span>

   <span class="n">TBufferFile</span><span class="p">(</span><span class="n">TBuffer</span><span class="o">::</span><span class="n">EMode</span> <span class="n">mode</span><span class="p">);</span>
<span class="c1">/// Create an I/O buffer object. Mode should be either TBuffer::kRead or</span>
<span class="c1">/// TBuffer::kWrite. By default the I/O buffer has a size of</span>
<span class="c1">/// TBuffer::kInitialSize (1024) bytes.   </span>
   
   <span class="n">TBufferFile</span><span class="p">(</span><span class="n">TBuffer</span><span class="o">::</span><span class="n">EMode</span> <span class="n">mode</span><span class="p">,</span> <span class="n">Int_t</span> <span class="n">bufsiz</span><span class="p">);</span>
<span class="c1">/// Create an I/O buffer object. Mode should be either TBuffer::kRead or</span>
<span class="c1">/// TBuffer::kWrite.   </span>
   
   <span class="n">TBufferFile</span><span class="p">(</span><span class="n">TBuffer</span><span class="o">::</span><span class="n">EMode</span> <span class="n">mode</span><span class="p">,</span> <span class="n">Int_t</span> <span class="n">bufsiz</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="n">Bool_t</span> <span class="n">adopt</span> <span class="o">=</span> <span class="n">kTRUE</span><span class="p">,</span> <span class="n">ReAllocCharFun_t</span> <span class="n">reallocfunc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">);</span>
<span class="c1">/// Create an I/O buffer object.</span>
<span class="c1">/// Mode should be either TBuffer::kRead or</span>
<span class="c1">/// TBuffer::kWrite. By default the I/O buffer has a size of</span>
<span class="c1">/// TBuffer::kInitialSize (1024) bytes. An external buffer can be passed</span>
<span class="c1">/// to TBuffer via the buf argument. By default this buffer will be adopted</span>
<span class="c1">/// unless adopt is false.</span>
<span class="c1">/// If the new buffer is &lt;b&gt;not&lt;/b&gt; adopted and no memory allocation routine</span>
<span class="c1">/// is provided, a Fatal error will be issued if the Buffer attempts to</span>
<span class="c1">/// expand.   </span>
   
   <span class="k">virtual</span> <span class="o">~</span><span class="n">TBufferFile</span><span class="p">();</span>

   <span class="n">Int_t</span>    <span class="nf">GetMapCount</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">fMapCount</span><span class="p">;</span> <span class="p">}</span>
   <span class="kt">void</span>     <span class="nf">GetMappedObject</span><span class="p">(</span><span class="n">UInt_t</span> <span class="n">tag</span><span class="p">,</span> <span class="kt">void</span><span class="o">*</span> <span class="o">&amp;</span><span class="n">ptr</span><span class="p">,</span> <span class="n">TClass</span><span class="o">*</span> <span class="o">&amp;</span><span class="n">ClassPtr</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
<span class="c1">/// Retrieve the object stored in the buffer&#39;s object map at &#39;tag&#39;</span>
<span class="c1">/// Set ptr and ClassPtr respectively to the address of the object and</span>
<span class="c1">/// a pointer to its TClass.   </span>
   
   <span class="kt">void</span>     <span class="nf">MapObject</span><span class="p">(</span><span class="k">const</span> <span class="n">TObject</span> <span class="o">*</span><span class="n">obj</span><span class="p">,</span> <span class="n">UInt_t</span> <span class="n">offset</span> <span class="o">=</span> <span class="mi">1</span><span class="p">);</span>
<span class="c1">/// Add object to the fMap container.</span>
<span class="c1">/// If obj is not 0 add object to the map (in read mode also add 0 objects to</span>
<span class="c1">/// the map). This method may only be called outside this class just before</span>
<span class="c1">/// calling obj-&gt;Streamer() to prevent self reference of obj, in case obj</span>
<span class="c1">/// contains (via via) a pointer to itself. In that case offset must be 1</span>
<span class="c1">/// (default value for offset).   </span>
   
   <span class="kt">void</span>     <span class="nf">MapObject</span><span class="p">(</span><span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">obj</span><span class="p">,</span> <span class="k">const</span> <span class="n">TClass</span> <span class="o">*</span><span class="n">cl</span><span class="p">,</span> <span class="n">UInt_t</span> <span class="n">offset</span> <span class="o">=</span> <span class="mi">1</span><span class="p">);</span>
<span class="c1">/// Add object to the fMap container.</span>
<span class="c1">/// If obj is not 0 add object to the map (in read mode also add 0 objects to</span>
<span class="c1">/// the map). This method may only be called outside this class just before</span>
<span class="c1">/// calling obj-&gt;Streamer() to prevent self reference of obj, in case obj</span>
<span class="c1">/// contains (via via) a pointer to itself. In that case offset must be 1</span>
<span class="c1">/// (default value for offset).   </span>
   
   <span class="kt">void</span>     <span class="nf">Reset</span><span class="p">()</span> <span class="p">{</span> <span class="n">SetBufferOffset</span><span class="p">();</span> <span class="n">ResetMap</span><span class="p">();</span> <span class="p">}</span>
   <span class="kt">void</span>     <span class="nf">InitMap</span><span class="p">();</span>
<span class="c1">/// Create the fMap container and initialize them</span>
<span class="c1">/// with the null object.   </span>
   
   <span class="kt">void</span>     <span class="nf">ResetMap</span><span class="p">();</span>
<span class="c1">/// Delete existing fMap and reset map counter.   </span>
   
   <span class="kt">void</span>     <span class="nf">SetReadParam</span><span class="p">(</span><span class="n">Int_t</span> <span class="n">mapsize</span><span class="p">);</span>
<span class="c1">/// Set the initial size of the map used to store object and class</span>
<span class="c1">/// references during reading. The default size is TBufferFile::kMapSize.</span>
<span class="c1">/// Increasing the default has the benefit that when reading many</span>
<span class="c1">/// small objects the map does not need to be resized too often</span>
<span class="c1">/// (the system is always dynamic, even with the default everything</span>
<span class="c1">/// will work, only the initial resizing will cost some time).</span>
<span class="c1">/// This method can only be called directly after the creation of</span>
<span class="c1">/// the TBuffer, before any reading is done. Globally this option</span>
<span class="c1">/// can be changed using SetGlobalReadParam().   </span>
   
   <span class="kt">void</span>     <span class="nf">SetWriteParam</span><span class="p">(</span><span class="n">Int_t</span> <span class="n">mapsize</span><span class="p">);</span>
<span class="c1">/// Set the initial size of the hashtable used to store object and class</span>
<span class="c1">/// references during writing. The default size is TBufferFile::kMapSize.</span>
<span class="c1">/// Increasing the default has the benefit that when writing many</span>
<span class="c1">/// small objects the hashtable does not get too many collisions</span>
<span class="c1">/// (the system is always dynamic, even with the default everything</span>
<span class="c1">/// will work, only a large number of collisions will cost performance).</span>
<span class="c1">/// For optimal performance hashsize should always be a prime.</span>
<span class="c1">/// This method can only be called directly after the creation of</span>
<span class="c1">/// the TBuffer, before any writing is done. Globally this option</span>
<span class="c1">/// can be changed using SetGlobalWriteParam().</span>

   <span class="n">Bool_t</span>   <span class="nf">CheckObject</span><span class="p">(</span><span class="k">const</span> <span class="n">TObject</span> <span class="o">*</span><span class="n">obj</span><span class="p">);</span>
<span class="c1">/// Check if the specified object is already in the buffer.</span>
<span class="c1">/// Returns kTRUE if object already in the buffer, kFALSE otherwise</span>
<span class="c1">/// (also if obj is 0 or TBuffer not in writing mode).</span>

   <span class="n">Bool_t</span>   <span class="nf">CheckObject</span><span class="p">(</span><span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">obj</span><span class="p">,</span> <span class="k">const</span> <span class="n">TClass</span> <span class="o">*</span><span class="n">ptrClass</span><span class="p">);</span>
<span class="c1">/// Check if the specified object of the specified class is already in</span>
<span class="c1">/// the buffer. Returns kTRUE if object already in the buffer,</span>
<span class="c1">/// kFALSE otherwise (also if obj is 0 ).</span>

   <span class="k">virtual</span> <span class="n">Int_t</span>      <span class="nf">GetVersionOwner</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
<span class="c1">/// Return the version number of the owner file.   </span>
   
   <span class="k">virtual</span> <span class="n">Int_t</span>      <span class="nf">CheckByteCount</span><span class="p">(</span><span class="n">UInt_t</span> <span class="n">startpos</span><span class="p">,</span> <span class="n">UInt_t</span> <span class="n">bcnt</span><span class="p">,</span> <span class="k">const</span> <span class="n">TClass</span> <span class="o">*</span><span class="n">clss</span><span class="p">);</span>
<span class="c1">/// Check byte count with current buffer position. They should</span>
<span class="c1">/// match. If not print warning and position buffer in correct</span>
<span class="c1">/// place determined by the byte count. Startpos is position of</span>
<span class="c1">/// first byte where the byte count is written in buffer.</span>
<span class="c1">/// Returns 0 if everything is ok, otherwise the bytecount offset</span>
<span class="c1">/// (&lt; 0 when read too little, &gt;0 when read too much).   </span>
   
   <span class="k">virtual</span> <span class="n">Int_t</span>      <span class="nf">CheckByteCount</span><span class="p">(</span><span class="n">UInt_t</span> <span class="n">startpos</span><span class="p">,</span> <span class="n">UInt_t</span> <span class="n">bcnt</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">classname</span><span class="p">);</span>
<span class="c1">/// Check byte count with current buffer position. They should</span>
<span class="c1">/// match. If not print warning and position buffer in correct</span>
<span class="c1">/// place determined by the byte count. Startpos is position of</span>
<span class="c1">/// first byte where the byte count is written in buffer.</span>
<span class="c1">/// Returns 0 if everything is ok, otherwise the bytecount offset</span>
<span class="c1">/// (&lt; 0 when read too little, &gt;0 when read too much).   </span>
   
   <span class="k">virtual</span> <span class="kt">void</span>       <span class="nf">SetByteCount</span><span class="p">(</span><span class="n">UInt_t</span> <span class="n">cntpos</span><span class="p">,</span> <span class="n">Bool_t</span> <span class="n">packInVersion</span> <span class="o">=</span> <span class="n">kFALSE</span><span class="p">);</span>
<span class="c1">/// Set byte count at position cntpos in the buffer. Generate warning if</span>
<span class="c1">/// count larger than kMaxMapCount. The count is excluded its own size.</span>

   <span class="k">virtual</span> <span class="kt">void</span>       <span class="nf">SkipVersion</span><span class="p">(</span><span class="k">const</span> <span class="n">TClass</span> <span class="o">*</span><span class="n">cl</span> <span class="o">=</span> <span class="mi">0</span><span class="p">);</span>
<span class="c1">/// Skip class version from I/O buffer.   </span>
   
   <span class="k">virtual</span> <span class="n">Version_t</span>  <span class="nf">ReadVersion</span><span class="p">(</span><span class="n">UInt_t</span> <span class="o">*</span><span class="n">start</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">UInt_t</span> <span class="o">*</span><span class="n">bcnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="k">const</span> <span class="n">TClass</span> <span class="o">*</span><span class="n">cl</span> <span class="o">=</span> <span class="mi">0</span><span class="p">);</span>
<span class="c1">/// Read class version from I/O buffer.   </span>
   
   <span class="k">virtual</span> <span class="n">Version_t</span>  <span class="nf">ReadVersionNoCheckSum</span><span class="p">(</span><span class="n">UInt_t</span> <span class="o">*</span><span class="n">start</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">UInt_t</span> <span class="o">*</span><span class="n">bcnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">);</span>
<span class="c1">/// Read class version from I/O buffer, when the caller knows for sure that</span>
<span class="c1">/// there is no checksum written/involved.   </span>
   
   <span class="k">virtual</span> <span class="n">Version_t</span>  <span class="nf">ReadVersionForMemberWise</span><span class="p">(</span><span class="k">const</span> <span class="n">TClass</span> <span class="o">*</span><span class="n">cl</span> <span class="o">=</span> <span class="mi">0</span><span class="p">);</span>
<span class="c1">/// Read class version from I/O buffer</span>
<span class="c1">/// To be used when streaming out member-wise streamed collection where we do not</span>
<span class="c1">/// care (not save) about the byte count and can safely ignore missing streamerInfo</span>
<span class="c1">/// (since they usually indicate empty collections).   </span>
   
   <span class="k">virtual</span> <span class="n">UInt_t</span>     <span class="nf">WriteVersion</span><span class="p">(</span><span class="k">const</span> <span class="n">TClass</span> <span class="o">*</span><span class="n">cl</span><span class="p">,</span> <span class="n">Bool_t</span> <span class="n">useBcnt</span> <span class="o">=</span> <span class="n">kFALSE</span><span class="p">);</span>
<span class="c1">/// Write class version to I/O buffer.   </span>
   
   <span class="k">virtual</span> <span class="n">UInt_t</span>     <span class="nf">WriteVersionMemberWise</span><span class="p">(</span><span class="k">const</span> <span class="n">TClass</span> <span class="o">*</span><span class="n">cl</span><span class="p">,</span> <span class="n">Bool_t</span> <span class="n">useBcnt</span> <span class="o">=</span> <span class="n">kFALSE</span><span class="p">);</span>
<span class="c1">/// Write class version to I/O buffer after setting the kStreamedMemberWise</span>
<span class="c1">/// bit in the version number.   </span>

   <span class="k">virtual</span> <span class="kt">void</span>      <span class="o">*</span><span class="nf">ReadObjectAny</span><span class="p">(</span><span class="k">const</span> <span class="n">TClass</span><span class="o">*</span> <span class="n">cast</span><span class="p">);</span>
<span class="c1">/// Read object from I/O buffer.</span>
<span class="c1">/// A typical use for this function is:</span>
<span class="c1">///     MyClass *ptr = (MyClass*)b.ReadObjectAny(MyClass::Class());</span>
<span class="c1">/// I.e. clCast should point to a TClass object describing the class pointed</span>
<span class="c1">/// to by your pointer.</span>
<span class="c1">/// In case of multiple inheritance, the return value might not be the</span>
<span class="c1">/// real beginning of the object in memory.  You will need to use a</span>
<span class="c1">/// dynamic_cast later if you need to retrieve it.   </span>
   
   <span class="k">virtual</span> <span class="kt">void</span>       <span class="nf">SkipObjectAny</span><span class="p">();</span>
<span class="c1">/// Skip any kind of object from buffer</span>

   <span class="k">virtual</span> <span class="kt">void</span>       <span class="nf">TagStreamerInfo</span><span class="p">(</span><span class="n">TVirtualStreamerInfo</span><span class="o">*</span> <span class="n">info</span><span class="p">);</span>
<span class="c1">/// Mark the classindex of the current file as using this TStreamerInfo   </span>
   
   <span class="k">virtual</span> <span class="kt">void</span>       <span class="nf">IncrementLevel</span><span class="p">(</span><span class="n">TVirtualStreamerInfo</span><span class="o">*</span> <span class="n">info</span><span class="p">);</span>
<span class="c1">/// Increment level.   </span>
   
   <span class="k">virtual</span> <span class="kt">void</span>       <span class="nf">SetStreamerElementNumber</span><span class="p">(</span><span class="n">TStreamerElement</span><span class="o">*</span><span class="p">,</span><span class="n">Int_t</span><span class="p">)</span> <span class="p">{}</span>
   <span class="k">virtual</span> <span class="kt">void</span>       <span class="nf">DecrementLevel</span><span class="p">(</span><span class="n">TVirtualStreamerInfo</span><span class="o">*</span><span class="p">);</span>
<span class="c1">/// Decrement level.   </span>
   
   <span class="n">TVirtualStreamerInfo</span>  <span class="o">*</span><span class="nf">GetInfo</span><span class="p">()</span> <span class="p">{</span><span class="k">return</span> <span class="p">(</span><span class="n">TVirtualStreamerInfo</span><span class="o">*</span><span class="p">)</span><span class="n">fInfo</span><span class="p">;}</span>
   <span class="k">virtual</span> <span class="kt">void</span>       <span class="nf">ClassBegin</span><span class="p">(</span><span class="k">const</span> <span class="n">TClass</span><span class="o">*</span><span class="p">,</span> <span class="n">Version_t</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{}</span>
   <span class="k">virtual</span> <span class="kt">void</span>       <span class="nf">ClassEnd</span><span class="p">(</span><span class="k">const</span> <span class="n">TClass</span><span class="o">*</span><span class="p">)</span> <span class="p">{}</span>
   <span class="k">virtual</span> <span class="kt">void</span>       <span class="nf">ClassMember</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">Int_t</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">Int_t</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{}</span>

   <span class="k">virtual</span> <span class="n">Int_t</span>      <span class="nf">ReadBuf</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="n">Int_t</span> <span class="n">max</span><span class="p">);</span>
<span class="c1">/// Read max bytes from the I/O buffer into buf. The function returns</span>
<span class="c1">/// the actual number of bytes read.   </span>
   
   <span class="k">virtual</span> <span class="kt">void</span>       <span class="nf">WriteBuf</span><span class="p">(</span><span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="n">Int_t</span> <span class="n">max</span><span class="p">);</span>
<span class="c1">/// Write max bytes from buf into the I/O buffer.</span>

   <span class="k">virtual</span> <span class="kt">char</span>      <span class="o">*</span><span class="nf">ReadString</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="n">Int_t</span> <span class="n">max</span><span class="p">);</span>
<span class="c1">/// Read string from I/O buffer. String is read till 0 character is</span>
<span class="c1">/// found or till max-1 characters are read (i.e. string s has max</span>
<span class="c1">/// bytes allocated). If max = -1 no check on number of character is</span>
<span class="c1">/// made, reading continues till 0 character is found.</span>

   <span class="k">virtual</span> <span class="kt">void</span>       <span class="nf">WriteString</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">s</span><span class="p">);</span>
<span class="c1">/// Write string to I/O buffer. Writes string upto and including the</span>
<span class="c1">/// terminating 0.</span>

   <span class="k">virtual</span> <span class="n">TClass</span>    <span class="o">*</span><span class="nf">ReadClass</span><span class="p">(</span><span class="k">const</span> <span class="n">TClass</span> <span class="o">*</span><span class="n">cl</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">UInt_t</span> <span class="o">*</span><span class="n">objTag</span> <span class="o">=</span> <span class="mi">0</span><span class="p">);</span>
<span class="c1">/// Read class definition from I/O buffer.</span>
<span class="c1">/// \param[in] clReq Can be used to cross check if the actually read object is of the requested class.</span>
<span class="c1">/// \param[in] objTag Set in case the object is a reference to an already read object.   </span>
   
   <span class="k">virtual</span> <span class="kt">void</span>       <span class="nf">WriteClass</span><span class="p">(</span><span class="k">const</span> <span class="n">TClass</span> <span class="o">*</span><span class="n">cl</span><span class="p">);</span>
<span class="c1">/// Write class description to I/O buffer.   </span>

   <span class="k">virtual</span> <span class="n">TObject</span>   <span class="o">*</span><span class="nf">ReadObject</span><span class="p">(</span><span class="k">const</span> <span class="n">TClass</span> <span class="o">*</span><span class="n">cl</span><span class="p">);</span>
<span class="c1">/// Read object from I/O buffer. clReq is NOT used.</span>
<span class="c1">/// The value returned is the address of the actual start in memory of</span>
<span class="c1">/// the object. Note that if the actual class of the object does not</span>
<span class="c1">/// inherit first from TObject, the type of the pointer is NOT &#39;TObject*&#39;.</span>
<span class="c1">/// [More accurately, the class needs to start with the TObject part, for</span>
<span class="c1">/// the pointer to be a real TObject*].</span>
<span class="c1">/// We recommend using ReadObjectAny instead of ReadObject</span>

   <span class="k">virtual</span> <span class="kt">void</span>       <span class="nf">WriteObject</span><span class="p">(</span><span class="k">const</span> <span class="n">TObject</span> <span class="o">*</span><span class="n">obj</span><span class="p">,</span> <span class="n">Bool_t</span> <span class="n">cacheReuse</span> <span class="o">=</span> <span class="n">kTRUE</span><span class="p">);</span>
<span class="c1">/// Write object to I/O buffer.</span>

   <span class="k">using</span> <span class="n">TBuffer</span><span class="o">::</span><span class="n">WriteObject</span><span class="p">;</span>

   <span class="k">virtual</span> <span class="n">Int_t</span>      <span class="nf">WriteObjectAny</span><span class="p">(</span><span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">obj</span><span class="p">,</span> <span class="k">const</span> <span class="n">TClass</span> <span class="o">*</span><span class="n">ptrClass</span><span class="p">,</span> <span class="n">Bool_t</span> <span class="n">cacheReuse</span> <span class="o">=</span> <span class="n">kTRUE</span><span class="p">);</span>
<span class="c1">/// Write object to I/O buffer.</span>
<span class="c1">/// This function assumes that the value in &#39;obj&#39; is the value stored in</span>
<span class="c1">/// a pointer to a &quot;ptrClass&quot;. The actual type of the object pointed to</span>
<span class="c1">/// can be any class derived from &quot;ptrClass&quot;.</span>
<span class="c1">/// Return:</span>
<span class="c1">///   - 0: failure</span>
<span class="c1">///   - 1: success</span>
<span class="c1">///   - 2: truncated success (i.e actual class is missing. Only ptrClass saved.)</span>
<span class="c1">/// If &#39;cacheReuse&#39; is true (default) upon seeing an object address a second time,</span>
<span class="c1">/// we record the offset where its was written the first time rather than streaming</span>
<span class="c1">/// the object a second time.</span>
<span class="c1">/// If &#39;cacheReuse&#39; is false, we always stream the object.  This allows the (re)use</span>
<span class="c1">/// of temporary object to store different data in the same buffer.</span>

   <span class="n">UShort_t</span> <span class="nf">GetPidOffset</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
      <span class="c1">// See comment in TBuffer::SetPidOffset</span>
      <span class="k">return</span> <span class="n">fPidOffset</span><span class="p">;</span>
   <span class="p">}</span>
   <span class="kt">void</span>     <span class="nf">SetPidOffset</span><span class="p">(</span><span class="n">UShort_t</span> <span class="n">offset</span><span class="p">);</span>
<span class="c1">/// This offset is used when a key (or basket) is transfered from one</span>
<span class="c1">/// file to the other.  In this case the TRef and TObject might have stored a</span>
<span class="c1">/// pid index (to retrieve TProcessIDs) which referred to their order on the original</span>
<span class="c1">/// file, the fPidOffset is to be added to those values to correctly find the</span>
<span class="c1">/// TProcessID.  This fPidOffset needs to be increment if the key/basket is copied</span>
<span class="c1">/// and need to be zero for new key/basket.   </span>
   
   <span class="n">Int_t</span>    <span class="nf">GetBufferDisplacement</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">fDisplacement</span><span class="p">;</span> <span class="p">}</span>
   <span class="kt">void</span>     <span class="nf">SetBufferDisplacement</span><span class="p">()</span> <span class="p">{</span> <span class="n">fDisplacement</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="p">}</span>
   <span class="kt">void</span>     <span class="nf">SetBufferDisplacement</span><span class="p">(</span><span class="n">Int_t</span> <span class="n">skipped</span><span class="p">)</span>
            <span class="p">{</span> <span class="n">fDisplacement</span> <span class="o">=</span>  <span class="p">(</span><span class="n">Int_t</span><span class="p">)(</span><span class="n">Length</span><span class="p">()</span> <span class="o">-</span> <span class="n">skipped</span><span class="p">);</span> <span class="p">}</span>

   <span class="c1">// basic types and arrays of basic types</span>
   <span class="k">virtual</span>   <span class="kt">void</span>     <span class="nf">ReadFloat16</span> <span class="p">(</span><span class="n">Float_t</span> <span class="o">*</span><span class="n">f</span><span class="p">,</span> <span class="n">TStreamerElement</span> <span class="o">*</span><span class="n">ele</span><span class="o">=</span><span class="mi">0</span><span class="p">);</span>
<span class="c1">/// Read a Float16_t from the buffer,</span>
<span class="c1">/// see comments about Float16_t encoding at TBufferFile::WriteFloat16().   </span>
   
   <span class="k">virtual</span>   <span class="kt">void</span>     <span class="nf">WriteFloat16</span><span class="p">(</span><span class="n">Float_t</span> <span class="o">*</span><span class="n">f</span><span class="p">,</span> <span class="n">TStreamerElement</span> <span class="o">*</span><span class="n">ele</span><span class="o">=</span><span class="mi">0</span><span class="p">);</span>
<span class="c1">/// Write a Float16_t to the buffer.</span>
<span class="c1">/// The following cases are supported for streaming a Float16_t type</span>
<span class="c1">/// depending on the range declaration in the comment field of the data member:</span>
<span class="c1">/// Case | Example |</span>
<span class="c1">/// -----|---------|</span>
<span class="c1">///  A   | Float16_t     fNormal; |</span>
<span class="c1">///  B   | Float16_t     fTemperature; //[0,100]|</span>
<span class="c1">///  C   | Float16_t     fCharge;      //[-1,1,2]|</span>
<span class="c1">///  D   | Float16_t     fVertex[3];   //[-30,30,10]|</span>
<span class="c1">///  E   | Float16_t     fChi2;        //[0,0,6]|</span>
<span class="c1">///  F   | Int_t         fNsp;&lt;br&gt;Float16_t*    fPointValue;   //[fNsp][0,3]|</span>
<span class="c1">///   - In case A fNormal is converted from a Float_t to a Float_t with mantissa truncated to 12 bits</span>
<span class="c1">///   - In case B fTemperature is converted to a 32 bit unsigned integer</span>
<span class="c1">///   - In case C fCharge is converted to a 2 bits unsigned integer</span>
<span class="c1">///   - In case D the array elements of fVertex are converted to an unsigned 10 bits integer</span>
<span class="c1">///   - In case E fChi2 is converted to a Float_t with truncated precision at 6 bits</span>
<span class="c1">///   - In case F the fNsp elements of array fPointvalue are converted to an unsigned 32 bit integer</span>
<span class="c1">/// Note that the range specifier must follow the dimension specifier.</span>
<span class="c1">/// Case B has more precision (9 to 10 significative digits than case A (6 to 7 digits).</span>
<span class="c1">/// The range specifier has the general format: [xmin,xmax] or [xmin,xmax,nbits]</span>
<span class="c1">///   - [0,1];</span>
<span class="c1">///   - [-10,100];</span>
<span class="c1">///   - [-pi,pi], [-pi/2,pi/4],[-2pi,2*pi]</span>
<span class="c1">///   - [-10,100,16]</span>
<span class="c1">///   - [0,0,8]</span>
<span class="c1">/// if nbits is not specified, or nbits &lt;2 or nbits&gt;16 it is set to 16. If</span>
<span class="c1">/// (xmin==0 and xmax==0 and nbits &lt;=14) the float word will have</span>
<span class="c1">/// its mantissa truncated to nbits significative bits.</span>
<span class="c1">/// ## IMPORTANT NOTE</span>
<span class="c1">/// ### NOTE 1</span>
<span class="c1">/// Lets assume an original variable float x:</span>
<span class="c1">/// When using the format [0,0,8] (ie range not specified) you get the best</span>
<span class="c1">/// relative precision when storing and reading back the truncated x, say xt.</span>
<span class="c1">/// The variance of (x-xt)/x will be better than when specifying a range</span>
<span class="c1">/// for the same number of bits. However the precision relative to the</span>
<span class="c1">/// range (x-xt)/(xmax-xmin) will be worst, and vice-versa.</span>
<span class="c1">/// The format [0,0,8] is also interesting when the range of x is infinite</span>
<span class="c1">/// or unknown.</span>
<span class="c1">/// ### NOTE 2</span>
<span class="c1">/// It is important to understand the difference with the meaning of nbits</span>
<span class="c1">///   - in case of [-1,1,nbits], nbits is the total number of bits used to make</span>
<span class="c1">/// the conversion from a float to an integer</span>
<span class="c1">///   - in case of [0,0,nbits], nbits is the number of bits used for the mantissa</span>
<span class="c1">///  See example of use of the Float16_t data type in tutorial double32.C</span>
<span class="c1">///  \image html tbufferfile_double32.gif   </span>
   
   <span class="k">virtual</span>   <span class="kt">void</span>     <span class="nf">ReadDouble32</span> <span class="p">(</span><span class="n">Double_t</span> <span class="o">*</span><span class="n">d</span><span class="p">,</span> <span class="n">TStreamerElement</span> <span class="o">*</span><span class="n">ele</span><span class="o">=</span><span class="mi">0</span><span class="p">);</span>
<span class="c1">/// Read a Double32_t from the buffer,</span>
<span class="c1">/// see comments about Double32_t encoding at TBufferFile::WriteDouble32().   </span>
   
   <span class="k">virtual</span>   <span class="kt">void</span>     <span class="nf">WriteDouble32</span><span class="p">(</span><span class="n">Double_t</span> <span class="o">*</span><span class="n">d</span><span class="p">,</span> <span class="n">TStreamerElement</span> <span class="o">*</span><span class="n">ele</span><span class="o">=</span><span class="mi">0</span><span class="p">);</span>
<span class="c1">/// Write a Double32_t to the buffer.</span>
<span class="c1">/// The following cases are supported for streaming a Double32_t type</span>
<span class="c1">/// depending on the range declaration in the comment field of the data member:</span>
<span class="c1">/// Case | Example |</span>
<span class="c1">/// -----|---------|</span>
<span class="c1">///  A   | Double32_t     fNormal; |</span>
<span class="c1">///  B   | Double32_t     fTemperature; //[0,100]|</span>
<span class="c1">///  C   | Double32_t     fCharge;      //[-1,1,2]|</span>
<span class="c1">///  D   | Double32_t     fVertex[3];   //[-30,30,10]|</span>
<span class="c1">///  E   | Double32_t     fChi2;        //[0,0,6]|</span>
<span class="c1">///  F   | Int_t         fNsp;&lt;br&gt;Double32_t*    fPointValue;   //[fNsp][0,3]|</span>
<span class="c1">/// In case A fNormal is converted from a Double_t to a Float_t</span>
<span class="c1">/// In case B fTemperature is converted to a 32 bit unsigned integer</span>
<span class="c1">/// In case C fCharge is converted to a 2 bits unsigned integer</span>
<span class="c1">/// In case D the array elements of fVertex are converted to an unsigned 10 bits integer</span>
<span class="c1">/// In case E fChi2 is converted to a Float_t with mantissa truncated precision at 6 bits</span>
<span class="c1">/// In case F the fNsp elements of array fPointvalue are converted to an unsigned 32 bit integer</span>
<span class="c1">///           Note that the range specifier must follow the dimension specifier.</span>
<span class="c1">/// Case B has more precision (9 to 10 significative digits than case A (6 to 7 digits).</span>
<span class="c1">/// See TBufferFile::WriteFloat16 for more information.</span>
<span class="c1">///  see example of use of the Double32_t data type in tutorial double32.C</span>
<span class="c1">///  \image html tbufferfile_double32.gif   </span>
   
   <span class="k">virtual</span>   <span class="kt">void</span>     <span class="nf">ReadWithFactor</span><span class="p">(</span><span class="n">Float_t</span> <span class="o">*</span><span class="n">ptr</span><span class="p">,</span> <span class="n">Double_t</span> <span class="n">factor</span><span class="p">,</span> <span class="n">Double_t</span> <span class="n">minvalue</span><span class="p">);</span>
<span class="c1">/// Read a Float16_t from the buffer when the factor and minimum value have been specified</span>
<span class="c1">/// see comments about Double32_t encoding at TBufferFile::WriteDouble32().   </span>
   
   <span class="k">virtual</span>   <span class="kt">void</span>     <span class="nf">ReadWithNbits</span><span class="p">(</span><span class="n">Float_t</span> <span class="o">*</span><span class="n">ptr</span><span class="p">,</span> <span class="n">Int_t</span> <span class="n">nbits</span><span class="p">);</span>
<span class="c1">/// Read a Float16_t from the buffer when the number of bits is specified (explicitly or not)</span>
<span class="c1">/// see comments about Float16_t encoding at TBufferFile::WriteFloat16().   </span>
   
   <span class="k">virtual</span>   <span class="kt">void</span>     <span class="nf">ReadWithFactor</span><span class="p">(</span><span class="n">Double_t</span> <span class="o">*</span><span class="n">ptr</span><span class="p">,</span> <span class="n">Double_t</span> <span class="n">factor</span><span class="p">,</span> <span class="n">Double_t</span> <span class="n">minvalue</span><span class="p">);</span>
<span class="c1">/// Read a Double32_t from the buffer when the factor and minimum value have been specified</span>
<span class="c1">/// see comments about Double32_t encoding at TBufferFile::WriteDouble32().   </span>
   
   <span class="k">virtual</span>   <span class="kt">void</span>     <span class="nf">ReadWithNbits</span><span class="p">(</span><span class="n">Double_t</span> <span class="o">*</span><span class="n">ptr</span><span class="p">,</span> <span class="n">Int_t</span> <span class="n">nbits</span><span class="p">);</span>
<span class="c1">/// Read a Double32_t from the buffer when the number of bits is specified (explicitly or not)</span>
<span class="c1">/// see comments about Double32_t encoding at TBufferFile::WriteDouble32().   </span>

   <span class="k">virtual</span>   <span class="n">Int_t</span>    <span class="nf">ReadArray</span><span class="p">(</span><span class="n">Bool_t</span>    <span class="o">*&amp;</span><span class="n">b</span><span class="p">);</span>
   <span class="k">virtual</span>   <span class="n">Int_t</span>    <span class="nf">ReadArray</span><span class="p">(</span><span class="n">Char_t</span>    <span class="o">*&amp;</span><span class="n">c</span><span class="p">);</span>
   <span class="k">virtual</span>   <span class="n">Int_t</span>    <span class="nf">ReadArray</span><span class="p">(</span><span class="n">UChar_t</span>   <span class="o">*&amp;</span><span class="n">c</span><span class="p">);</span>
   <span class="k">virtual</span>   <span class="n">Int_t</span>    <span class="nf">ReadArray</span><span class="p">(</span><span class="n">Short_t</span>   <span class="o">*&amp;</span><span class="n">h</span><span class="p">);</span>
   <span class="k">virtual</span>   <span class="n">Int_t</span>    <span class="nf">ReadArray</span><span class="p">(</span><span class="n">UShort_t</span>  <span class="o">*&amp;</span><span class="n">h</span><span class="p">);</span>
   <span class="k">virtual</span>   <span class="n">Int_t</span>    <span class="nf">ReadArray</span><span class="p">(</span><span class="n">Int_t</span>     <span class="o">*&amp;</span><span class="n">i</span><span class="p">);</span>
   <span class="k">virtual</span>   <span class="n">Int_t</span>    <span class="nf">ReadArray</span><span class="p">(</span><span class="n">UInt_t</span>    <span class="o">*&amp;</span><span class="n">i</span><span class="p">);</span>
   <span class="k">virtual</span>   <span class="n">Int_t</span>    <span class="nf">ReadArray</span><span class="p">(</span><span class="n">Long_t</span>    <span class="o">*&amp;</span><span class="n">l</span><span class="p">);</span>
   <span class="k">virtual</span>   <span class="n">Int_t</span>    <span class="nf">ReadArray</span><span class="p">(</span><span class="n">ULong_t</span>   <span class="o">*&amp;</span><span class="n">l</span><span class="p">);</span>
   <span class="k">virtual</span>   <span class="n">Int_t</span>    <span class="nf">ReadArray</span><span class="p">(</span><span class="n">Long64_t</span>  <span class="o">*&amp;</span><span class="n">l</span><span class="p">);</span>
   <span class="k">virtual</span>   <span class="n">Int_t</span>    <span class="nf">ReadArray</span><span class="p">(</span><span class="n">ULong64_t</span> <span class="o">*&amp;</span><span class="n">l</span><span class="p">);</span>
   <span class="k">virtual</span>   <span class="n">Int_t</span>    <span class="nf">ReadArray</span><span class="p">(</span><span class="n">Float_t</span>   <span class="o">*&amp;</span><span class="n">f</span><span class="p">);</span>
   <span class="k">virtual</span>   <span class="n">Int_t</span>    <span class="nf">ReadArray</span><span class="p">(</span><span class="n">Double_t</span>  <span class="o">*&amp;</span><span class="n">d</span><span class="p">);</span>
   <span class="k">virtual</span>   <span class="n">Int_t</span>    <span class="nf">ReadArrayFloat16</span><span class="p">(</span><span class="n">Float_t</span>  <span class="o">*&amp;</span><span class="n">f</span><span class="p">,</span> <span class="n">TStreamerElement</span> <span class="o">*</span><span class="n">ele</span><span class="o">=</span><span class="mi">0</span><span class="p">);</span>
<span class="c1">/// Read array of floats (written as truncated float) from the I/O buffer.</span>
<span class="c1">/// Returns the number of floats read.</span>
<span class="c1">/// If argument is a 0 pointer then space will be allocated for the array.</span>
<span class="c1">/// see comments about Float16_t encoding at TBufferFile::WriteFloat16   </span>
   
   <span class="k">virtual</span>   <span class="n">Int_t</span>    <span class="nf">ReadArrayDouble32</span><span class="p">(</span><span class="n">Double_t</span>  <span class="o">*&amp;</span><span class="n">d</span><span class="p">,</span> <span class="n">TStreamerElement</span> <span class="o">*</span><span class="n">ele</span><span class="o">=</span><span class="mi">0</span><span class="p">);</span>
<span class="c1">/// Read array of doubles (written as float) from the I/O buffer.</span>
<span class="c1">/// Returns the number of doubles read.</span>
<span class="c1">/// If argument is a 0 pointer then space will be allocated for the array.</span>
<span class="c1">/// see comments about Double32_t encoding at TBufferFile::WriteDouble32</span>


   <span class="k">virtual</span>   <span class="n">Int_t</span>    <span class="nf">ReadStaticArray</span><span class="p">(</span><span class="n">Bool_t</span>    <span class="o">*</span><span class="n">b</span><span class="p">);</span>
   <span class="k">virtual</span>   <span class="n">Int_t</span>    <span class="nf">ReadStaticArray</span><span class="p">(</span><span class="n">Char_t</span>    <span class="o">*</span><span class="n">c</span><span class="p">);</span>
   <span class="k">virtual</span>   <span class="n">Int_t</span>    <span class="nf">ReadStaticArray</span><span class="p">(</span><span class="n">UChar_t</span>   <span class="o">*</span><span class="n">c</span><span class="p">);</span>
   <span class="k">virtual</span>   <span class="n">Int_t</span>    <span class="nf">ReadStaticArray</span><span class="p">(</span><span class="n">Short_t</span>   <span class="o">*</span><span class="n">h</span><span class="p">);</span>
   <span class="k">virtual</span>   <span class="n">Int_t</span>    <span class="nf">ReadStaticArray</span><span class="p">(</span><span class="n">UShort_t</span>  <span class="o">*</span><span class="n">h</span><span class="p">);</span>
   <span class="k">virtual</span>   <span class="n">Int_t</span>    <span class="nf">ReadStaticArray</span><span class="p">(</span><span class="n">Int_t</span>     <span class="o">*</span><span class="n">i</span><span class="p">);</span>
   <span class="k">virtual</span>   <span class="n">Int_t</span>    <span class="nf">ReadStaticArray</span><span class="p">(</span><span class="n">UInt_t</span>    <span class="o">*</span><span class="n">i</span><span class="p">);</span>
   <span class="k">virtual</span>   <span class="n">Int_t</span>    <span class="nf">ReadStaticArray</span><span class="p">(</span><span class="n">Long_t</span>    <span class="o">*</span><span class="n">l</span><span class="p">);</span>
   <span class="k">virtual</span>   <span class="n">Int_t</span>    <span class="nf">ReadStaticArray</span><span class="p">(</span><span class="n">ULong_t</span>   <span class="o">*</span><span class="n">l</span><span class="p">);</span>
   <span class="k">virtual</span>   <span class="n">Int_t</span>    <span class="nf">ReadStaticArray</span><span class="p">(</span><span class="n">Long64_t</span>  <span class="o">*</span><span class="n">l</span><span class="p">);</span>
   <span class="k">virtual</span>   <span class="n">Int_t</span>    <span class="nf">ReadStaticArray</span><span class="p">(</span><span class="n">ULong64_t</span> <span class="o">*</span><span class="n">l</span><span class="p">);</span>
   <span class="k">virtual</span>   <span class="n">Int_t</span>    <span class="nf">ReadStaticArray</span><span class="p">(</span><span class="n">Float_t</span>   <span class="o">*</span><span class="n">f</span><span class="p">);</span>
   <span class="k">virtual</span>   <span class="n">Int_t</span>    <span class="nf">ReadStaticArray</span><span class="p">(</span><span class="n">Double_t</span>  <span class="o">*</span><span class="n">d</span><span class="p">);</span>
   <span class="k">virtual</span>   <span class="n">Int_t</span>    <span class="nf">ReadStaticArrayFloat16</span><span class="p">(</span><span class="n">Float_t</span>  <span class="o">*</span><span class="n">f</span><span class="p">,</span> <span class="n">TStreamerElement</span> <span class="o">*</span><span class="n">ele</span><span class="o">=</span><span class="mi">0</span><span class="p">);</span>
<span class="c1">/// Read array of floats (written as truncated float) from the I/O buffer.</span>
<span class="c1">/// Returns the number of floats read.</span>
<span class="c1">/// see comments about Float16_t encoding at TBufferFile::WriteFloat16   </span>
   
   <span class="k">virtual</span>   <span class="n">Int_t</span>    <span class="nf">ReadStaticArrayDouble32</span><span class="p">(</span><span class="n">Double_t</span>  <span class="o">*</span><span class="n">d</span><span class="p">,</span> <span class="n">TStreamerElement</span> <span class="o">*</span><span class="n">ele</span><span class="o">=</span><span class="mi">0</span><span class="p">);</span>
<span class="c1">/// Read array of doubles (written as float) from the I/O buffer.</span>
<span class="c1">/// Returns the number of doubles read.</span>
<span class="c1">/// see comments about Double32_t encoding at TBufferFile::WriteDouble32</span>


   <span class="k">virtual</span>   <span class="kt">void</span>     <span class="nf">ReadFastArray</span><span class="p">(</span><span class="n">Bool_t</span>    <span class="o">*</span><span class="n">b</span><span class="p">,</span> <span class="n">Int_t</span> <span class="n">n</span><span class="p">);</span>
   <span class="k">virtual</span>   <span class="kt">void</span>     <span class="nf">ReadFastArray</span><span class="p">(</span><span class="n">Char_t</span>    <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="n">Int_t</span> <span class="n">n</span><span class="p">);</span>
   <span class="k">virtual</span>   <span class="kt">void</span>     <span class="nf">ReadFastArrayString</span><span class="p">(</span><span class="n">Char_t</span>    <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="n">Int_t</span> <span class="n">n</span><span class="p">);</span>
   <span class="k">virtual</span>   <span class="kt">void</span>     <span class="nf">ReadFastArray</span><span class="p">(</span><span class="n">UChar_t</span>   <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="n">Int_t</span> <span class="n">n</span><span class="p">);</span>
   <span class="k">virtual</span>   <span class="kt">void</span>     <span class="nf">ReadFastArray</span><span class="p">(</span><span class="n">Short_t</span>   <span class="o">*</span><span class="n">h</span><span class="p">,</span> <span class="n">Int_t</span> <span class="n">n</span><span class="p">);</span>
   <span class="k">virtual</span>   <span class="kt">void</span>     <span class="nf">ReadFastArray</span><span class="p">(</span><span class="n">UShort_t</span>  <span class="o">*</span><span class="n">h</span><span class="p">,</span> <span class="n">Int_t</span> <span class="n">n</span><span class="p">);</span>
   <span class="k">virtual</span>   <span class="kt">void</span>     <span class="nf">ReadFastArray</span><span class="p">(</span><span class="n">Int_t</span>     <span class="o">*</span><span class="n">i</span><span class="p">,</span> <span class="n">Int_t</span> <span class="n">n</span><span class="p">);</span>
   <span class="k">virtual</span>   <span class="kt">void</span>     <span class="nf">ReadFastArray</span><span class="p">(</span><span class="n">UInt_t</span>    <span class="o">*</span><span class="n">i</span><span class="p">,</span> <span class="n">Int_t</span> <span class="n">n</span><span class="p">);</span>
   <span class="k">virtual</span>   <span class="kt">void</span>     <span class="nf">ReadFastArray</span><span class="p">(</span><span class="n">Long_t</span>    <span class="o">*</span><span class="n">l</span><span class="p">,</span> <span class="n">Int_t</span> <span class="n">n</span><span class="p">);</span>
   <span class="k">virtual</span>   <span class="kt">void</span>     <span class="nf">ReadFastArray</span><span class="p">(</span><span class="n">ULong_t</span>   <span class="o">*</span><span class="n">l</span><span class="p">,</span> <span class="n">Int_t</span> <span class="n">n</span><span class="p">);</span>
   <span class="k">virtual</span>   <span class="kt">void</span>     <span class="nf">ReadFastArray</span><span class="p">(</span><span class="n">Long64_t</span>  <span class="o">*</span><span class="n">l</span><span class="p">,</span> <span class="n">Int_t</span> <span class="n">n</span><span class="p">);</span>
   <span class="k">virtual</span>   <span class="kt">void</span>     <span class="nf">ReadFastArray</span><span class="p">(</span><span class="n">ULong64_t</span> <span class="o">*</span><span class="n">l</span><span class="p">,</span> <span class="n">Int_t</span> <span class="n">n</span><span class="p">);</span>
   <span class="k">virtual</span>   <span class="kt">void</span>     <span class="nf">ReadFastArray</span><span class="p">(</span><span class="n">Float_t</span>   <span class="o">*</span><span class="n">f</span><span class="p">,</span> <span class="n">Int_t</span> <span class="n">n</span><span class="p">);</span>
   <span class="k">virtual</span>   <span class="kt">void</span>     <span class="nf">ReadFastArray</span><span class="p">(</span><span class="n">Double_t</span>  <span class="o">*</span><span class="n">d</span><span class="p">,</span> <span class="n">Int_t</span> <span class="n">n</span><span class="p">);</span>
   <span class="k">virtual</span>   <span class="kt">void</span>     <span class="nf">ReadFastArrayFloat16</span><span class="p">(</span><span class="n">Float_t</span>  <span class="o">*</span><span class="n">f</span><span class="p">,</span> <span class="n">Int_t</span> <span class="n">n</span><span class="p">,</span> <span class="n">TStreamerElement</span> <span class="o">*</span><span class="n">ele</span><span class="o">=</span><span class="mi">0</span><span class="p">);</span>
<span class="c1">/// Read array of n floats (written as truncated float) from the I/O buffer.</span>
<span class="c1">/// see comments about Float16_t encoding at TBufferFile::WriteFloat16   </span>
   
   <span class="k">virtual</span>   <span class="kt">void</span>     <span class="nf">ReadFastArrayDouble32</span><span class="p">(</span><span class="n">Double_t</span>  <span class="o">*</span><span class="n">d</span><span class="p">,</span> <span class="n">Int_t</span> <span class="n">n</span><span class="p">,</span> <span class="n">TStreamerElement</span> <span class="o">*</span><span class="n">ele</span><span class="o">=</span><span class="mi">0</span><span class="p">);</span>
<span class="c1">/// Read array of n doubles (written as float) from the I/O buffer.</span>
<span class="c1">/// see comments about Double32_t encoding at TBufferFile::WriteDouble32   </span>
   
   <span class="k">virtual</span>   <span class="kt">void</span>     <span class="nf">ReadFastArrayWithFactor</span><span class="p">(</span><span class="n">Float_t</span> <span class="o">*</span><span class="n">ptr</span><span class="p">,</span> <span class="n">Int_t</span> <span class="n">n</span><span class="p">,</span> <span class="n">Double_t</span> <span class="n">factor</span><span class="p">,</span> <span class="n">Double_t</span> <span class="n">minvalue</span><span class="p">)</span> <span class="p">;</span>
<span class="c1">/// Read array of n floats (written as truncated float) from the I/O buffer.</span>
<span class="c1">/// see comments about Float16_t encoding at TBufferFile::WriteFloat16   </span>
   
   <span class="k">virtual</span>   <span class="kt">void</span>     <span class="nf">ReadFastArrayWithNbits</span><span class="p">(</span><span class="n">Float_t</span> <span class="o">*</span><span class="n">ptr</span><span class="p">,</span> <span class="n">Int_t</span> <span class="n">n</span><span class="p">,</span> <span class="n">Int_t</span> <span class="n">nbits</span><span class="p">);</span>
<span class="c1">/// Read array of n floats (written as truncated float) from the I/O buffer.</span>
<span class="c1">/// see comments about Float16_t encoding at TBufferFile::WriteFloat16   </span>
   
   <span class="k">virtual</span>   <span class="kt">void</span>     <span class="nf">ReadFastArrayWithFactor</span><span class="p">(</span><span class="n">Double_t</span> <span class="o">*</span><span class="n">ptr</span><span class="p">,</span> <span class="n">Int_t</span> <span class="n">n</span><span class="p">,</span> <span class="n">Double_t</span> <span class="n">factor</span><span class="p">,</span> <span class="n">Double_t</span> <span class="n">minvalue</span><span class="p">);</span>
<span class="c1">/// Read array of n doubles (written as float) from the I/O buffer.</span>
<span class="c1">/// see comments about Double32_t encoding at TBufferFile::WriteDouble32   </span>
   
   <span class="k">virtual</span>   <span class="kt">void</span>     <span class="nf">ReadFastArrayWithNbits</span><span class="p">(</span><span class="n">Double_t</span> <span class="o">*</span><span class="n">ptr</span><span class="p">,</span> <span class="n">Int_t</span> <span class="n">n</span><span class="p">,</span> <span class="n">Int_t</span> <span class="n">nbits</span><span class="p">)</span> <span class="p">;</span>
<span class="c1">/// Read array of n doubles (written as float) from the I/O buffer.</span>
<span class="c1">/// see comments about Double32_t encoding at TBufferFile::WriteDouble32   </span>
   
   <span class="k">virtual</span>   <span class="kt">void</span>     <span class="nf">ReadFastArray</span><span class="p">(</span><span class="kt">void</span>  <span class="o">*</span><span class="n">start</span> <span class="p">,</span> <span class="k">const</span> <span class="n">TClass</span> <span class="o">*</span><span class="n">cl</span><span class="p">,</span> <span class="n">Int_t</span> <span class="n">n</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">TMemberStreamer</span> <span class="o">*</span><span class="n">s</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="k">const</span> <span class="n">TClass</span><span class="o">*</span> <span class="n">onFileClass</span><span class="o">=</span><span class="mi">0</span> <span class="p">);</span>
<span class="c1">/// Read an array of &#39;n&#39; objects from the I/O buffer.</span>
<span class="c1">/// Stores the objects read starting at the address &#39;start&#39;.</span>
<span class="c1">/// The objects in the array are assume to be of class &#39;cl&#39;.   </span>
   
   <span class="k">virtual</span>   <span class="kt">void</span>     <span class="nf">ReadFastArray</span><span class="p">(</span><span class="kt">void</span> <span class="o">**</span><span class="n">startp</span><span class="p">,</span> <span class="k">const</span> <span class="n">TClass</span> <span class="o">*</span><span class="n">cl</span><span class="p">,</span> <span class="n">Int_t</span> <span class="n">n</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">Bool_t</span> <span class="n">isPreAlloc</span><span class="o">=</span><span class="n">kFALSE</span><span class="p">,</span> <span class="n">TMemberStreamer</span> <span class="o">*</span><span class="n">s</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="k">const</span> <span class="n">TClass</span><span class="o">*</span> <span class="n">onFileClass</span><span class="o">=</span><span class="mi">0</span><span class="p">);</span>
<span class="c1">/// Read an array of &#39;n&#39; objects from the I/O buffer.</span>
<span class="c1">/// The objects read are stored starting at the address &#39;*start&#39;</span>
<span class="c1">/// The objects in the array are assumed to be of class &#39;cl&#39; or a derived class.</span>
<span class="c1">/// &#39;mode&#39; indicates whether the data member is marked with &#39;-&gt;&#39;</span>


   <span class="k">virtual</span>   <span class="kt">void</span>     <span class="nf">WriteArray</span><span class="p">(</span><span class="k">const</span> <span class="n">Bool_t</span>    <span class="o">*</span><span class="n">b</span><span class="p">,</span> <span class="n">Int_t</span> <span class="n">n</span><span class="p">);</span>
   <span class="k">virtual</span>   <span class="kt">void</span>     <span class="nf">WriteArray</span><span class="p">(</span><span class="k">const</span> <span class="n">Char_t</span>    <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="n">Int_t</span> <span class="n">n</span><span class="p">);</span>
   <span class="k">virtual</span>   <span class="kt">void</span>     <span class="nf">WriteArray</span><span class="p">(</span><span class="k">const</span> <span class="n">UChar_t</span>   <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="n">Int_t</span> <span class="n">n</span><span class="p">);</span>
   <span class="k">virtual</span>   <span class="kt">void</span>     <span class="nf">WriteArray</span><span class="p">(</span><span class="k">const</span> <span class="n">Short_t</span>   <span class="o">*</span><span class="n">h</span><span class="p">,</span> <span class="n">Int_t</span> <span class="n">n</span><span class="p">);</span>
   <span class="k">virtual</span>   <span class="kt">void</span>     <span class="nf">WriteArray</span><span class="p">(</span><span class="k">const</span> <span class="n">UShort_t</span>  <span class="o">*</span><span class="n">h</span><span class="p">,</span> <span class="n">Int_t</span> <span class="n">n</span><span class="p">);</span>
   <span class="k">virtual</span>   <span class="kt">void</span>     <span class="nf">WriteArray</span><span class="p">(</span><span class="k">const</span> <span class="n">Int_t</span>     <span class="o">*</span><span class="n">i</span><span class="p">,</span> <span class="n">Int_t</span> <span class="n">n</span><span class="p">);</span>
   <span class="k">virtual</span>   <span class="kt">void</span>     <span class="nf">WriteArray</span><span class="p">(</span><span class="k">const</span> <span class="n">UInt_t</span>    <span class="o">*</span><span class="n">i</span><span class="p">,</span> <span class="n">Int_t</span> <span class="n">n</span><span class="p">);</span>
   <span class="k">virtual</span>   <span class="kt">void</span>     <span class="nf">WriteArray</span><span class="p">(</span><span class="k">const</span> <span class="n">Long_t</span>    <span class="o">*</span><span class="n">l</span><span class="p">,</span> <span class="n">Int_t</span> <span class="n">n</span><span class="p">);</span>
   <span class="k">virtual</span>   <span class="kt">void</span>     <span class="nf">WriteArray</span><span class="p">(</span><span class="k">const</span> <span class="n">ULong_t</span>   <span class="o">*</span><span class="n">l</span><span class="p">,</span> <span class="n">Int_t</span> <span class="n">n</span><span class="p">);</span>
   <span class="k">virtual</span>   <span class="kt">void</span>     <span class="nf">WriteArray</span><span class="p">(</span><span class="k">const</span> <span class="n">Long64_t</span>  <span class="o">*</span><span class="n">l</span><span class="p">,</span> <span class="n">Int_t</span> <span class="n">n</span><span class="p">);</span>
   <span class="k">virtual</span>   <span class="kt">void</span>     <span class="nf">WriteArray</span><span class="p">(</span><span class="k">const</span> <span class="n">ULong64_t</span> <span class="o">*</span><span class="n">l</span><span class="p">,</span> <span class="n">Int_t</span> <span class="n">n</span><span class="p">);</span>
   <span class="k">virtual</span>   <span class="kt">void</span>     <span class="nf">WriteArray</span><span class="p">(</span><span class="k">const</span> <span class="n">Float_t</span>   <span class="o">*</span><span class="n">f</span><span class="p">,</span> <span class="n">Int_t</span> <span class="n">n</span><span class="p">);</span>
   <span class="k">virtual</span>   <span class="kt">void</span>     <span class="nf">WriteArray</span><span class="p">(</span><span class="k">const</span> <span class="n">Double_t</span>  <span class="o">*</span><span class="n">d</span><span class="p">,</span> <span class="n">Int_t</span> <span class="n">n</span><span class="p">);</span>
   <span class="k">virtual</span>   <span class="kt">void</span>     <span class="nf">WriteArrayFloat16</span><span class="p">(</span><span class="k">const</span> <span class="n">Float_t</span>  <span class="o">*</span><span class="n">f</span><span class="p">,</span> <span class="n">Int_t</span> <span class="n">n</span><span class="p">,</span> <span class="n">TStreamerElement</span> <span class="o">*</span><span class="n">ele</span><span class="o">=</span><span class="mi">0</span><span class="p">);</span>
<span class="c1">/// Write array of n floats (as truncated float) into the I/O buffer.</span>
<span class="c1">/// see comments about Float16_t encoding at TBufferFile::WriteFloat16   </span>
   
   <span class="k">virtual</span>   <span class="kt">void</span>     <span class="nf">WriteArrayDouble32</span><span class="p">(</span><span class="k">const</span> <span class="n">Double_t</span>  <span class="o">*</span><span class="n">d</span><span class="p">,</span> <span class="n">Int_t</span> <span class="n">n</span><span class="p">,</span> <span class="n">TStreamerElement</span> <span class="o">*</span><span class="n">ele</span><span class="o">=</span><span class="mi">0</span><span class="p">);</span>
<span class="c1">/// Write array of n doubles (as float) into the I/O buffer.</span>
<span class="c1">/// see comments about Double32_t encoding at TBufferFile::WriteDouble32</span>

   <span class="k">virtual</span>   <span class="kt">void</span>     <span class="nf">WriteFastArray</span><span class="p">(</span><span class="k">const</span> <span class="n">Bool_t</span>    <span class="o">*</span><span class="n">b</span><span class="p">,</span> <span class="n">Int_t</span> <span class="n">n</span><span class="p">);</span>
   <span class="k">virtual</span>   <span class="kt">void</span>     <span class="nf">WriteFastArray</span><span class="p">(</span><span class="k">const</span> <span class="n">Char_t</span>    <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="n">Int_t</span> <span class="n">n</span><span class="p">);</span>
   <span class="k">virtual</span>   <span class="kt">void</span>     <span class="nf">WriteFastArrayString</span><span class="p">(</span><span class="k">const</span> <span class="n">Char_t</span>    <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="n">Int_t</span> <span class="n">n</span><span class="p">);</span><span class="c1">/// Write array of n characters into the I/O buffer.</span>
   <span class="k">virtual</span>   <span class="kt">void</span>     <span class="nf">WriteFastArray</span><span class="p">(</span><span class="k">const</span> <span class="n">UChar_t</span>   <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="n">Int_t</span> <span class="n">n</span><span class="p">);</span>
   <span class="k">virtual</span>   <span class="kt">void</span>     <span class="nf">WriteFastArray</span><span class="p">(</span><span class="k">const</span> <span class="n">Short_t</span>   <span class="o">*</span><span class="n">h</span><span class="p">,</span> <span class="n">Int_t</span> <span class="n">n</span><span class="p">);</span>
   <span class="k">virtual</span>   <span class="kt">void</span>     <span class="nf">WriteFastArray</span><span class="p">(</span><span class="k">const</span> <span class="n">UShort_t</span>  <span class="o">*</span><span class="n">h</span><span class="p">,</span> <span class="n">Int_t</span> <span class="n">n</span><span class="p">);</span>
   <span class="k">virtual</span>   <span class="kt">void</span>     <span class="nf">WriteFastArray</span><span class="p">(</span><span class="k">const</span> <span class="n">Int_t</span>     <span class="o">*</span><span class="n">i</span><span class="p">,</span> <span class="n">Int_t</span> <span class="n">n</span><span class="p">);</span>
   <span class="k">virtual</span>   <span class="kt">void</span>     <span class="nf">WriteFastArray</span><span class="p">(</span><span class="k">const</span> <span class="n">UInt_t</span>    <span class="o">*</span><span class="n">i</span><span class="p">,</span> <span class="n">Int_t</span> <span class="n">n</span><span class="p">);</span>
   <span class="k">virtual</span>   <span class="kt">void</span>     <span class="nf">WriteFastArray</span><span class="p">(</span><span class="k">const</span> <span class="n">Long_t</span>    <span class="o">*</span><span class="n">l</span><span class="p">,</span> <span class="n">Int_t</span> <span class="n">n</span><span class="p">);</span>
   <span class="k">virtual</span>   <span class="kt">void</span>     <span class="nf">WriteFastArray</span><span class="p">(</span><span class="k">const</span> <span class="n">ULong_t</span>   <span class="o">*</span><span class="n">l</span><span class="p">,</span> <span class="n">Int_t</span> <span class="n">n</span><span class="p">);</span>
   <span class="k">virtual</span>   <span class="kt">void</span>     <span class="nf">WriteFastArray</span><span class="p">(</span><span class="k">const</span> <span class="n">Long64_t</span>  <span class="o">*</span><span class="n">l</span><span class="p">,</span> <span class="n">Int_t</span> <span class="n">n</span><span class="p">);</span>
   <span class="k">virtual</span>   <span class="kt">void</span>     <span class="nf">WriteFastArray</span><span class="p">(</span><span class="k">const</span> <span class="n">ULong64_t</span> <span class="o">*</span><span class="n">l</span><span class="p">,</span> <span class="n">Int_t</span> <span class="n">n</span><span class="p">);</span>
   <span class="k">virtual</span>   <span class="kt">void</span>     <span class="nf">WriteFastArray</span><span class="p">(</span><span class="k">const</span> <span class="n">Float_t</span>   <span class="o">*</span><span class="n">f</span><span class="p">,</span> <span class="n">Int_t</span> <span class="n">n</span><span class="p">);</span><span class="c1">/// Write array of n floats into the I/O buffer.</span>
   <span class="k">virtual</span>   <span class="kt">void</span>     <span class="nf">WriteFastArray</span><span class="p">(</span><span class="k">const</span> <span class="n">Double_t</span>  <span class="o">*</span><span class="n">d</span><span class="p">,</span> <span class="n">Int_t</span> <span class="n">n</span><span class="p">);</span><span class="c1">/// Write array of n doubles into the I/O buffer.</span>
   <span class="k">virtual</span>   <span class="kt">void</span>     <span class="nf">WriteFastArrayFloat16</span><span class="p">(</span><span class="k">const</span> <span class="n">Float_t</span>  <span class="o">*</span><span class="n">f</span><span class="p">,</span> <span class="n">Int_t</span> <span class="n">n</span><span class="p">,</span> <span class="n">TStreamerElement</span> <span class="o">*</span><span class="n">ele</span><span class="o">=</span><span class="mi">0</span><span class="p">);</span>
<span class="c1">/// Write array of n floats (as truncated float) into the I/O buffer.</span>
<span class="c1">/// see comments about Float16_t encoding at TBufferFile::WriteFloat16   </span>
   
   <span class="k">virtual</span>   <span class="kt">void</span>     <span class="nf">WriteFastArrayDouble32</span><span class="p">(</span><span class="k">const</span> <span class="n">Double_t</span>  <span class="o">*</span><span class="n">d</span><span class="p">,</span> <span class="n">Int_t</span> <span class="n">n</span><span class="p">,</span> <span class="n">TStreamerElement</span> <span class="o">*</span><span class="n">ele</span><span class="o">=</span><span class="mi">0</span><span class="p">);</span>
<span class="c1">/// Write array of n doubles (as float) into the I/O buffer.</span>
<span class="c1">/// see comments about Double32_t encoding at TBufferFile::WriteDouble32   </span>
   
   <span class="k">virtual</span>   <span class="kt">void</span>     <span class="nf">WriteFastArray</span><span class="p">(</span><span class="kt">void</span>  <span class="o">*</span><span class="n">start</span><span class="p">,</span>  <span class="k">const</span> <span class="n">TClass</span> <span class="o">*</span><span class="n">cl</span><span class="p">,</span> <span class="n">Int_t</span> <span class="n">n</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">TMemberStreamer</span> <span class="o">*</span><span class="n">s</span><span class="o">=</span><span class="mi">0</span><span class="p">);</span>
<span class="c1">/// Write an array of object starting at the address &#39;start&#39; and of length &#39;n&#39;</span>
<span class="c1">/// the objects in the array are assumed to be of class &#39;cl&#39;   </span>
   
   <span class="k">virtual</span>   <span class="n">Int_t</span>    <span class="nf">WriteFastArray</span><span class="p">(</span><span class="kt">void</span> <span class="o">**</span><span class="n">startp</span><span class="p">,</span> <span class="k">const</span> <span class="n">TClass</span> <span class="o">*</span><span class="n">cl</span><span class="p">,</span> <span class="n">Int_t</span> <span class="n">n</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">Bool_t</span> <span class="n">isPreAlloc</span><span class="o">=</span><span class="n">kFALSE</span><span class="p">,</span> <span class="n">TMemberStreamer</span> <span class="o">*</span><span class="n">s</span><span class="o">=</span><span class="mi">0</span><span class="p">);</span>
<span class="c1">/// Write an array of object starting at the address &#39;*start&#39; and of length &#39;n&#39;</span>
<span class="c1">/// the objects in the array are of class &#39;cl&#39;</span>
<span class="c1">/// &#39;isPreAlloc&#39; indicates whether the data member is marked with &#39;-&gt;&#39;</span>
<span class="c1">/// Return:</span>
<span class="c1">///   - 0: success</span>
<span class="c1">///   - 2: truncated success (i.e actual class is missing. Only ptrClass saved.)</span>

   <span class="k">virtual</span>   <span class="kt">void</span>     <span class="nf">StreamObject</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">obj</span><span class="p">,</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">type_info</span> <span class="o">&amp;</span><span class="n">typeinfo</span><span class="p">,</span> <span class="k">const</span> <span class="n">TClass</span><span class="o">*</span> <span class="n">onFileClass</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">);</span>
<span class="c1">/// Stream an object given its C++ typeinfo information.   </span>
   
   <span class="k">virtual</span>   <span class="kt">void</span>     <span class="nf">StreamObject</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">obj</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">className</span><span class="p">,</span> <span class="k">const</span> <span class="n">TClass</span><span class="o">*</span> <span class="n">onFileClass</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">);</span>
<span class="c1">/// Stream an object given the name of its actual class.   </span>
   
   <span class="k">virtual</span>   <span class="kt">void</span>     <span class="nf">StreamObject</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">obj</span><span class="p">,</span> <span class="k">const</span> <span class="n">TClass</span> <span class="o">*</span><span class="n">cl</span><span class="p">,</span> <span class="k">const</span> <span class="n">TClass</span><span class="o">*</span> <span class="n">onFileClass</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">);</span>
<span class="c1">/// Stream an object given a pointer to its actual class.   </span>
   
   <span class="k">virtual</span>   <span class="kt">void</span>     <span class="nf">StreamObject</span><span class="p">(</span><span class="n">TObject</span> <span class="o">*</span><span class="n">obj</span><span class="p">);</span>
<span class="c1">/// Stream an object inheriting from TObject using its streamer.   </span>

   <span class="k">virtual</span>   <span class="kt">void</span>     <span class="nf">ReadBool</span><span class="p">(</span><span class="n">Bool_t</span>       <span class="o">&amp;</span><span class="n">b</span><span class="p">);</span>
   <span class="k">virtual</span>   <span class="kt">void</span>     <span class="nf">ReadChar</span><span class="p">(</span><span class="n">Char_t</span>       <span class="o">&amp;</span><span class="n">c</span><span class="p">);</span>
   <span class="k">virtual</span>   <span class="kt">void</span>     <span class="nf">ReadUChar</span><span class="p">(</span><span class="n">UChar_t</span>     <span class="o">&amp;</span><span class="n">c</span><span class="p">);</span>
   <span class="k">virtual</span>   <span class="kt">void</span>     <span class="nf">ReadShort</span><span class="p">(</span><span class="n">Short_t</span>     <span class="o">&amp;</span><span class="n">s</span><span class="p">);</span>
   <span class="k">virtual</span>   <span class="kt">void</span>     <span class="nf">ReadUShort</span><span class="p">(</span><span class="n">UShort_t</span>   <span class="o">&amp;</span><span class="n">s</span><span class="p">);</span>
   <span class="k">virtual</span>   <span class="kt">void</span>     <span class="nf">ReadInt</span><span class="p">(</span><span class="n">Int_t</span>         <span class="o">&amp;</span><span class="n">i</span><span class="p">);</span>
   <span class="k">virtual</span>   <span class="kt">void</span>     <span class="nf">ReadUInt</span><span class="p">(</span><span class="n">UInt_t</span>       <span class="o">&amp;</span><span class="n">i</span><span class="p">);</span>
   <span class="k">virtual</span>   <span class="kt">void</span>     <span class="nf">ReadLong</span><span class="p">(</span><span class="n">Long_t</span>       <span class="o">&amp;</span><span class="n">l</span><span class="p">);</span>
   <span class="k">virtual</span>   <span class="kt">void</span>     <span class="nf">ReadULong</span><span class="p">(</span><span class="n">ULong_t</span>     <span class="o">&amp;</span><span class="n">l</span><span class="p">);</span>
   <span class="k">virtual</span>   <span class="kt">void</span>     <span class="nf">ReadLong64</span><span class="p">(</span><span class="n">Long64_t</span>   <span class="o">&amp;</span><span class="n">l</span><span class="p">);</span>
   <span class="k">virtual</span>   <span class="kt">void</span>     <span class="nf">ReadULong64</span><span class="p">(</span><span class="n">ULong64_t</span> <span class="o">&amp;</span><span class="n">l</span><span class="p">);</span>
   <span class="k">virtual</span>   <span class="kt">void</span>     <span class="nf">ReadFloat</span><span class="p">(</span><span class="n">Float_t</span>     <span class="o">&amp;</span><span class="n">f</span><span class="p">);</span>
   <span class="k">virtual</span>   <span class="kt">void</span>     <span class="nf">ReadDouble</span><span class="p">(</span><span class="n">Double_t</span>   <span class="o">&amp;</span><span class="n">d</span><span class="p">);</span>
   <span class="k">virtual</span>   <span class="kt">void</span>     <span class="nf">ReadCharP</span><span class="p">(</span><span class="n">Char_t</span>      <span class="o">*</span><span class="n">c</span><span class="p">);</span>
   <span class="k">virtual</span>   <span class="kt">void</span>     <span class="nf">ReadTString</span><span class="p">(</span><span class="n">TString</span>   <span class="o">&amp;</span><span class="n">s</span><span class="p">);</span>
   <span class="k">virtual</span>   <span class="kt">void</span>     <span class="nf">ReadStdString</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="o">*</span><span class="n">s</span><span class="p">);</span>
   <span class="k">using</span>              <span class="n">TBuffer</span><span class="o">::</span><span class="n">ReadStdString</span><span class="p">;</span>
   <span class="k">virtual</span>   <span class="kt">void</span>     <span class="nf">ReadCharStar</span><span class="p">(</span><span class="kt">char</span><span class="o">*</span> <span class="o">&amp;</span><span class="n">s</span><span class="p">);</span>
<span class="c1">/// Read char* from TBuffer.</span>

   <span class="k">virtual</span>   <span class="kt">void</span>     <span class="nf">WriteBool</span><span class="p">(</span><span class="n">Bool_t</span>       <span class="n">b</span><span class="p">);</span>
   <span class="k">virtual</span>   <span class="kt">void</span>     <span class="nf">WriteChar</span><span class="p">(</span><span class="n">Char_t</span>       <span class="n">c</span><span class="p">);</span>
   <span class="k">virtual</span>   <span class="kt">void</span>     <span class="nf">WriteUChar</span><span class="p">(</span><span class="n">UChar_t</span>     <span class="n">c</span><span class="p">);</span>
   <span class="k">virtual</span>   <span class="kt">void</span>     <span class="nf">WriteShort</span><span class="p">(</span><span class="n">Short_t</span>     <span class="n">s</span><span class="p">);</span>
   <span class="k">virtual</span>   <span class="kt">void</span>     <span class="nf">WriteUShort</span><span class="p">(</span><span class="n">UShort_t</span>   <span class="n">s</span><span class="p">);</span>
   <span class="k">virtual</span>   <span class="kt">void</span>     <span class="nf">WriteInt</span><span class="p">(</span><span class="n">Int_t</span>         <span class="n">i</span><span class="p">);</span>
   <span class="k">virtual</span>   <span class="kt">void</span>     <span class="nf">WriteUInt</span><span class="p">(</span><span class="n">UInt_t</span>       <span class="n">i</span><span class="p">);</span>
   <span class="k">virtual</span>   <span class="kt">void</span>     <span class="nf">WriteLong</span><span class="p">(</span><span class="n">Long_t</span>       <span class="n">l</span><span class="p">);</span>
   <span class="k">virtual</span>   <span class="kt">void</span>     <span class="nf">WriteULong</span><span class="p">(</span><span class="n">ULong_t</span>     <span class="n">l</span><span class="p">);</span>
   <span class="k">virtual</span>   <span class="kt">void</span>     <span class="nf">WriteLong64</span><span class="p">(</span><span class="n">Long64_t</span>   <span class="n">l</span><span class="p">);</span>
   <span class="k">virtual</span>   <span class="kt">void</span>     <span class="nf">WriteULong64</span><span class="p">(</span><span class="n">ULong64_t</span> <span class="n">l</span><span class="p">);</span>
   <span class="k">virtual</span>   <span class="kt">void</span>     <span class="nf">WriteFloat</span><span class="p">(</span><span class="n">Float_t</span>     <span class="n">f</span><span class="p">);</span>
   <span class="k">virtual</span>   <span class="kt">void</span>     <span class="nf">WriteDouble</span><span class="p">(</span><span class="n">Double_t</span>   <span class="n">d</span><span class="p">);</span>
   <span class="k">virtual</span>   <span class="kt">void</span>     <span class="nf">WriteCharP</span><span class="p">(</span><span class="k">const</span> <span class="n">Char_t</span> <span class="o">*</span><span class="n">c</span><span class="p">);</span>
   <span class="k">virtual</span>   <span class="kt">void</span>     <span class="nf">WriteTString</span><span class="p">(</span><span class="k">const</span> <span class="n">TString</span> <span class="o">&amp;</span><span class="n">s</span><span class="p">);</span>
   <span class="k">using</span>              <span class="n">TBuffer</span><span class="o">::</span><span class="n">WriteStdString</span><span class="p">;</span>
   <span class="k">virtual</span>   <span class="kt">void</span>     <span class="nf">WriteStdString</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="o">*</span><span class="n">s</span><span class="p">);</span>
   <span class="k">virtual</span>   <span class="kt">void</span>     <span class="nf">WriteCharStar</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">s</span><span class="p">);</span>
<span class="c1">/// Write char* into TBuffer.</span>

   <span class="c1">// Special basic ROOT objects and collections</span>
   <span class="k">virtual</span>   <span class="n">TProcessID</span> <span class="o">*</span><span class="nf">GetLastProcessID</span><span class="p">(</span><span class="n">TRefTable</span> <span class="o">*</span><span class="n">reftable</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
<span class="c1">/// Return the last TProcessID in the file.   </span>
   
   <span class="k">virtual</span>   <span class="n">UInt_t</span>      <span class="nf">GetTRefExecId</span><span class="p">();</span>
<span class="c1">/// Return the exec id stored in the current TStreamerInfo element.</span>
<span class="c1">/// The execid has been saved in the unique id of the TStreamerElement</span>
<span class="c1">/// being read by TStreamerElement::Streamer.</span>
<span class="c1">/// The current element (fgElement) is set as a static global</span>
<span class="c1">/// by TStreamerInfo::ReadBuffer (Clones) when reading this TRef.   </span>
   
   <span class="k">virtual</span>   <span class="n">TProcessID</span> <span class="o">*</span><span class="nf">ReadProcessID</span><span class="p">(</span><span class="n">UShort_t</span> <span class="n">pidf</span><span class="p">);</span>
<span class="c1">/// The TProcessID with number pidf is read from file.</span>
<span class="c1">/// If the object is not already entered in the gROOT list, it is added.   </span>
   
   <span class="k">virtual</span>   <span class="n">UShort_t</span>    <span class="nf">WriteProcessID</span><span class="p">(</span><span class="n">TProcessID</span> <span class="o">*</span><span class="n">pid</span><span class="p">);</span>
<span class="c1">/// Check if the ProcessID pid is already in the file.</span>
<span class="c1">/// If not, add it and return the index number in the local file list.</span>

   <span class="c1">// Utilities for TStreamerInfo</span>
   <span class="k">virtual</span>   <span class="kt">void</span>   <span class="nf">ForceWriteInfo</span><span class="p">(</span><span class="n">TVirtualStreamerInfo</span> <span class="o">*</span><span class="n">info</span><span class="p">,</span> <span class="n">Bool_t</span> <span class="n">force</span><span class="p">);</span>
<span class="c1">/// force writing the TStreamerInfo to the file   </span>
   
   <span class="k">virtual</span>   <span class="kt">void</span>   <span class="nf">ForceWriteInfoClones</span><span class="p">(</span><span class="n">TClonesArray</span> <span class="o">*</span><span class="n">a</span><span class="p">);</span>
<span class="c1">/// Make sure TStreamerInfo is not optimized, otherwise it will not be</span>
<span class="c1">/// possible to support schema evolution in read mode.</span>
<span class="c1">/// In case the StreamerInfo has already been computed and optimized,</span>
<span class="c1">/// one must disable the option BypassStreamer.   </span>
   
   <span class="k">virtual</span>   <span class="n">Int_t</span>  <span class="nf">ReadClones</span> <span class="p">(</span><span class="n">TClonesArray</span> <span class="o">*</span><span class="n">a</span><span class="p">,</span> <span class="n">Int_t</span> <span class="n">nobjects</span><span class="p">,</span> <span class="n">Version_t</span> <span class="n">objvers</span><span class="p">);</span>
<span class="c1">/// Interface to TStreamerInfo::ReadBufferClones.   </span>
   
   <span class="k">virtual</span>   <span class="n">Int_t</span>  <span class="nf">WriteClones</span><span class="p">(</span><span class="n">TClonesArray</span> <span class="o">*</span><span class="n">a</span><span class="p">,</span> <span class="n">Int_t</span> <span class="n">nobjects</span><span class="p">);</span>
<span class="c1">/// Interface to TStreamerInfo::WriteBufferClones.</span>

   <span class="c1">// Utilities for TClass</span>
   <span class="k">virtual</span>   <span class="n">Int_t</span>  <span class="nf">ReadClassEmulated</span><span class="p">(</span><span class="k">const</span> <span class="n">TClass</span> <span class="o">*</span><span class="n">cl</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">object</span><span class="p">,</span> <span class="k">const</span> <span class="n">TClass</span> <span class="o">*</span><span class="n">onfile_class</span><span class="p">);</span>
<span class="c1">/// Read emulated class.   </span>
   
   <span class="k">virtual</span>   <span class="n">Int_t</span>  <span class="nf">ReadClassBuffer</span><span class="p">(</span><span class="k">const</span> <span class="n">TClass</span> <span class="o">*</span><span class="n">cl</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">pointer</span><span class="p">,</span> <span class="k">const</span> <span class="n">TClass</span> <span class="o">*</span><span class="n">onfile_class</span><span class="p">);</span>
<span class="c1">/// Deserialize information from a buffer into an object.</span>
<span class="c1">/// Note: This function is called by the xxx::Streamer()</span>
<span class="c1">/// functions in rootcint-generated dictionaries.   </span>
   
   <span class="k">virtual</span>   <span class="n">Int_t</span>  <span class="nf">ReadClassBuffer</span><span class="p">(</span><span class="k">const</span> <span class="n">TClass</span> <span class="o">*</span><span class="n">cl</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">pointer</span><span class="p">,</span> <span class="n">Int_t</span> <span class="n">version</span><span class="p">,</span> <span class="n">UInt_t</span> <span class="n">start</span><span class="p">,</span> <span class="n">UInt_t</span> <span class="n">count</span><span class="p">,</span> <span class="k">const</span> <span class="n">TClass</span> <span class="o">*</span><span class="n">onfile_class</span><span class="p">);</span>
<span class="c1">/// Deserialize information from a buffer into an object.</span>
<span class="c1">/// Note: This function is called by the xxx::Streamer() functions in</span>
<span class="c1">/// rootcint-generated dictionaries.</span>
<span class="c1">/// This function assumes that the class version and the byte count</span>
<span class="c1">/// information have been read.</span>
<span class="c1">/// \param[in] version The version number of the class</span>
<span class="c1">/// \param[in] start   The starting position in the buffer b</span>
<span class="c1">/// \param[in] count   The number of bytes for this object in the buffer   </span>
   
   <span class="k">virtual</span>   <span class="n">Int_t</span>  <span class="nf">WriteClassBuffer</span><span class="p">(</span><span class="k">const</span> <span class="n">TClass</span> <span class="o">*</span><span class="n">cl</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">pointer</span><span class="p">);</span>
<span class="c1">/// Function called by the Streamer functions to serialize object at p</span>
<span class="c1">/// to buffer b. The optional argument info may be specified to give an</span>
<span class="c1">/// alternative StreamerInfo instead of using the default StreamerInfo</span>
<span class="c1">/// automatically built from the class definition.</span>
<span class="c1">/// For more information, see class TStreamerInfo.</span>

   <span class="c1">// Utilites to streamer using sequences.</span>
   <span class="n">Int_t</span> <span class="nf">ApplySequence</span><span class="p">(</span><span class="k">const</span> <span class="n">TStreamerInfoActions</span><span class="o">::</span><span class="n">TActionSequence</span> <span class="o">&amp;</span><span class="n">sequence</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">object</span><span class="p">);</span>
<span class="c1">/// Read one collection of objects from the buffer using the StreamerInfoLoopAction.</span>
<span class="c1">/// The collection needs to be a split TClonesArray or a split vector of pointers.   </span>
   
   <span class="n">Int_t</span> <span class="nf">ApplySequenceVecPtr</span><span class="p">(</span><span class="k">const</span> <span class="n">TStreamerInfoActions</span><span class="o">::</span><span class="n">TActionSequence</span> <span class="o">&amp;</span><span class="n">sequence</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">start_collection</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">end_collection</span><span class="p">);</span>
<span class="c1">/// Read one collection of objects from the buffer using the StreamerInfoLoopAction.</span>
<span class="c1">/// The collection needs to be a split TClonesArray or a split vector of pointers.   </span>
   
   <span class="n">Int_t</span> <span class="nf">ApplySequence</span><span class="p">(</span><span class="k">const</span> <span class="n">TStreamerInfoActions</span><span class="o">::</span><span class="n">TActionSequence</span> <span class="o">&amp;</span><span class="n">sequence</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">start_collection</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">end_collection</span><span class="p">);</span>
<span class="c1">/// Read one collection of objects from the buffer using the StreamerInfoLoopAction.</span>

   <span class="k">static</span> <span class="kt">void</span>    <span class="nf">SetGlobalReadParam</span><span class="p">(</span><span class="n">Int_t</span> <span class="n">mapsize</span><span class="p">);</span>
<span class="c1">/// Set the initial size of the map used to store object and class</span>
<span class="c1">/// references during reading.</span>
<span class="c1">/// The default size is kMapSize.</span>
<span class="c1">/// Increasing the default has the benefit that when reading many</span>
<span class="c1">/// small objects the array does not need to be resized too often</span>
<span class="c1">/// (the system is always dynamic, even with the default everything</span>
<span class="c1">/// will work, only the initial resizing will cost some time).</span>
<span class="c1">/// Per TBuffer object this option can be changed using SetReadParam().   </span>
   
   <span class="k">static</span> <span class="kt">void</span>    <span class="nf">SetGlobalWriteParam</span><span class="p">(</span><span class="n">Int_t</span> <span class="n">mapsize</span><span class="p">);</span>
<span class="c1">/// Set the initial size of the map used to store object and class</span>
<span class="c1">/// references during reading.</span>
<span class="c1">/// The default size is kMapSize.</span>
<span class="c1">/// Increasing the default has the benefit that when reading many</span>
<span class="c1">/// small objects the array does not need to be resized too often</span>
<span class="c1">/// (the system is always dynamic, even with the default everything</span>
<span class="c1">/// will work, only the initial resizing will cost some time).</span>
<span class="c1">/// Per TBuffer object this option can be changed using SetReadParam().   </span>
   
   <span class="k">static</span> <span class="n">Int_t</span>   <span class="nf">GetGlobalReadParam</span><span class="p">();</span>
<span class="c1">/// Get default read map size.</span>

   <span class="k">static</span> <span class="n">Int_t</span>   <span class="nf">GetGlobalWriteParam</span><span class="p">();</span>
<span class="c1">/// Get default write map size.   </span>
</pre></div>
</div>
<!-- TBufferFile.md ends here --></div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="TBufferJSON.html" class="btn btn-neutral float-right" title="TBufferJSON" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="TBuffer.html" class="btn btn-neutral float-left" title="TBuffer" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2020, Hongyi Wu(吴鸿毅)

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>