

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="zh-CN" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="zh-CN" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>TH1 &mdash; ROOT Note 1 文档</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script type="text/javascript" src="../_static/jquery.js"></script>
        <script type="text/javascript" src="../_static/underscore.js"></script>
        <script type="text/javascript" src="../_static/doctools.js"></script>
        <script type="text/javascript" src="../_static/language_data.js"></script>
        <script type="text/javascript" src="../_static/translations.js"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/graphviz.css" type="text/css" />
    <link rel="index" title="索引" href="../genindex.html" />
    <link rel="search" title="搜索" href="../search.html" />
    <link rel="next" title="TH2" href="TH2.html" />
    <link rel="prev" title="TGraphPolar" href="TGraphPolar.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html" class="icon icon-home"> ROOT Note
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">简介</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../README.html">简介</a></li>
</ul>
<p class="caption"><span class="caption-text">base类的使用</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="README.html">类的使用</a></li>
<li class="toctree-l1"><a class="reference internal" href="TObject.html">TObject</a></li>
<li class="toctree-l1"><a class="reference internal" href="TTask.html">TTask</a></li>
<li class="toctree-l1"><a class="reference internal" href="Buttons.html">Buttons</a></li>
<li class="toctree-l1"><a class="reference internal" href="TNamed.html">TNamed</a></li>
<li class="toctree-l1"><a class="reference internal" href="TStyle.html">TStyle</a></li>
<li class="toctree-l1"><a class="reference internal" href="TSystem.html">TSystem</a></li>
<li class="toctree-l1"><a class="reference internal" href="TROOT.html">TROOT</a></li>
<li class="toctree-l1"><a class="reference internal" href="TFolder.html">TFolder</a></li>
<li class="toctree-l1"><a class="reference internal" href="TEnv.html">TEnv</a></li>
<li class="toctree-l1"><a class="reference internal" href="TMacro.html">TMacro</a></li>
<li class="toctree-l1"><a class="reference internal" href="TApplication.html">TApplication</a></li>
<li class="toctree-l1"><a class="reference internal" href="TProcessID.html">TProcessID</a></li>
<li class="toctree-l1"><a class="reference internal" href="TProcessUUID.html">TProcessUUID</a></li>
<li class="toctree-l1"><a class="reference internal" href="TString.html">TString</a></li>
<li class="toctree-l1"><a class="reference internal" href="TColor.html">TColor</a></li>
<li class="toctree-l1"><a class="reference internal" href="TBase64.html">TBase64</a></li>
<li class="toctree-l1"><a class="reference internal" href="TMD5.html">TMD5</a></li>
</ul>
<p class="caption"><span class="caption-text">IO类的使用</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="README.html">类的使用</a></li>
<li class="toctree-l1"><a class="reference internal" href="TKey.html">TKey</a></li>
<li class="toctree-l1"><a class="reference internal" href="TDirectory.html">TDirectory</a></li>
<li class="toctree-l1"><a class="reference internal" href="TDirectoryFile.html">TDirectoryFile</a></li>
<li class="toctree-l1"><a class="reference internal" href="TSystemFile.html">TSystemFile</a></li>
<li class="toctree-l1"><a class="reference internal" href="TSystemDirectory.html">TSystemDirectory</a></li>
<li class="toctree-l1"><a class="reference internal" href="TFile.html">TFile</a></li>
<li class="toctree-l1"><a class="reference internal" href="TFileCacheWrite.html">TFileCacheWrite</a></li>
<li class="toctree-l1"><a class="reference internal" href="TFileCacheRead.html">TFileCacheRead</a></li>
<li class="toctree-l1"><a class="reference internal" href="TFileMerger.html">TFileMerger</a></li>
<li class="toctree-l1"><a class="reference internal" href="TMemFile.html">TMemFile</a></li>
<li class="toctree-l1"><a class="reference internal" href="TKeyMapFile.html">TKeyMapFile</a></li>
<li class="toctree-l1"><a class="reference internal" href="TMapFile.html">TMapFile</a></li>
<li class="toctree-l1"><a class="reference internal" href="TArchiveFile.html">TArchiveFile</a></li>
<li class="toctree-l1"><a class="reference internal" href="TZIPFile.html">TZIPFile</a></li>
<li class="toctree-l1"><a class="reference internal" href="TFilePrefetch.html">TFilePrefetch</a></li>
<li class="toctree-l1"><a class="reference internal" href="TFPBlock.html">TFPBlock</a></li>
<li class="toctree-l1"><a class="reference internal" href="THDFSFile.html">THDFSFile</a></li>
<li class="toctree-l1"><a class="reference internal" href="TBuffer.html">TBuffer</a></li>
<li class="toctree-l1"><a class="reference internal" href="TBufferFile.html">TBufferFile</a></li>
<li class="toctree-l1"><a class="reference internal" href="TBufferJSON.html">TBufferJSON</a></li>
<li class="toctree-l1"><a class="reference internal" href="TKeySQL.html">TKeySQL</a></li>
<li class="toctree-l1"><a class="reference internal" href="TSQLObjectData.html">TSQLObjectData</a></li>
<li class="toctree-l1"><a class="reference internal" href="TSQLStructure.html">TSQLStructure</a></li>
<li class="toctree-l1"><a class="reference internal" href="TSQLClassInfo.html">TSQLClassInfo</a></li>
<li class="toctree-l1"><a class="reference internal" href="TBufferSQL2.html">TBufferSQL2</a></li>
<li class="toctree-l1"><a class="reference internal" href="TSQLFile.html">TSQLFile</a></li>
<li class="toctree-l1"><a class="reference internal" href="TXMLEngine.html">TXMLEngine</a></li>
<li class="toctree-l1"><a class="reference internal" href="TBufferXML.html">TBufferXML</a></li>
<li class="toctree-l1"><a class="reference internal" href="TXMLSetup.html">TXMLSetup</a></li>
<li class="toctree-l1"><a class="reference internal" href="TKeyXML.html">TKeyXML</a></li>
<li class="toctree-l1"><a class="reference internal" href="TXMLPlayer.html">TXMLPlayer</a></li>
<li class="toctree-l1"><a class="reference internal" href="TXMLFile.html">TXMLFile</a></li>
</ul>
<p class="caption"><span class="caption-text">常用类的使用</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="README.html">类的使用</a></li>
<li class="toctree-l1"><a class="reference internal" href="TTree.html">TTree</a></li>
<li class="toctree-l1"><a class="reference internal" href="TCut.html">TCut</a></li>
<li class="toctree-l1"><a class="reference internal" href="TTreePlayer.html">TTreePlayer</a></li>
<li class="toctree-l1"><a class="reference internal" href="TChain.html">TChain</a></li>
<li class="toctree-l1"><a class="reference internal" href="TEventList.html">TEventList</a></li>
<li class="toctree-l1"><a class="reference internal" href="TBranch.html">TBranch</a></li>
<li class="toctree-l1"><a class="reference internal" href="TNtuple.html">TNtuple</a></li>
<li class="toctree-l1"><a class="reference internal" href="TNtupleD.html">TNtupleD</a></li>
<li class="toctree-l1"><a class="reference internal" href="TCollection.html">TCollection</a></li>
<li class="toctree-l1"><a class="reference internal" href="TSeqCollection.html">TSeqCollection</a></li>
<li class="toctree-l1"><a class="reference internal" href="TList.html">TList</a></li>
<li class="toctree-l1"><a class="reference internal" href="TVirtualFitter.html">TVirtualFitter</a></li>
<li class="toctree-l1"><a class="reference internal" href="TBackCompFitter.html">TBackCompFitter</a></li>
<li class="toctree-l1"><a class="reference internal" href="FitResult.html">FitResult</a></li>
<li class="toctree-l1"><a class="reference internal" href="TFitter.html">TFitter</a></li>
<li class="toctree-l1"><a class="reference internal" href="TFitResult.html">TFitResult</a></li>
<li class="toctree-l1"><a class="reference internal" href="TFitResultPtr.html">TFitResultPtr</a></li>
<li class="toctree-l1"><a class="reference internal" href="TFractionFitter.html">TFractionFitter</a></li>
<li class="toctree-l1"><a class="reference internal" href="TLinearFitter.html">TLinearFitter</a></li>
<li class="toctree-l1"><a class="reference internal" href="TAttAxis.html">TAttAxis</a></li>
<li class="toctree-l1"><a class="reference internal" href="TAxis.html">TAxis</a></li>
<li class="toctree-l1"><a class="reference internal" href="TGaxis.html">TGaxis</a></li>
<li class="toctree-l1"><a class="reference internal" href="TGaxis.html#example">example</a></li>
<li class="toctree-l1"><a class="reference internal" href="TText.html">TText</a></li>
<li class="toctree-l1"><a class="reference internal" href="TPaveStats.html">TPaveStats</a></li>
<li class="toctree-l1"><a class="reference internal" href="TPolyMarker.html">TPolyMarker</a></li>
<li class="toctree-l1"><a class="reference internal" href="TPaveText.html">TPaveText</a></li>
<li class="toctree-l1"><a class="reference internal" href="TPolyMarker3D.html">TPolyMarker3D</a></li>
<li class="toctree-l1"><a class="reference internal" href="TLatex.html">TLatex</a></li>
<li class="toctree-l1"><a class="reference internal" href="TLegend.html">TLegend</a></li>
<li class="toctree-l1"><a class="reference internal" href="TLegendEntry.html">TLegendEntry</a></li>
<li class="toctree-l1"><a class="reference internal" href="TLine.html">TLine</a></li>
<li class="toctree-l1"><a class="reference internal" href="TVirtualPad.html">TVirtualPad</a></li>
<li class="toctree-l1"><a class="reference internal" href="TPad.html">TPad</a></li>
<li class="toctree-l1"><a class="reference internal" href="TCanvas.html">TCanvas</a></li>
<li class="toctree-l1"><a class="reference internal" href="TF1.html">TF1</a></li>
<li class="toctree-l1"><a class="reference internal" href="TF2.html">TF2</a></li>
<li class="toctree-l1"><a class="reference internal" href="TF3.html">TF3</a></li>
<li class="toctree-l1"><a class="reference internal" href="TGraph.html">TGraph</a></li>
<li class="toctree-l1"><a class="reference internal" href="TCutG.html">TCutG</a></li>
<li class="toctree-l1"><a class="reference internal" href="TMultiGraph.html">TMultiGraph</a></li>
<li class="toctree-l1"><a class="reference internal" href="TGraph2D.html">TGraph2D</a></li>
<li class="toctree-l1"><a class="reference internal" href="TGraph2DErrors.html">TGraph2DErrors</a></li>
<li class="toctree-l1"><a class="reference internal" href="TGraphErrors.html">TGraphErrors</a></li>
<li class="toctree-l1"><a class="reference internal" href="TGraphPolar.html">TGraphPolar</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">TH1</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#class">class</a></li>
<li class="toctree-l2"><a class="reference internal" href="#code">code</a></li>
<li class="toctree-l2"><a class="reference internal" href="#example">example</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="TH2.html">TH2</a></li>
<li class="toctree-l1"><a class="reference internal" href="TH2Poly.html">TH2Poly</a></li>
<li class="toctree-l1"><a class="reference internal" href="TH3.html">TH3</a></li>
<li class="toctree-l1"><a class="reference internal" href="TProfile.html">TProfile</a></li>
<li class="toctree-l1"><a class="reference internal" href="TProfile2D.html">TProfile2D</a></li>
<li class="toctree-l1"><a class="reference internal" href="TProfile3D.html">TProfile3D</a></li>
<li class="toctree-l1"><a class="reference internal" href="TMath.html">TMath</a></li>
<li class="toctree-l1"><a class="reference internal" href="TMathBase.html">TMathBase</a></li>
<li class="toctree-l1"><a class="reference internal" href="TMatrixT.html">TMatrixT</a></li>
<li class="toctree-l1"><a class="reference internal" href="TMatrixTBase.html">TMatrixTBase</a></li>
<li class="toctree-l1"><a class="reference internal" href="TMatrixTSparse.html">TMatrixTSparse</a></li>
<li class="toctree-l1"><a class="reference internal" href="TMatrixTSym.html">TMatrixTSym</a></li>
<li class="toctree-l1"><a class="reference internal" href="TSpline.html">TSpline</a></li>
<li class="toctree-l1"><a class="reference internal" href="TMinuit.html">TMinuit</a></li>
<li class="toctree-l1"><a class="reference internal" href="TMinuitMinimizer.html">TMinuitMinimizer</a></li>
<li class="toctree-l1"><a class="reference internal" href="TRandom.html">TRandom</a></li>
<li class="toctree-l1"><a class="reference internal" href="TRandom1.html">TRandom1</a></li>
<li class="toctree-l1"><a class="reference internal" href="TRandom2.html">TRandom2</a></li>
<li class="toctree-l1"><a class="reference internal" href="TRandom3.html">TRandom3</a></li>
<li class="toctree-l1"><a class="reference internal" href="TSelector.html">TSelector</a></li>
<li class="toctree-l1"><a class="reference internal" href="TSelectorCint.html">TSelectorCint</a></li>
<li class="toctree-l1"><a class="reference internal" href="TSelectorDraw.html">TSelectorDraw</a></li>
<li class="toctree-l1"><a class="reference internal" href="TSelectorEntries.html">TSelectorEntries</a></li>
<li class="toctree-l1"><a class="reference internal" href="TSelectorList.html">TSelectorList</a></li>
<li class="toctree-l1"><a class="reference internal" href="TSelectorScalar.html">TSelectorScalar</a></li>
<li class="toctree-l1"><a class="reference internal" href="TSpectrum.html">TSpectrum</a></li>
<li class="toctree-l1"><a class="reference internal" href="TSpectrum2.html">TSpectrum2</a></li>
<li class="toctree-l1"><a class="reference internal" href="TSpectrum2Fit.html">TSpectrum2Fit</a></li>
<li class="toctree-l1"><a class="reference internal" href="TSpectrum2Painter.html">TSpectrum2Painter</a></li>
<li class="toctree-l1"><a class="reference internal" href="TSpectrum2Transform.html">TSpectrum2Transform</a></li>
<li class="toctree-l1"><a class="reference internal" href="TSpectrum3.html">TSpectrum3</a></li>
<li class="toctree-l1"><a class="reference internal" href="TSpectrumFit.html">TSpectrumFit</a></li>
<li class="toctree-l1"><a class="reference internal" href="TSpectrumTransform.html">TSpectrumTransform</a></li>
<li class="toctree-l1"><a class="reference internal" href="TTime.html">TTime</a></li>
<li class="toctree-l1"><a class="reference internal" href="TTimer.html">TTimer</a></li>
<li class="toctree-l1"><a class="reference internal" href="TTimeStamp.html">TTimeStamp</a></li>
<li class="toctree-l1"><a class="reference internal" href="TStopwatch.html">TStopwatch</a></li>
<li class="toctree-l1"><a class="reference internal" href="TBenchmark.html">TBenchmark</a></li>
<li class="toctree-l1"><a class="reference internal" href="TThread.html">TThread</a></li>
<li class="toctree-l1"><a class="reference internal" href="TThreadFactory.html">TThreadFactory</a></li>
<li class="toctree-l1"><a class="reference internal" href="TThreadImp.html">TThreadImp</a></li>
<li class="toctree-l1"><a class="reference internal" href="TServerSocket.html">TServerSocket</a></li>
<li class="toctree-l1"><a class="reference internal" href="TSocket.html">TSocket</a></li>
<li class="toctree-l1"><a class="reference internal" href="TPServerSocket.html">TPServerSocket</a></li>
<li class="toctree-l1"><a class="reference internal" href="TPSocket.html">TPSocket</a></li>
<li class="toctree-l1"><a class="reference internal" href="TEllipse.html">TEllipse</a></li>
<li class="toctree-l1"><a class="reference internal" href="TNeuron.html">TNeuron</a></li>
<li class="toctree-l1"><a class="reference internal" href="TMLPAnalyzer.html">TMLPAnalyzer</a></li>
<li class="toctree-l1"><a class="reference internal" href="TMonitor.html">TMonitor</a></li>
<li class="toctree-l1"><a class="reference internal" href="TMultiLayerPerceptron.html">TMultiLayerPerceptron</a></li>
</ul>
<p class="caption"><span class="caption-text">图形界面的使用</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="gui/README.html">README</a></li>
<li class="toctree-l1"><a class="reference internal" href="gui/GuiTypes.html">GuiTypes</a></li>
<li class="toctree-l1"><a class="reference internal" href="gui/TGButton.html">TGButton</a></li>
<li class="toctree-l1"><a class="reference internal" href="gui/TGButtonGroup.html">TGButtonGroup</a></li>
<li class="toctree-l1"><a class="reference internal" href="gui/TGCanvas.html">TGCanvas</a></li>
<li class="toctree-l1"><a class="reference internal" href="gui/TGClient.html">TGClient</a></li>
<li class="toctree-l1"><a class="reference internal" href="gui/TGColorDialog.html">TGColorDialog</a></li>
<li class="toctree-l1"><a class="reference internal" href="gui/TGColorSelect.html">TGColorSelect</a></li>
<li class="toctree-l1"><a class="reference internal" href="gui/TGComboBox.html">TGComboBox</a></li>
<li class="toctree-l1"><a class="reference internal" href="gui/TGCommandPlugin.html">TGCommandPlugin</a></li>
<li class="toctree-l1"><a class="reference internal" href="gui/TGDimension.html">TGDimension</a></li>
<li class="toctree-l1"><a class="reference internal" href="gui/TGDNDManager.html">TGDNDManager</a></li>
<li class="toctree-l1"><a class="reference internal" href="gui/TGDockableFrame.html">TGDockableFrame</a></li>
<li class="toctree-l1"><a class="reference internal" href="gui/TGDoubleSlider.html">TGDoubleSlider</a></li>
<li class="toctree-l1"><a class="reference internal" href="gui/TGEventHandler.html">TGEventHandler</a></li>
<li class="toctree-l1"><a class="reference internal" href="gui/TGFileBrowser.html">TGFileBrowser</a></li>
<li class="toctree-l1"><a class="reference internal" href="gui/TGFileDialog.html">TGFileDialog</a></li>
<li class="toctree-l1"><a class="reference internal" href="gui/TGFont.html">TGFont</a></li>
<li class="toctree-l1"><a class="reference internal" href="gui/TGFontDialog.html">TGFontDialog</a></li>
<li class="toctree-l1"><a class="reference internal" href="gui/TGFrame.html">TGFrame</a></li>
<li class="toctree-l1"><a class="reference internal" href="gui/TGFSComboBox.html">TGFSComboBox</a></li>
<li class="toctree-l1"><a class="reference internal" href="gui/TGFSContainer.html">TGFSContainer</a></li>
<li class="toctree-l1"><a class="reference internal" href="gui/TGGC.html">TGGC</a></li>
<li class="toctree-l1"><a class="reference internal" href="gui/TGIcon.html">TGIcon</a></li>
<li class="toctree-l1"><a class="reference internal" href="gui/TGIdleHandler.html">TGIdleHandler</a></li>
<li class="toctree-l1"><a class="reference internal" href="gui/TGImageMap.html">TGImageMap</a></li>
<li class="toctree-l1"><a class="reference internal" href="gui/TGInputDialog.html">TGInputDialog</a></li>
<li class="toctree-l1"><a class="reference internal" href="gui/TGLabel.html">TGLabel</a></li>
<li class="toctree-l1"><a class="reference internal" href="gui/TGLayout.html">TGLayout</a></li>
<li class="toctree-l1"><a class="reference internal" href="gui/TGListBox.html">TGListBox</a></li>
<li class="toctree-l1"><a class="reference internal" href="gui/TGListTree.html">TGListTree</a></li>
<li class="toctree-l1"><a class="reference internal" href="gui/TGListView.html">TGListView</a></li>
<li class="toctree-l1"><a class="reference internal" href="gui/TGMdiDecorFrame.html">TGMdiDecorFrame</a></li>
<li class="toctree-l1"><a class="reference internal" href="gui/TGMdiFrame.html">TGMdiFrame</a></li>
<li class="toctree-l1"><a class="reference internal" href="gui/TGMdiMainFrame.html">TGMdiMainFrame</a></li>
<li class="toctree-l1"><a class="reference internal" href="gui/TGMdiMenu.html">TGMdiMenu</a></li>
<li class="toctree-l1"><a class="reference internal" href="gui/TGMenu.html">TGMenu</a></li>
<li class="toctree-l1"><a class="reference internal" href="gui/TGMimeTypes.html">TGMimeTypes</a></li>
<li class="toctree-l1"><a class="reference internal" href="gui/TGMsgBox.html">TGMsgBox</a></li>
<li class="toctree-l1"><a class="reference internal" href="gui/TGNumberEntry.html">TGNumberEntry</a></li>
<li class="toctree-l1"><a class="reference internal" href="gui/TGObject.html">TGObject</a></li>
<li class="toctree-l1"><a class="reference internal" href="gui/TGPack.html">TGPack</a></li>
<li class="toctree-l1"><a class="reference internal" href="gui/TGPasswdDialog.html">TGPasswdDialog</a></li>
<li class="toctree-l1"><a class="reference internal" href="gui/TGPicture.html">TGPicture</a></li>
<li class="toctree-l1"><a class="reference internal" href="gui/TGProgressBar.html">TGProgressBar</a></li>
<li class="toctree-l1"><a class="reference internal" href="gui/TGRedirectOutputGuard.html">TGRedirectOutputGuard</a></li>
<li class="toctree-l1"><a class="reference internal" href="gui/TGResourcePool.html">TGResourcePool</a></li>
<li class="toctree-l1"><a class="reference internal" href="gui/TGScrollBar.html">TGScrollBar</a></li>
<li class="toctree-l1"><a class="reference internal" href="gui/TGShapedFrame.html">TGShapedFrame</a></li>
<li class="toctree-l1"><a class="reference internal" href="gui/TGShutter.html">TGShutter</a></li>
<li class="toctree-l1"><a class="reference internal" href="gui/TGSimpleTable.html">TGSimpleTable</a></li>
<li class="toctree-l1"><a class="reference internal" href="gui/TGSimpleTableInterface.html">TGSimpleTableInterface</a></li>
<li class="toctree-l1"><a class="reference internal" href="gui/TGSlider.html">TGSlider</a></li>
<li class="toctree-l1"><a class="reference internal" href="gui/TGSpeedo.html">TGSpeedo</a></li>
<li class="toctree-l1"><a class="reference internal" href="gui/TGSplitFrame.html">TGSplitFrame</a></li>
<li class="toctree-l1"><a class="reference internal" href="gui/TGSplitter.html">TGSplitter</a></li>
<li class="toctree-l1"><a class="reference internal" href="gui/TGStatusBar.html">TGStatusBar</a></li>
<li class="toctree-l1"><a class="reference internal" href="gui/TGString.html">TGString</a></li>
<li class="toctree-l1"><a class="reference internal" href="gui/TGTab.html">TGTab</a></li>
<li class="toctree-l1"><a class="reference internal" href="gui/TGTable.html">TGTable</a></li>
<li class="toctree-l1"><a class="reference internal" href="gui/TGTableCell.html">TGTableCell</a></li>
<li class="toctree-l1"><a class="reference internal" href="gui/TGTableContainer.html">TGTableContainer</a></li>
<li class="toctree-l1"><a class="reference internal" href="gui/TGTableHeader.html">TGTableHeader</a></li>
<li class="toctree-l1"><a class="reference internal" href="gui/TGTableLayout.html">TGTableLayout</a></li>
<li class="toctree-l1"><a class="reference internal" href="gui/TGText.html">TGText</a></li>
<li class="toctree-l1"><a class="reference internal" href="gui/TGTextBuffer.html">TGTextBuffer</a></li>
<li class="toctree-l1"><a class="reference internal" href="gui/TGTextEdit.html">TGTextEdit</a></li>
<li class="toctree-l1"><a class="reference internal" href="gui/TGTextEditDialogs.html">TGTextEditDialogs</a></li>
<li class="toctree-l1"><a class="reference internal" href="gui/TGTextEditor.html">TGTextEditor</a></li>
<li class="toctree-l1"><a class="reference internal" href="gui/TGTextEntry.html">TGTextEntry</a></li>
<li class="toctree-l1"><a class="reference internal" href="gui/TGTextView.html">TGTextView</a></li>
<li class="toctree-l1"><a class="reference internal" href="gui/TGTextViewStream.html">TGTextViewStream</a></li>
<li class="toctree-l1"><a class="reference internal" href="gui/TGToolBar.html">TGToolBar</a></li>
<li class="toctree-l1"><a class="reference internal" href="gui/TGToolTip.html">TGToolTip</a></li>
<li class="toctree-l1"><a class="reference internal" href="gui/TGTripleSlider.html">TGTripleSlider</a></li>
<li class="toctree-l1"><a class="reference internal" href="gui/TGuiBuilder.html">TGuiBuilder</a></li>
<li class="toctree-l1"><a class="reference internal" href="gui/TGView.html">TGView</a></li>
<li class="toctree-l1"><a class="reference internal" href="gui/TGWidget.html">TGWidget</a></li>
<li class="toctree-l1"><a class="reference internal" href="gui/TGWindow.html">TGWindow</a></li>
<li class="toctree-l1"><a class="reference internal" href="gui/TGXYLayout.html">TGXYLayout</a></li>
<li class="toctree-l1"><a class="reference internal" href="gui/TQObject.html">TQObject</a></li>
<li class="toctree-l1"><a class="reference internal" href="gui/TRootEmbeddedCanvas.html">TRootEmbeddedCanvas</a></li>
</ul>
<p class="caption"><span class="caption-text">GRAF3D</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="graf3d/README.html">README</a></li>
<li class="toctree-l1"><a class="reference internal" href="graf3d/TAxis3D.html">TAxis3D</a></li>
<li class="toctree-l1"><a class="reference internal" href="graf3d/TBRIK.html">TBRIK</a></li>
<li class="toctree-l1"><a class="reference internal" href="graf3d/TCONE.html">TCONE</a></li>
<li class="toctree-l1"><a class="reference internal" href="graf3d/TCONS.html">TCONS</a></li>
<li class="toctree-l1"><a class="reference internal" href="graf3d/TCTUB.html">TCTUB</a></li>
<li class="toctree-l1"><a class="reference internal" href="graf3d/TELTU.html">TELTU</a></li>
<li class="toctree-l1"><a class="reference internal" href="graf3d/TGeometry.html">TGeometry</a></li>
<li class="toctree-l1"><a class="reference internal" href="graf3d/TGTRA.html">TGTRA</a></li>
<li class="toctree-l1"><a class="reference internal" href="graf3d/THelix.html">THelix</a></li>
<li class="toctree-l1"><a class="reference internal" href="graf3d/THYPE.html">THYPE</a></li>
<li class="toctree-l1"><a class="reference internal" href="graf3d/TMarker3DBox.html">TMarker3DBox</a></li>
<li class="toctree-l1"><a class="reference internal" href="graf3d/TMaterial.html">TMaterial</a></li>
<li class="toctree-l1"><a class="reference internal" href="graf3d/TMixture.html">TMixture</a></li>
<li class="toctree-l1"><a class="reference internal" href="graf3d/TNodeDiv.html">TNodeDiv</a></li>
<li class="toctree-l1"><a class="reference internal" href="graf3d/TNode.html">TNode</a></li>
<li class="toctree-l1"><a class="reference internal" href="graf3d/TPARA.html">TPARA</a></li>
<li class="toctree-l1"><a class="reference internal" href="graf3d/TPCON.html">TPCON</a></li>
<li class="toctree-l1"><a class="reference internal" href="graf3d/TPGON.html">TPGON</a></li>
<li class="toctree-l1"><a class="reference internal" href="graf3d/TPoints3DABC.html">TPoints3DABC</a></li>
<li class="toctree-l1"><a class="reference internal" href="graf3d/TPointSet3D.html">TPointSet3D</a></li>
<li class="toctree-l1"><a class="reference internal" href="graf3d/TPolyLine3D.html">TPolyLine3D</a></li>
<li class="toctree-l1"><a class="reference internal" href="graf3d/TPolyMarker3D.html">TPolyMarker3D</a></li>
<li class="toctree-l1"><a class="reference internal" href="graf3d/TRotMatrix.html">TRotMatrix</a></li>
<li class="toctree-l1"><a class="reference internal" href="graf3d/TShape.html">TShape</a></li>
<li class="toctree-l1"><a class="reference internal" href="graf3d/TSPHE.html">TSPHE</a></li>
<li class="toctree-l1"><a class="reference internal" href="graf3d/TTRAP.html">TTRAP</a></li>
<li class="toctree-l1"><a class="reference internal" href="graf3d/TTRD1.html">TTRD1</a></li>
<li class="toctree-l1"><a class="reference internal" href="graf3d/TTRD2.html">TTRD2</a></li>
<li class="toctree-l1"><a class="reference internal" href="graf3d/TTUBE.html">TTUBE</a></li>
<li class="toctree-l1"><a class="reference internal" href="graf3d/TTUBS.html">TTUBS</a></li>
<li class="toctree-l1"><a class="reference internal" href="graf3d/TView3D.html">TView3D</a></li>
<li class="toctree-l1"><a class="reference internal" href="graf3d/TXTRU.html">TXTRU</a></li>
<li class="toctree-l1"><a class="reference internal" href="graf3d/X3DBuffer.html">X3DBuffer</a></li>
</ul>
<p class="caption"><span class="caption-text">physics</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="math/README.html">README</a></li>
<li class="toctree-l1"><a class="reference internal" href="math/TFeldmanCousins.html">TFeldmanCousins</a></li>
<li class="toctree-l1"><a class="reference internal" href="math/TGenPhaseSpace.html">TGenPhaseSpace</a></li>
<li class="toctree-l1"><a class="reference internal" href="math/TLorentzRotation.html">TLorentzRotation</a></li>
<li class="toctree-l1"><a class="reference internal" href="math/TLorentzVector.html">TLorentzVector</a></li>
<li class="toctree-l1"><a class="reference internal" href="math/TQuaternion.html">TQuaternion</a></li>
<li class="toctree-l1"><a class="reference internal" href="math/TRobustEstimator.html">TRobustEstimator</a></li>
<li class="toctree-l1"><a class="reference internal" href="math/TRolke.html">TRolke</a></li>
<li class="toctree-l1"><a class="reference internal" href="math/TRotation.html">TRotation</a></li>
<li class="toctree-l1"><a class="reference internal" href="math/TVectorT.html">TVectorT</a></li>
<li class="toctree-l1"><a class="reference internal" href="math/TVector2.html">TVector2</a></li>
<li class="toctree-l1"><a class="reference internal" href="math/TVector3.html">TVector3</a></li>
</ul>
<p class="caption"><span class="caption-text">net</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="net/README.html">README</a></li>
<li class="toctree-l1"><a class="reference internal" href="net/TCivetweb.html">TCivetweb</a></li>
<li class="toctree-l1"><a class="reference internal" href="net/TFastCgi.html">TFastCgi</a></li>
<li class="toctree-l1"><a class="reference internal" href="net/THttpCallArg.html">THttpCallArg</a></li>
<li class="toctree-l1"><a class="reference internal" href="net/THttpEngine.html">THttpEngine</a></li>
<li class="toctree-l1"><a class="reference internal" href="net/THttpServer.html">THttpServer</a></li>
<li class="toctree-l1"><a class="reference internal" href="net/THttpWSEngine.html">THttpWSEngine</a></li>
<li class="toctree-l1"><a class="reference internal" href="net/THttpWSHandler.html">THttpWSHandler</a></li>
<li class="toctree-l1"><a class="reference internal" href="net/TRootSniffer.html">TRootSniffer</a></li>
<li class="toctree-l1"><a class="reference internal" href="net/TRootSnifferStore.html">TRootSnifferStore</a></li>
</ul>
<p class="caption"><span class="caption-text">数据结构</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../structure/README.html">数据结构</a></li>
<li class="toctree-l1"><a class="reference internal" href="../structure/datarecord.html">datarecord</a></li>
<li class="toctree-l1"><a class="reference internal" href="../structure/dobject.html">dataobject</a></li>
<li class="toctree-l1"><a class="reference internal" href="../structure/freesegments.html">FreeSegments</a></li>
<li class="toctree-l1"><a class="reference internal" href="../structure/gap.html">gap</a></li>
<li class="toctree-l1"><a class="reference internal" href="../structure/header.html">header</a></li>
<li class="toctree-l1"><a class="reference internal" href="../structure/keyslist.html">KeysList</a></li>
<li class="toctree-l1"><a class="reference internal" href="../structure/StreamerInfo.html">StreamerInfo</a></li>
<li class="toctree-l1"><a class="reference internal" href="../structure/TClonesArray.html">TClonesArray</a></li>
<li class="toctree-l1"><a class="reference internal" href="../structure/TDirectory.html">TDirectory</a></li>
<li class="toctree-l1"><a class="reference internal" href="../structure/TFile.html">TFile</a></li>
<li class="toctree-l1"><a class="reference internal" href="../structure/TObject.html">TObject</a></li>
<li class="toctree-l1"><a class="reference internal" href="../structure/TProcessID.html">TProcessID</a></li>
<li class="toctree-l1"><a class="reference internal" href="../structure/TRefArray.html">TRefArray</a></li>
<li class="toctree-l1"><a class="reference internal" href="../structure/TRef.html">TRef</a></li>
<li class="toctree-l1"><a class="reference internal" href="../structure/TTree.html">TTree</a></li>
</ul>
<p class="caption"><span class="caption-text">预定义</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../define/README.html">预定义</a></li>
<li class="toctree-l1"><a class="reference internal" href="../define/RVersion.html">RVersion</a></li>
</ul>
<p class="caption"><span class="caption-text">文件版本</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../version/version.html">文件更新版本</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">ROOT Note</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html">Docs</a> &raquo;</li>
        
      <li>TH1</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../_sources/class/TH1.md.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <!-- TH1.md --- 
;; 
;; Description: 
;; Author: Hongyi Wu(吴鸿毅)
;; Email: wuhongyi@qq.com 
;; Created: 五 12月  5 12:32:36 2014 (+0800)
;; Last-Updated: 一 1月 15 13:31:31 2018 (+0800)
;;           By: Hongyi Wu(吴鸿毅)
;;     Update #: 23
;; URL: http://wuhongyi.cn --><div class="section" id="th1">
<h1>TH1<a class="headerlink" href="#th1" title="永久链接至标题">¶</a></h1>
<p>继承 public TNamed, public TAttLine, public TAttFill, public TAttMarker</p>
<ul class="simple">
<li><p>TH1C : histograms with one byte per channel.   Maximum bin content = 127</p></li>
<li><p>TH1S : histograms with one short per channel.  Maximum bin content = 32767</p></li>
<li><p>TH1I : histograms with one int per channel.    Maximum bin content = 2147483647</p></li>
<li><p>TH1F : histograms with one float per channel.  Maximum precision 7 digits</p></li>
<li><p>TH1D : histograms with one double per channel. Maximum precision 14 digits</p></li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">The</span> <span class="n">TH</span><span class="o">*</span><span class="n">C</span> <span class="n">classes</span> <span class="n">also</span> <span class="n">inherit</span> <span class="kn">from</span> <span class="nn">the</span> <span class="n">array</span> <span class="k">class</span> <span class="nc">TArrayC</span><span class="o">.</span>
<span class="n">The</span> <span class="n">TH</span><span class="o">*</span><span class="n">S</span> <span class="n">classes</span> <span class="n">also</span> <span class="n">inherit</span> <span class="kn">from</span> <span class="nn">the</span> <span class="n">array</span> <span class="k">class</span> <span class="nc">TArrayS</span><span class="o">.</span>
<span class="n">The</span> <span class="n">TH</span><span class="o">*</span><span class="n">I</span> <span class="n">classes</span> <span class="n">also</span> <span class="n">inherit</span> <span class="kn">from</span> <span class="nn">the</span> <span class="n">array</span> <span class="k">class</span> <span class="nc">TArrayI</span><span class="o">.</span>
<span class="n">The</span> <span class="n">TH</span><span class="o">*</span><span class="n">F</span> <span class="n">classes</span> <span class="n">also</span> <span class="n">inherit</span> <span class="kn">from</span> <span class="nn">the</span> <span class="n">array</span> <span class="k">class</span> <span class="nc">TArrayF</span><span class="o">.</span>
<span class="n">The</span> <span class="n">TH</span><span class="o">*</span><span class="n">D</span> <span class="n">classes</span> <span class="n">also</span> <span class="n">inherit</span> <span class="kn">from</span> <span class="nn">the</span> <span class="n">array</span> <span class="k">class</span> <span class="nc">TArrayD</span><span class="o">.</span>
</pre></div>
</div>
<p>When an histogram is created, a reference to it is automatically added to the list of in-memory objects for the current file or directory. This default behaviour can be changed by:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">h</span><span class="o">-&gt;</span><span class="n">SetDirectory</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>          <span class="c1">// for the current histogram h</span>
<span class="n">TH1</span><span class="o">::</span><span class="n">AddDirectory</span><span class="p">(</span><span class="n">kFALSE</span><span class="p">);</span>   <span class="c1">// sets a global switch disabling the reference</span>
</pre></div>
</div>
<p>When the histogram is deleted, the reference to it is removed from the list of objects in memory. When a file is closed, all histograms in memory associated with this file are automatically deleted.</p>
<hr class="docutils" />
<p>All histogram types support either fix or variable bin sizes. 2-D histograms may have fix size bins along X and variable size bins along Y or vice-versa. The functions to fill, manipulate, draw or access histograms are identical in both cases.</p>
<p>Convention for numbering bins</p>
<p>For all histogram types: nbins, xlow, xup</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">bin</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>       <span class="n">underflow</span> <span class="nb">bin</span>
<span class="nb">bin</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>       <span class="n">first</span> <span class="nb">bin</span> <span class="k">with</span> <span class="n">low</span><span class="o">-</span><span class="n">edge</span> <span class="n">xlow</span> <span class="n">INCLUDED</span>
<span class="nb">bin</span> <span class="o">=</span> <span class="n">nbins</span><span class="p">;</span>   <span class="n">last</span> <span class="nb">bin</span> <span class="k">with</span> <span class="n">upper</span><span class="o">-</span><span class="n">edge</span> <span class="n">xup</span> <span class="n">EXCLUDED</span>
<span class="nb">bin</span> <span class="o">=</span> <span class="n">nbins</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span> <span class="n">overflow</span> <span class="nb">bin</span>
</pre></div>
</div>
<div class="section" id="class">
<h2>class<a class="headerlink" href="#class" title="永久链接至标题">¶</a></h2>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span>   <span class="c1">// TH1 status bits</span>
   <span class="k">enum</span> <span class="p">{</span>
      <span class="n">kNoStats</span>     <span class="o">=</span> <span class="n">BIT</span><span class="p">(</span><span class="mi">9</span><span class="p">),</span>  <span class="c1">// don&#39;t draw stats box</span>
      <span class="n">kUserContour</span> <span class="o">=</span> <span class="n">BIT</span><span class="p">(</span><span class="mi">10</span><span class="p">),</span> <span class="c1">// user specified contour levels</span>
      <span class="c1">//kCanRebin    = BIT(11), // FIXME DEPRECATED - to be removed, replaced by SetCanExtend / CanExtendAllAxes</span>
      <span class="n">kLogX</span>        <span class="o">=</span> <span class="n">BIT</span><span class="p">(</span><span class="mi">15</span><span class="p">),</span> <span class="c1">// X-axis in log scale</span>
      <span class="n">kIsZoomed</span>    <span class="o">=</span> <span class="n">BIT</span><span class="p">(</span><span class="mi">16</span><span class="p">),</span> <span class="c1">// bit set when zooming on Y axis</span>
      <span class="n">kNoTitle</span>     <span class="o">=</span> <span class="n">BIT</span><span class="p">(</span><span class="mi">17</span><span class="p">),</span> <span class="c1">// don&#39;t draw the histogram title</span>
      <span class="n">kIsAverage</span>   <span class="o">=</span> <span class="n">BIT</span><span class="p">(</span><span class="mi">18</span><span class="p">),</span> <span class="c1">// Bin contents are average (used by Add)</span>
      <span class="n">kIsNotW</span>      <span class="o">=</span> <span class="n">BIT</span><span class="p">(</span><span class="mi">19</span><span class="p">)</span>  <span class="c1">// Histogram is forced to be not weighted even when the histogram is filled with weighted different than 1.</span>
   <span class="p">};</span>
   <span class="c1">// size of statistics data (size of  array used in GetStats()/ PutStats )</span>
   <span class="c1">// s[0]  = sumw       s[1]  = sumw2</span>
   <span class="c1">// s[2]  = sumwx      s[3]  = sumwx2</span>
   <span class="c1">// s[4]  = sumwy      s[5]  = sumwy2   s[6]  = sumwxy</span>
   <span class="c1">// s[7]  = sumwz      s[8]  = sumwz2   s[9]  = sumwxz   s[10]  = sumwyz</span>
   <span class="c1">// s[11] = sumwt      s[12] = sumwt2                 (11 and 12 used only by TProfile3D)</span>
   <span class="k">enum</span> <span class="p">{</span>
      <span class="n">kNstat</span>       <span class="o">=</span> <span class="mi">13</span>  <span class="c1">// size of statistics data (up to TProfile3D)</span>
   <span class="p">};</span>


   <span class="k">virtual</span> <span class="o">~</span><span class="n">TH1</span><span class="p">();</span>

   <span class="k">virtual</span> <span class="n">Bool_t</span>   <span class="nf">Add</span><span class="p">(</span><span class="n">TF1</span> <span class="o">*</span><span class="n">h1</span><span class="p">,</span> <span class="n">Double_t</span> <span class="n">c1</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">Option_t</span> <span class="o">*</span><span class="n">option</span><span class="o">=</span><span class="s">&quot;&quot;</span><span class="p">);</span>
<span class="c1">/// Performs the operation: this = this + c1*f1</span>
<span class="c1">/// if errors are defined (see TH1::Sumw2), errors are also recalculated.</span>
<span class="c1">/// By default, the function is computed at the centre of the bin.</span>
<span class="c1">/// if option &quot;I&quot; is specified (1-d histogram only), the integral of the</span>
<span class="c1">/// function in each bin is used instead of the value of the function at</span>
<span class="c1">/// the centre of the bin.</span>
<span class="c1">/// Only bins inside the function range are recomputed.</span>
<span class="c1">/// IMPORTANT NOTE: If you intend to use the errors of this histogram later</span>
<span class="c1">/// you should call Sumw2 before making this operation.</span>
<span class="c1">/// This is particularly important if you fit the histogram after TH1::Add</span>
<span class="c1">/// The function return kFALSE if the Add operation failed</span>

   <span class="k">virtual</span> <span class="n">Bool_t</span>   <span class="nf">Add</span><span class="p">(</span><span class="k">const</span> <span class="n">TH1</span> <span class="o">*</span><span class="n">h1</span><span class="p">,</span> <span class="n">Double_t</span> <span class="n">c1</span><span class="o">=</span><span class="mi">1</span><span class="p">);</span><span class="c1">//该函数是将h1直方图进行c1倍的放大或缩小后加到当前直方图中。</span>
<span class="c1">/// Performs the operation: this = this + c1*h1</span>
<span class="c1">/// If errors are defined (see TH1::Sumw2), errors are also recalculated.</span>
<span class="c1">/// Note that if h1 has Sumw2 set, Sumw2 is automatically called for this</span>
<span class="c1">/// if not already set.</span>
<span class="c1">/// Note also that adding histogram with labels is not supported, histogram will be</span>
<span class="c1">/// added merging them by bin number independently of the labels.</span>
<span class="c1">/// For adding histogram with labels one should use TH1::Merge</span>
<span class="c1">/// SPECIAL CASE (Average/Efficiency histograms)</span>
<span class="c1">/// For histograms representing averages or efficiencies, one should compute the average</span>
<span class="c1">/// of the two histograms and not the sum. One can mark a histogram to be an average</span>
<span class="c1">/// histogram by setting its bit kIsAverage with</span>
<span class="c1">/// myhist.SetBit(TH1::kIsAverage);</span>
<span class="c1">/// Note that the two histograms must have their kIsAverage bit set</span>
<span class="c1">/// IMPORTANT NOTE1: If you intend to use the errors of this histogram later</span>
<span class="c1">/// you should call Sumw2 before making this operation.</span>
<span class="c1">/// This is particularly important if you fit the histogram after TH1::Add</span>
<span class="c1">/// IMPORTANT NOTE2: if h1 has a normalisation factor, the normalisation factor</span>
<span class="c1">/// is used , ie  this = this + c1*factor*h1</span>
<span class="c1">/// Use the other TH1::Add function if you do not want this feature</span>
<span class="c1">/// The function return kFALSE if the Add operation failed</span>

   <span class="k">virtual</span> <span class="n">Bool_t</span>   <span class="nf">Add</span><span class="p">(</span><span class="k">const</span> <span class="n">TH1</span> <span class="o">*</span><span class="n">h</span><span class="p">,</span> <span class="k">const</span> <span class="n">TH1</span> <span class="o">*</span><span class="n">h2</span><span class="p">,</span> <span class="n">Double_t</span> <span class="n">c1</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">Double_t</span> <span class="n">c2</span><span class="o">=</span><span class="mi">1</span><span class="p">);</span> <span class="c1">// *MENU* 将 h1 放大或缩小 c1 倍加上 h2 放大或缩小 c2 倍相加赋给 h。</span>
<span class="c1">/// Replace contents of this histogram by the addition of h1 and h2.</span>
<span class="c1">///this = c1*h1 + c2*h2</span>
<span class="c1">///if errors are defined (see TH1::Sumw2), errors are also recalculated</span>
<span class="c1">///Note that if h1 or h2 have Sumw2 set, Sumw2 is automatically called for this</span>
<span class="c1">///if not already set.</span>
<span class="c1">///Note also that adding histogram with labels is not supported, histogram will be</span>
<span class="c1">///added merging them by bin number independently of the labels.</span>
<span class="c1">///For adding histogram ith labels one should use TH1::Merge</span>
<span class="c1">/// SPECIAL CASE (Average/Efficiency histograms)</span>
<span class="c1">/// For histograms representing averages or efficiencies, one should compute the average</span>
<span class="c1">/// of the two histograms and not the sum. One can mark a histogram to be an average</span>
<span class="c1">/// histogram by setting its bit kIsAverage with</span>
<span class="c1">/// myhist.SetBit(TH1::kIsAverage);</span>
<span class="c1">/// Note that the two histograms must have their kIsAverage bit set</span>
<span class="c1">/// IMPORTANT NOTE: If you intend to use the errors of this histogram later</span>
<span class="c1">/// you should call Sumw2 before making this operation.</span>
<span class="c1">/// This is particularly important if you fit the histogram after TH1::Add</span>
<span class="c1">/// ANOTHER SPECIAL CASE : h1 = h2 and c2 &lt; 0</span>
<span class="c1">/// do a scaling   this = c1 * h1 / (bin Volume)</span>
<span class="c1">/// The function returns kFALSE if the Add operation failed</span>

   <span class="k">virtual</span> <span class="kt">void</span>     <span class="nf">AddBinContent</span><span class="p">(</span><span class="n">Int_t</span> <span class="n">bin</span><span class="p">);</span><span class="c1">//在第 bin 个 bin 上计数加一。</span>
   <span class="k">virtual</span> <span class="kt">void</span>     <span class="nf">AddBinContent</span><span class="p">(</span><span class="n">Int_t</span> <span class="n">bin</span><span class="p">,</span> <span class="n">Double_t</span> <span class="n">w</span><span class="p">);</span><span class="c1">/// Increment bin content by a weight w.</span>
   <span class="k">static</span>  <span class="kt">void</span>     <span class="nf">AddDirectory</span><span class="p">(</span><span class="n">Bool_t</span> <span class="n">add</span><span class="o">=</span><span class="n">kTRUE</span><span class="p">);</span>
<span class="c1">/// Sets the flag controlling the automatic add of histograms in memory</span>
<span class="c1">/// By default (fAddDirectory = kTRUE), histograms are automatically added</span>
<span class="c1">/// to the list of objects in memory.</span>
<span class="c1">/// Note that one histogram can be removed from its support directory</span>
<span class="c1">/// by calling h-&gt;SetDirectory(0) or h-&gt;SetDirectory(dir) to add it</span>
<span class="c1">/// to the list of objects in the directory dir.</span>
<span class="c1">/// NOTE that this is a static function. To call it, use;</span>
<span class="c1">/// TH1::AddDirectory</span>

   <span class="k">static</span>  <span class="n">Bool_t</span>   <span class="nf">AddDirectoryStatus</span><span class="p">();</span><span class="c1">///static function: cannot be inlined on Windows/NT</span>
   <span class="k">virtual</span> <span class="kt">void</span>     <span class="nf">Browse</span><span class="p">(</span><span class="n">TBrowser</span> <span class="o">*</span><span class="n">b</span><span class="p">);</span><span class="c1">/// Browe the Histogram object.</span>
   <span class="k">virtual</span> <span class="n">Bool_t</span>   <span class="nf">CanExtendAllAxes</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span><span class="c1">/// returns true if all axes are extendable</span>
   <span class="k">virtual</span> <span class="n">Double_t</span> <span class="nf">Chi2Test</span><span class="p">(</span><span class="k">const</span> <span class="n">TH1</span><span class="o">*</span> <span class="n">h2</span><span class="p">,</span> <span class="n">Option_t</span> <span class="o">*</span><span class="n">option</span> <span class="o">=</span> <span class="s">&quot;UU&quot;</span><span class="p">,</span> <span class="n">Double_t</span> <span class="o">*</span><span class="n">res</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
<span class="c1">/// chi^{2} test for comparing weighted and unweighted histograms</span>
<span class="c1">/// Function: Returns p-value. Other return values are specified by the 3rd parameter</span>
<span class="c1">/// \param[in] h2 the second histogram</span>
<span class="c1">/// \param[in] option</span>
<span class="c1">///   - &quot;UU&quot; = experiment experiment comparison (unweighted-unweighted)</span>
<span class="c1">///   - &quot;UW&quot; = experiment MC comparison (unweighted-weighted). Note that</span>
<span class="c1">///      the first histogram should be unweighted</span>
<span class="c1">///   - &quot;WW&quot; = MC MC comparison (weighted-weighted)</span>
<span class="c1">///   - &quot;NORM&quot; = to be used when one or both of the histograms is scaled</span>
<span class="c1">///              but the histogram originally was unweighted</span>
<span class="c1">///   - by default underflows and overlows are not included:</span>
<span class="c1">///      * &quot;OF&quot; = overflows included</span>
<span class="c1">///      * &quot;UF&quot; = underflows included</span>
<span class="c1">///   - &quot;P&quot; = print chi2, ndf, p_value, igood</span>
<span class="c1">///   - &quot;CHI2&quot; = returns chi2 instead of p-value</span>
<span class="c1">///   - &quot;CHI2/NDF&quot; = returns #chi^{2}/ndf</span>
<span class="c1">/// \param[in] res not empty - computes normalized residuals and returns them in this array</span>
<span class="c1">/// The current implementation is based on the papers chi^{2} test for comparison</span>
<span class="c1">/// of weighted and unweighted histograms&quot; in Proceedings of PHYSTAT05 and</span>
<span class="c1">/// &quot;Comparison weighted and unweighted histograms&quot;, arXiv:physics/0605123</span>
<span class="c1">/// by N.Gagunashvili. This function has been implemented by Daniel Haertl in August 2006.</span>
<span class="c1">/// Introduction:</span>
<span class="c1">/// A frequently used technique in data analysis is the comparison of</span>
<span class="c1">/// histograms. First suggested by Pearson [1] the #chi^{2}  test of</span>
<span class="c1">/// homogeneity is used widely for comparing usual (unweighted) histograms.</span>
<span class="c1">/// This paper describes the implementation modified #chi^{2} tests</span>
<span class="c1">/// for comparison of weighted and unweighted  histograms and two weighted</span>
<span class="c1">/// histograms [2] as well as usual Pearson&#39;s #chi^{2} test for</span>
<span class="c1">/// comparison two usual (unweighted) histograms.</span>
<span class="c1">/// Overview:</span>
<span class="c1">/// Comparison of two histograms expect hypotheses that two histograms</span>
<span class="c1">/// represent identical distributions. To make a decision p-value should</span>
<span class="c1">/// be calculated. The hypotheses of identity is rejected if the p-value is</span>
<span class="c1">/// lower then some significance level. Traditionally significance levels</span>
<span class="c1">/// 0.1, 0.05 and 0.01 are used. The comparison procedure should include an</span>
<span class="c1">/// analysis of the residuals which is often helpful in identifying the</span>
<span class="c1">/// bins of histograms responsible for a significant overall #chi^{2} value.</span>
<span class="c1">/// Residuals are the difference between bin contents and expected bin</span>
<span class="c1">/// contents. Most convenient for analysis are the normalized residuals. If</span>
<span class="c1">/// hypotheses of identity are valid then normalized residuals are</span>
<span class="c1">/// approximately independent and identically distributed random variables</span>
<span class="c1">/// having N(0,1) distribution. Analysis of residuals expect test of above</span>
<span class="c1">/// mentioned properties of residuals. Notice that indirectly the analysis</span>
<span class="c1">/// of residuals increase the power of #chi^{2} test.</span>
<span class="c1">/// Methods of comparison:</span>
<span class="c1">/// #chi^{2} test for comparison two (unweighted) histograms:</span>
<span class="c1">/// Let us consider two  histograms with the  same binning and the  number</span>
<span class="c1">/// of bins equal to r. Let us denote the number of events in the ith bin</span>
<span class="c1">/// in the first histogram as ni and as mi in the second one. The total</span>
<span class="c1">/// number of events in the first histogram is equal to:</span>
<span class="c1">/// \f[</span>
<span class="c1">///  N = \sum_{i=1}^{r} n_{i}</span>
<span class="c1">/// \f]</span>
<span class="c1">/// and</span>
<span class="c1">/// \f[</span>
<span class="c1">///  M = \sum_{i=1}^{r} m_{i}</span>
<span class="c1">/// \f]</span>
<span class="c1">/// in the second histogram. The hypothesis of identity (homogeneity) [3]</span>
<span class="c1">/// is that the two histograms represent random values with identical</span>
<span class="c1">/// distributions. It is equivalent that there exist r constants p1,...,pr,</span>
<span class="c1">/// such that</span>
<span class="c1">/// \f[</span>
<span class="c1">///\sum_{i=1}^{r} p_{i}=1</span>
<span class="c1">/// \f]</span>
<span class="c1">/// and the probability of belonging to the ith bin for some measured value</span>
<span class="c1">/// in both experiments is equal to pi. The number of events in the ith</span>
<span class="c1">/// bin is a random variable with a distribution approximated by a Poisson</span>
<span class="c1">/// probability distribution</span>
<span class="c1">/// \f[</span>
<span class="c1">///\frac{e^{-Np_{i}}(Np_{i})^{n_{i}}}{n_{i}!}</span>
<span class="c1">/// \f]</span>
<span class="c1">///for the first histogram and with distribution</span>
<span class="c1">/// \f[</span>
<span class="c1">///\frac{e^{-Mp_{i}}(Mp_{i})^{m_{i}}}{m_{i}!}</span>
<span class="c1">/// \f]</span>
<span class="c1">/// for the second histogram. If the hypothesis of homogeneity is valid,</span>
<span class="c1">/// then the  maximum likelihood estimator of pi, i=1,...,r, is</span>
<span class="c1">/// \f[</span>
<span class="c1">///\hat{p}_{i}= \frac{n_{i}+m_{i}}{N+M}</span>
<span class="c1">/// \f]</span>
<span class="c1">/// and then</span>
<span class="c1">/// \f[</span>
<span class="c1">///  X^{2} = \sum_{i=1}^{r}\frac{(n_{i}-N\hat{p}_{i})^{2}}{N\hat{p}_{i}} + \sum_{i=1}^{r}\frac{(m_{i}-M\hat{p}_{i})^{2}}{M\hat{p}_{i}} =\frac{1}{MN} \sum_{i=1}^{r}\frac{(Mn_{i}-Nm_{i})^{2}}{n_{i}+m_{i}}</span>
<span class="c1">/// \f]</span>
<span class="c1">/// has approximately a \f$ \chi^{2}_{(r-1)} \f$ distribution [3].</span>
<span class="c1">/// The comparison procedure can include an analysis of the residuals which</span>
<span class="c1">/// is often helpful in identifying the bins of histograms responsible for</span>
<span class="c1">/// a significant overall #chi^{2} value. Most convenient for</span>
<span class="c1">/// analysis are the adjusted (normalized) residuals [4]</span>
<span class="c1">/// \f[</span>
<span class="c1">///  r_{i} = \frac{n_{i}-N\hat{p}_{i}}{\sqrt{N\hat{p}_{i}}\sqrt{(1-N/(N+M))(1-(n_{i}+m_{i})/(N+M))}}</span>
<span class="c1">/// \f]</span>
<span class="c1">/// If hypotheses of  homogeneity are valid then residuals ri are</span>
<span class="c1">/// approximately independent and identically distributed random variables</span>
<span class="c1">/// having N(0,1) distribution. The application of the #chi^{2} test has</span>
<span class="c1">/// restrictions related to the value of the expected frequencies Npi,</span>
<span class="c1">/// Mpi, i=1,...,r. A conservative rule formulated in [5] is that all the</span>
<span class="c1">/// expectations must be 1 or greater for both histograms. In practical</span>
<span class="c1">/// cases when expected frequencies are not known the estimated expected</span>
<span class="c1">/// frequencies \f$ M\hat{p}_{i}, N\hat{p}_{i}, i=1,...,r \f$ can be used.</span>
<span class="c1">///  Unweighted and weighted histograms comparison:</span>
<span class="c1">/// A simple modification of the ideas described above can be used for the</span>
<span class="c1">/// comparison of the usual (unweighted) and weighted histograms. Let us</span>
<span class="c1">/// denote the number of events in the ith bin in the unweighted</span>
<span class="c1">/// histogram as ni and the common weight of events in the ith bin of the</span>
<span class="c1">/// weighted histogram as wi. The total number of events in the</span>
<span class="c1">/// unweighted histogram is equal to</span>
<span class="c1">///\f[</span>
<span class="c1">///  N = \sum_{i=1}^{r} n_{i}</span>
<span class="c1">///\f]</span>
<span class="c1">/// and the total weight of events in the weighted histogram is equal to</span>
<span class="c1">///\f[</span>
<span class="c1">///  W = \sum_{i=1}^{r} w_{i}</span>
<span class="c1">///\f]</span>
<span class="c1">/// Let us formulate the hypothesis of identity of an unweighted histogram</span>
<span class="c1">/// to a weighted histogram so that there exist r constants p1,...,pr, such</span>
<span class="c1">/// that</span>
<span class="c1">///\f[</span>
<span class="c1">///  \sum_{i=1}^{r} p_{i} = 1</span>
<span class="c1">///\f]</span>
<span class="c1">/// for the unweighted histogram. The weight wi is a random variable with a</span>
<span class="c1">/// distribution approximated by the normal probability distribution</span>
<span class="c1">/// \f$ N(Wp_{i},\sigma_{i}^{2}) \f$ where \f$ \sigma_{i}^{2} \f$ is the variance of the weight wi.</span>
<span class="c1">/// If we replace the variance \f$ \sigma_{i}^{2} \f$</span>
<span class="c1">/// with estimate \f$ s_{i}^{2} \f$ (sum of squares of weights of</span>
<span class="c1">/// events in the ith bin) and the hypothesis of identity is valid, then the</span>
<span class="c1">/// maximum likelihood estimator of  pi,i=1,...,r, is</span>
<span class="c1">///\f[</span>
<span class="c1">///  \hat{p}_{i} = \frac{Ww_{i}-Ns_{i}^{2}+\sqrt{(Ww_{i}-Ns_{i}^{2})^{2}+4W^{2}s_{i}^{2}n_{i}}}{2W^{2}}</span>
<span class="c1">///\f]</span>
<span class="c1">/// We may then use the test statistic</span>
<span class="c1">///\f[</span>
<span class="c1">///  X^{2} = \sum_{i=1}^{r} \frac{(n_{i}-N\hat{p}_{i})^{2}}{N\hat{p}_{i}} + \sum_{i=1}^{r} \frac{(w_{i}-W\hat{p}_{i})^{2}}{s_{i}^{2}}</span>
<span class="c1">///\f]</span>
<span class="c1">/// and it has approximately a \f$ \sigma^{2}_{(r-1)} \f$ distribution [2]. This test, as well</span>
<span class="c1">/// as the original one [3], has a restriction on the expected frequencies. The</span>
<span class="c1">/// expected frequencies recommended for the weighted histogram is more than 25.</span>
<span class="c1">/// The value of the minimal expected frequency can be decreased down to 10 for</span>
<span class="c1">/// the case when the weights of the events are close to constant. In the case</span>
<span class="c1">/// of a weighted histogram if the number of events is unknown, then we can</span>
<span class="c1">/// apply this recommendation for the equivalent number of events as</span>
<span class="c1">///\f[</span>
<span class="c1">///  n_{i}^{equiv} = \frac{ w_{i}^{2} }{ s_{i}^{2} }</span>
<span class="c1">///\f]</span>
<span class="c1">/// The minimal expected frequency for an unweighted histogram must be 1. Notice</span>
<span class="c1">/// that any usual (unweighted) histogram can be considered as a weighted</span>
<span class="c1">/// histogram with events that have constant weights equal to 1.</span>
<span class="c1">/// The variance \f$ z_{i}^{2} \f$ of the difference between the weight wi</span>
<span class="c1">/// and the estimated expectation value of the weight is approximately equal to:</span>
<span class="c1">///\f[</span>
<span class="c1">///  z_{i}^{2} = Var(w_{i}-W\hat{p}_{i}) = N\hat{p}_{i}(1-N\hat{p}_{i})\left(\frac{Ws_{i}^{2}}{\sqrt{(Ns_{i}^{2}-w_{i}W)^{2}+4W^{2}s_{i}^{2}n_{i}}}\right)^{2}+\frac{s_{i}^{2}}{4}\left(1+\frac{Ns_{i}^{2}-w_{i}W}{\sqrt{(Ns_{i}^{2}-w_{i}W)^{2}+4W^{2}s_{i}^{2}n_{i}}}\right)^{2}</span>
<span class="c1">///\f]</span>
<span class="c1">/// The  residuals</span>
<span class="c1">///\f[</span>
<span class="c1">///  r_{i} = \frac{w_{i}-W\hat{p}_{i}}{z_{i}}</span>
<span class="c1">///\f]</span>
<span class="c1">/// have approximately a normal distribution with mean equal to 0 and standard</span>
<span class="c1">/// deviation  equal to 1.</span>
<span class="c1">/// Two weighted histograms comparison:</span>
<span class="c1">/// Let us denote the common  weight of events of the ith bin in the first</span>
<span class="c1">/// histogram as w1i and as w2i in the second one. The total weight of events</span>
<span class="c1">/// in the first histogram is equal to</span>
<span class="c1">///\f[</span>
<span class="c1">///  W_{1} = \sum_{i=1}^{r} w_{1i}</span>
<span class="c1">///\f]</span>
<span class="c1">/// and</span>
<span class="c1">///\f[</span>
<span class="c1">///  W_{2} = \sum_{i=1}^{r} w_{2i}</span>
<span class="c1">///\f]</span>
<span class="c1">/// in the second histogram. Let us formulate the hypothesis of identity of</span>
<span class="c1">/// weighted histograms so that there exist r constants p1,...,pr, such that</span>
<span class="c1">///\f[</span>
<span class="c1">///  \sum_{i=1}^{r} p_{i} = 1</span>
<span class="c1">///\f]</span>
<span class="c1">/// and also expectation value of weight w1i equal to W1pi and expectation value</span>
<span class="c1">/// of weight w2i equal to W2pi. Weights in both the histograms are random</span>
<span class="c1">/// variables with distributions which can be approximated by a normal</span>
<span class="c1">/// probability distribution \f$ N(W_{1}p_{i},\sigma_{1i}^{2}) \f$ for the first histogram</span>
<span class="c1">/// and by a distribution \f$ N(W_{2}p_{i},\sigma_{2i}^{2}) \f$ for the second.</span>
<span class="c1">/// Here \f$ \sigma_{1i}^{2} \f$ and \f$ \sigma_{2i}^{2} \f$ are the variances</span>
<span class="c1">/// of w1i and w2i with estimators \f$ s_{1i}^{2} \f$ and \f$ s_{2i}^{2} \f$ respectively.</span>
<span class="c1">/// If the hypothesis of identity is valid, then the maximum likelihood and</span>
<span class="c1">/// Least Square Method estimator of pi,i=1,...,r, is</span>
<span class="c1">///\f[</span>
<span class="c1">///  \hat{p}_{i} = \frac{w_{1i}W_{1}/s_{1i}^{2}+w_{2i}W_{2} /s_{2i}^{2}}{W_{1}^{2}/s_{1i}^{2}+W_{2}^{2}/s_{2i}^{2}}</span>
<span class="c1">///\f]</span>
<span class="c1">/// We may then use the test statistic</span>
<span class="c1">///\f[</span>
<span class="c1">/// X^{2} = \sum_{i=1}^{r} \frac{(w_{1i}-W_{1}\hat{p}_{i})^{2}}{s_{1i}^{2}} + \sum_{i=1}^{r} \frac{(w_{2i}-W_{2}\hat{p}_{i})^{2}}{s_{2i}^{2}} = \sum_{i=1}^{r} \frac{(W_{1}w_{2i}-W_{2}w_{1i})^{2}}{W_{1}^{2}s_{2i}^{2}+W_{2}^{2}s_{1i}^{2}}</span>
<span class="c1">///\f]</span>
<span class="c1">/// and it has approximately a \f$ \chi^{2}_{(r-1)} \f$ distribution [2].</span>
<span class="c1">/// The normalized or studentised residuals [6]</span>
<span class="c1">///\f[</span>
<span class="c1">///  r_{i} = \frac{w_{1i}-W_{1}\hat{p}_{i}}{s_{1i}\sqrt{1 - \frac{1}{(1+W_{2}^{2}s_{1i}^{2}/W_{1}^{2}s_{2i}^{2})}}}</span>
<span class="c1">///\f]</span>
<span class="c1">/// have approximately a normal distribution with mean equal to 0 and standard</span>
<span class="c1">/// deviation 1. A recommended minimal expected frequency is equal to 10 for</span>
<span class="c1">/// the proposed test.</span>
<span class="c1">/// Numerical examples:</span>
<span class="c1">/// The method described herein is now illustrated with an example.</span>
<span class="c1">/// We take a distribution</span>
<span class="c1">///\f[</span>
<span class="c1">/// \phi(x) = \frac{2}{(x-10)^{2}+1} + \frac{1}{(x-14)^{2}+1}       (1)</span>
<span class="c1">///\f]</span>
<span class="c1">/// defined on the interval [4,16]. Events distributed according to the formula</span>
<span class="c1">/// (1) are simulated to create the unweighted histogram. Uniformly distributed</span>
<span class="c1">/// events are simulated for the weighted histogram with weights calculated by</span>
<span class="c1">/// formula (1). Each histogram has the same number of bins: 20. Fig.1 shows</span>
<span class="c1">/// the result of comparison of the unweighted histogram with 200 events</span>
<span class="c1">/// (minimal expected frequency equal to one) and the weighted histogram with</span>
<span class="c1">/// 500 events (minimal expected frequency equal to 25)</span>
<span class="c1">/// Begin_Macro</span>
<span class="c1">/// ../../../tutorials/math/chi2test.C</span>
<span class="c1">/// End_Macro</span>
<span class="c1">/// Fig 1. An example of comparison of the unweighted histogram with 200 events</span>
<span class="c1">/// and the weighted histogram with 500 events:</span>
<span class="c1">///   a) unweighted histogram;</span>
<span class="c1">///   b) weighted histogram;</span>
<span class="c1">///   c) normalized residuals plot;</span>
<span class="c1">///   d) normal Q-Q plot of residuals.</span>
<span class="c1">/// The value of the test statistic \f$ \chi^{2} \f$ is equal to</span>
<span class="c1">/// 21.09 with p-value equal to 0.33, therefore the hypothesis of identity of</span>
<span class="c1">/// the two histograms can be accepted for 0.05 significant level. The behavior</span>
<span class="c1">/// of the normalized residuals plot (see Fig. 1c) and the normal Q-Q plot</span>
<span class="c1">/// (see Fig. 1d) of residuals are regular and we cannot identify the outliers</span>
<span class="c1">/// or bins with a big influence on \f$ \chi^{2} \f$.</span>
<span class="c1">/// The second example presents the same two histograms but 17 events was added</span>
<span class="c1">/// to content of bin number 15 in unweighted histogram. Fig.2 shows the result</span>
<span class="c1">/// of comparison of the unweighted histogram with 217 events (minimal expected</span>
<span class="c1">/// frequency equal to one) and the weighted histogram with 500 events (minimal</span>
<span class="c1">/// expected frequency equal to 25)</span>
<span class="c1">///Begin_Macro</span>
<span class="c1">/// ../../../tutorials/math/chi2test.C(17)</span>
<span class="c1">///End_Macro</span>
<span class="c1">/// Fig 2. An example of comparison of the unweighted histogram with 217 events</span>
<span class="c1">/// and the weighted histogram with 500 events:</span>
<span class="c1">///   a) unweighted histogram;</span>
<span class="c1">///   b) weighted histogram;</span>
<span class="c1">///   c) normalized residuals plot;</span>
<span class="c1">///   d) normal Q-Q plot of residuals.</span>
<span class="c1">/// The value of the test statistic \f$ \chi^{2} \f$ is equal to</span>
<span class="c1">/// 32.33 with p-value equal to 0.029, therefore the hypothesis of identity of</span>
<span class="c1">/// the two histograms is rejected for 0.05 significant level. The behavior of</span>
<span class="c1">/// the normalized residuals plot (see Fig. 2c) and the normal Q-Q plot (see</span>
<span class="c1">/// Fig. 2d) of residuals are not regular and we can identify the outlier or</span>
<span class="c1">/// bin with a big influence on \f$ \chi^{2} \f$.</span>

   <span class="k">virtual</span> <span class="n">Double_t</span> <span class="nf">Chi2TestX</span><span class="p">(</span><span class="k">const</span> <span class="n">TH1</span><span class="o">*</span> <span class="n">h2</span><span class="p">,</span> <span class="n">Double_t</span> <span class="o">&amp;</span><span class="n">chi2</span><span class="p">,</span> <span class="n">Int_t</span> <span class="o">&amp;</span><span class="n">ndf</span><span class="p">,</span> <span class="n">Int_t</span> <span class="o">&amp;</span><span class="n">igood</span><span class="p">,</span><span class="n">Option_t</span> <span class="o">*</span><span class="n">option</span> <span class="o">=</span> <span class="s">&quot;UU&quot;</span><span class="p">,</span>  <span class="n">Double_t</span> <span class="o">*</span><span class="n">res</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
<span class="c1">/// The computation routine of the Chisquare test. For the method description,</span>
<span class="c1">/// see Chi2Test() function.</span>
<span class="c1">/// \return p-value</span>
<span class="c1">/// \param[in] h2 the second histogram</span>
<span class="c1">/// \param[in] option</span>
<span class="c1">///  - &quot;UU&quot; = experiment experiment comparison (unweighted-unweighted)</span>
<span class="c1">///  - &quot;UW&quot; = experiment MC comparison (unweighted-weighted). Note that the first</span>
<span class="c1">///        histogram should be unweighted</span>
<span class="c1">///  - &quot;WW&quot; = MC MC comparison (weighted-weighted)</span>
<span class="c1">///  - &quot;NORM&quot; = if one or both histograms is scaled</span>
<span class="c1">///  - &quot;OF&quot; = overflows included</span>
<span class="c1">///  - &quot;UF&quot; = underflows included</span>
<span class="c1">///      by default underflows and overflows are not included</span>
<span class="c1">/// \param[out] igood test output</span>
<span class="c1">///    - igood=0 - no problems</span>
<span class="c1">///    - For unweighted unweighted  comparison</span>
<span class="c1">///      - igood=1&#39;There is a bin in the 1st histogram with less than 1 event&#39;</span>
<span class="c1">///      - igood=2&#39;There is a bin in the 2nd histogram with less than 1 event&#39;</span>
<span class="c1">///      - igood=3&#39;when the conditions for igood=1 and igood=2 are satisfied&#39;</span>
<span class="c1">///    - For  unweighted weighted  comparison</span>
<span class="c1">///      - igood=1&#39;There is a bin in the 1st histogram with less then 1 event&#39;</span>
<span class="c1">///      - igood=2&#39;There is a bin in the 2nd histogram with less then 10 effective number of events&#39;</span>
<span class="c1">///      - igood=3&#39;when the conditions for igood=1 and igood=2 are satisfied&#39;</span>
<span class="c1">///    - For  weighted weighted  comparison</span>
<span class="c1">///      - igood=1&#39;There is a bin in the 1st  histogram with less then 10 effective</span>
<span class="c1">///        number of events&#39;</span>
<span class="c1">///      - igood=2&#39;There is a bin in the 2nd  histogram with less then 10 effective</span>
<span class="c1">///        number of events&#39;</span>
<span class="c1">///      - igood=3&#39;when the conditions for igood=1 and igood=2 are satisfied&#39;</span>
<span class="c1">/// \param[out] chi2 chisquare of the test</span>
<span class="c1">/// \param[out] ndf number of degrees of freedom (important, when both histograms have the same empty bins)</span>
<span class="c1">/// \param[out] res normalized residuals for further analysis</span>

   <span class="k">virtual</span> <span class="n">Double_t</span> <span class="nf">Chisquare</span><span class="p">(</span><span class="n">TF1</span> <span class="o">*</span> <span class="n">f1</span><span class="p">,</span> <span class="n">Option_t</span> <span class="o">*</span><span class="n">option</span> <span class="o">=</span> <span class="s">&quot;&quot;</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
<span class="c1">/// Compute and return the chisquare of this histogram with respect to a function</span>
<span class="c1">/// The chisquare is computed by weighting each histogram point by the bin error</span>
<span class="c1">/// By default the full range of the histogram is used.</span>
<span class="c1">/// Use option &quot;R&quot; for restricting the chisquare calculation to the given range of the function</span>

   <span class="k">virtual</span> <span class="kt">void</span>     <span class="nf">ClearUnderflowAndOverflow</span><span class="p">();</span>
<span class="c1">/// Remove all the content from the underflow and overflow bins, without changing the number of entries</span>
<span class="c1">/// After calling this method, every undeflow and overflow bins will have content 0.0</span>
<span class="c1">/// The Sumw2 is also cleared, since there is no more content in the bins</span>

   <span class="k">virtual</span> <span class="n">Double_t</span> <span class="nf">ComputeIntegral</span><span class="p">(</span><span class="n">Bool_t</span> <span class="n">onlyPositive</span> <span class="o">=</span> <span class="nb">false</span><span class="p">);</span>
<span class="c1">///  Compute integral (cumulative sum of bins)</span>
<span class="c1">///  The result stored in fIntegral is used by the GetRandom functions.</span>
<span class="c1">///  This function is automatically called by GetRandom when the fIntegral</span>
<span class="c1">///  array does not exist or when the number of entries in the histogram</span>
<span class="c1">///  has changed since the previous call to GetRandom.</span>
<span class="c1">///  The resulting integral is normalized to 1</span>
<span class="c1">///  If the routine is called with the onlyPositive flag set an error will</span>
<span class="c1">///  be produced in case of negative bin content and a NaN value returned</span>

   <span class="n">TObject</span><span class="o">*</span>         <span class="nf">Clone</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">newname</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span><span class="c1">//克隆直方图，这里的 Close 是新开辟一块内存空间存储新直方图的，克隆之后，原始直方图的修改或删除对克隆的直方图没有影响。而TH1D *hnew =h;这个只是将新建的对象指向 h 的地址。</span>
   <span class="k">virtual</span> <span class="kt">void</span>     <span class="nf">Copy</span><span class="p">(</span><span class="n">TObject</span> <span class="o">&amp;</span><span class="n">hnew</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span><span class="c1">/// Copy this to newth1</span>
<span class="c1">/// Copy this histogram structure to newth1.</span>
<span class="c1">/// Note that this function does not copy the list of associated functions.</span>
<span class="c1">/// Use TObject::Clone to make a full copy of an histogram.</span>
<span class="c1">/// Note also that the histogram it will be created in gDirectory (if AddDirectoryStatus()=true)</span>
<span class="c1">/// or will not be added to any directory if  AddDirectoryStatus()=false</span>
<span class="c1">/// independently of the current directory stored in the original histogram</span>

   <span class="k">virtual</span> <span class="kt">void</span>     <span class="nf">DirectoryAutoAdd</span><span class="p">(</span><span class="n">TDirectory</span> <span class="o">*</span><span class="p">);</span>
<span class="c1">/// Perform the automatic addition of the histogram to the given directory</span>
<span class="c1">/// Note this function is called in place when the semantic requires</span>
<span class="c1">/// this object to be added to a directory (I.e. when being read from</span>
<span class="c1">/// a TKey or being Cloned)</span>

   <span class="k">virtual</span> <span class="n">Int_t</span>    <span class="nf">DistancetoPrimitive</span><span class="p">(</span><span class="n">Int_t</span> <span class="n">px</span><span class="p">,</span> <span class="n">Int_t</span> <span class="n">py</span><span class="p">);</span>
<span class="c1">/// Compute distance from point px,py to a line.</span>
<span class="c1">///  Compute the closest distance of approach from point px,py to elements</span>
<span class="c1">///  of an histogram.</span>
<span class="c1">///  The distance is computed in pixels units.</span>
<span class="c1">///  Algorithm:</span>
<span class="c1">///  Currently, this simple model computes the distance from the mouse</span>
<span class="c1">///  to the histogram contour only.</span>

   <span class="k">virtual</span> <span class="n">Bool_t</span>   <span class="nf">Divide</span><span class="p">(</span><span class="n">TF1</span> <span class="o">*</span><span class="n">f1</span><span class="p">,</span> <span class="n">Double_t</span> <span class="n">c1</span><span class="o">=</span><span class="mi">1</span><span class="p">);</span>
<span class="c1">/// Performs the operation: this = this/(c1*f1)</span>
<span class="c1">/// if errors are defined (see TH1::Sumw2), errors are also recalculated.</span>
<span class="c1">/// Only bins inside the function range are recomputed.</span>
<span class="c1">/// IMPORTANT NOTE: If you intend to use the errors of this histogram later</span>
<span class="c1">/// you should call Sumw2 before making this operation.</span>
<span class="c1">/// This is particularly important if you fit the histogram after TH1::Divide</span>
<span class="c1">/// The function return kFALSE if the divide operation failed</span>

   <span class="k">virtual</span> <span class="n">Bool_t</span>   <span class="nf">Divide</span><span class="p">(</span><span class="k">const</span> <span class="n">TH1</span> <span class="o">*</span><span class="n">h1</span><span class="p">);</span>
<span class="c1">/// Divide this histogram by h1.</span>
<span class="c1">/// this = this/h1</span>
<span class="c1">/// if errors are defined (see TH1::Sumw2), errors are also recalculated.</span>
<span class="c1">/// Note that if h1 has Sumw2 set, Sumw2 is automatically called for this</span>
<span class="c1">/// if not already set.</span>
<span class="c1">/// The resulting errors are calculated assuming uncorrelated histograms.</span>
<span class="c1">/// See the other TH1::Divide that gives the possibility to optionally</span>
<span class="c1">/// compute binomial errors.</span>
<span class="c1">/// IMPORTANT NOTE: If you intend to use the errors of this histogram later</span>
<span class="c1">/// you should call Sumw2 before making this operation.</span>
<span class="c1">/// This is particularly important if you fit the histogram after TH1::Scale</span>
<span class="c1">/// The function return kFALSE if the divide operation failed</span>

   <span class="k">virtual</span> <span class="n">Bool_t</span>   <span class="nf">Divide</span><span class="p">(</span><span class="k">const</span> <span class="n">TH1</span> <span class="o">*</span><span class="n">h1</span><span class="p">,</span> <span class="k">const</span> <span class="n">TH1</span> <span class="o">*</span><span class="n">h2</span><span class="p">,</span> <span class="n">Double_t</span> <span class="n">c1</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">Double_t</span> <span class="n">c2</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">Option_t</span> <span class="o">*</span><span class="n">option</span><span class="o">=</span><span class="s">&quot;&quot;</span><span class="p">);</span> <span class="c1">// *MENU*</span>
<span class="c1">/// Replace contents of this histogram by the division of h1 by h2.</span>
<span class="c1">///  this = c1*h1/(c2*h2)</span>
<span class="c1">/// If errors are defined (see TH1::Sumw2), errors are also recalculated</span>
<span class="c1">/// Note that if h1 or h2 have Sumw2 set, Sumw2 is automatically called for this</span>
<span class="c1">/// if not already set.</span>
<span class="c1">/// The resulting errors are calculated assuming uncorrelated histograms.</span>
<span class="c1">/// However, if option =&quot;B&quot; is specified, Binomial errors are computed.</span>
<span class="c1">/// In this case c1 and c2 do not make real sense and they are ignored.</span>
<span class="c1">/// IMPORTANT NOTE: If you intend to use the errors of this histogram later</span>
<span class="c1">/// you should call Sumw2 before making this operation.</span>
<span class="c1">/// This is particularly important if you fit the histogram after TH1::Divide</span>
<span class="c1">///  Please note also that in the binomial case errors are calculated using standard</span>
<span class="c1">///  binomial statistics, which means when b1 = b2, the error is zero.</span>
<span class="c1">///  If you prefer to have efficiency errors not going to zero when the efficiency is 1, you must</span>
<span class="c1">///  use the function TGraphAsymmErrors::BayesDivide, which will return an asymmetric and non-zero lower</span>
<span class="c1">///  error for the case b1=b2.</span>
<span class="c1">/// The function return kFALSE if the divide operation failed</span>

   <span class="k">virtual</span> <span class="kt">void</span>     <span class="nf">Draw</span><span class="p">(</span><span class="n">Option_t</span> <span class="o">*</span><span class="n">option</span><span class="o">=</span><span class="s">&quot;&quot;</span><span class="p">);</span><span class="c1">//画图</span>
<span class="c1">/// Draw this histogram with options.</span>
<span class="c1">/// Histograms are drawn via the THistPainter class. Each histogram has</span>
<span class="c1">/// a pointer to its own painter (to be usable in a multithreaded program).</span>
<span class="c1">/// The same histogram can be drawn with different options in different pads.</span>
<span class="c1">/// When an histogram drawn in a pad is deleted, the histogram is</span>
<span class="c1">/// automatically removed from the pad or pads where it was drawn.</span>
<span class="c1">/// If an histogram is drawn in a pad, then filled again, the new status</span>
<span class="c1">/// of the histogram will be automatically shown in the pad next time</span>
<span class="c1">/// the pad is updated. One does not need to redraw the histogram.</span>
<span class="c1">/// To draw the current version of an histogram in a pad, one can use</span>
<span class="c1">///   h-&gt;DrawCopy();</span>
<span class="c1">/// This makes a clone of the histogram. Once the clone is drawn, the original</span>
<span class="c1">/// histogram may be modified or deleted without affecting the aspect of the</span>
<span class="c1">/// clone.</span>
<span class="c1">/// By default, TH1::Draw clears the current pad.</span>
<span class="c1">/// One can use TH1::SetMaximum and TH1::SetMinimum to force a particular</span>
<span class="c1">/// value for the maximum or the minimum scale on the plot.</span>
<span class="c1">/// TH1::UseCurrentStyle can be used to change all histogram graphics</span>
<span class="c1">/// attributes to correspond to the current selected style.</span>
<span class="c1">/// This function must be called for each histogram.</span>
<span class="c1">/// In case one reads and draws many histograms from a file, one can force</span>
<span class="c1">/// the histograms to inherit automatically the current graphics style</span>
<span class="c1">/// by calling before gROOT-&gt;ForceStyle();</span>
<span class="c1">/// See the THistPainter class for a description of all the drawing options.</span>

   <span class="k">virtual</span> <span class="n">TH1</span>     <span class="o">*</span><span class="nf">DrawCopy</span><span class="p">(</span><span class="n">Option_t</span> <span class="o">*</span><span class="n">option</span><span class="o">=</span><span class="s">&quot;&quot;</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span> <span class="n">name_postfix</span> <span class="o">=</span> <span class="s">&quot;_copy&quot;</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
<span class="c1">/// Copy this histogram and Draw in the current pad.</span>
<span class="c1">/// Once the histogram is drawn into the pad, any further modification</span>
<span class="c1">/// using graphics input will be made on the copy of the histogram,</span>
<span class="c1">/// and not to the original object.</span>
<span class="c1">/// By default a postfix &quot;_copy&quot; is added to the histogram name. Pass an empty postfix in case</span>
<span class="c1">/// you want to draw an histogram with the same name</span>
<span class="c1">/// See Draw for the list of options</span>

   <span class="k">virtual</span> <span class="n">TH1</span>     <span class="o">*</span><span class="nf">DrawNormalized</span><span class="p">(</span><span class="n">Option_t</span> <span class="o">*</span><span class="n">option</span><span class="o">=</span><span class="s">&quot;&quot;</span><span class="p">,</span> <span class="n">Double_t</span> <span class="n">norm</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
<span class="c1">///  Draw a normalized copy of this histogram.</span>
<span class="c1">///  A clone of this histogram is normalized to norm and drawn with option.</span>
<span class="c1">///  A pointer to the normalized histogram is returned.</span>
<span class="c1">///  The contents of the histogram copy are scaled such that the new</span>
<span class="c1">///  sum of weights (excluding under and overflow) is equal to norm.</span>
<span class="c1">///  Note that the returned normalized histogram is not added to the list</span>
<span class="c1">///  of histograms in the current directory in memory.</span>
<span class="c1">///  It is the user&#39;s responsability to delete this histogram.</span>
<span class="c1">///  The kCanDelete bit is set for the returned object. If a pad containing</span>
<span class="c1">///  this copy is cleared, the histogram will be automatically deleted.</span>
<span class="c1">///  See Draw for the list of options</span>

   <span class="k">virtual</span> <span class="kt">void</span>     <span class="nf">DrawPanel</span><span class="p">();</span> <span class="c1">// *MENU*    Display a panel with all histogram drawing options.    See class TDrawPanelHist for example</span>
   <span class="k">virtual</span> <span class="n">Int_t</span>    <span class="nf">BufferEmpty</span><span class="p">(</span><span class="n">Int_t</span> <span class="n">action</span><span class="o">=</span><span class="mi">0</span><span class="p">);</span>
<span class="c1">/// Fill histogram with all entries in the buffer.</span>
<span class="c1">/// action = -1 histogram is reset and refilled from the buffer (called by THistPainter::Paint)</span>
<span class="c1">/// action =  0 histogram is reset and filled from the buffer. When the histogram is filled from the</span>
<span class="c1">///         buffer the value fBuffer[0] is set to a negative number (= - number of entries)</span>
<span class="c1">///         When calling with action == 0 the histogram is NOT refilled when fBuffer[0] is &lt; 0</span>
<span class="c1">///         While when calling with action = -1 the histogram is reset and ALWAYS refilled independently if</span>
<span class="c1">///         the histogram was filled before. This is needed when drawing the histogram</span>
<span class="c1">/// action =  1 histogram is filled and buffer is deleted</span>
<span class="c1">///         The buffer is automatically deleted when filling the histogram and the entries is</span>
<span class="c1">///         larger than the buffer size</span>

   <span class="k">virtual</span> <span class="kt">void</span>     <span class="nf">Eval</span><span class="p">(</span><span class="n">TF1</span> <span class="o">*</span><span class="n">f1</span><span class="p">,</span> <span class="n">Option_t</span> <span class="o">*</span><span class="n">option</span><span class="o">=</span><span class="s">&quot;&quot;</span><span class="p">);</span>
<span class="c1">/// Evaluate function f1 at the center of bins of this histogram.</span>
<span class="c1">/// If option &quot;R&quot; is specified, the function is evaluated only</span>
<span class="c1">/// for the bins included in the function range.</span>
<span class="c1">/// If option &quot;A&quot; is specified, the value of the function is added to the</span>
<span class="c1">/// existing bin contents</span>
<span class="c1">/// If option &quot;S&quot; is specified, the value of the function is used to</span>
<span class="c1">/// generate a value, distributed according to the Poisson</span>
<span class="c1">/// distribution, with f1 as the mean.</span>

   <span class="k">virtual</span> <span class="kt">void</span>     <span class="nf">ExecuteEvent</span><span class="p">(</span><span class="n">Int_t</span> <span class="n">event</span><span class="p">,</span> <span class="n">Int_t</span> <span class="n">px</span><span class="p">,</span> <span class="n">Int_t</span> <span class="n">py</span><span class="p">);</span>
<span class="c1">/// Execute action corresponding to one event.</span>
<span class="c1">/// This member function is called when a histogram is clicked with the locator</span>
<span class="c1">/// If Left button clicked on the bin top value, then the content of this bin</span>
<span class="c1">/// is modified according to the new position of the mouse when it is released.</span>

   <span class="k">virtual</span> <span class="kt">void</span>     <span class="nf">ExtendAxis</span><span class="p">(</span><span class="n">Double_t</span> <span class="n">x</span><span class="p">,</span> <span class="n">TAxis</span> <span class="o">*</span><span class="n">axis</span><span class="p">);</span>
<span class="c1">/// Histogram is resized along axis such that x is in the axis range.</span>
<span class="c1">/// The new axis limits are recomputed by doubling iteratively</span>
<span class="c1">/// the current axis range until the specified value x is within the limits.</span>
<span class="c1">/// The algorithm makes a copy of the histogram, then loops on all bins</span>
<span class="c1">/// of the old histogram to fill the extended histogram.</span>
<span class="c1">/// Takes into account errors (Sumw2) if any.</span>
<span class="c1">/// The algorithm works for 1-d, 2-D and 3-D histograms.</span>
<span class="c1">/// The axis must be extendable before invoking this function.</span>
<span class="c1">/// Ex: h-&gt;GetXaxis()-&gt;SetCanExtend(kTRUE);</span>

   <span class="k">virtual</span> <span class="n">TH1</span>     <span class="o">*</span><span class="nf">FFT</span><span class="p">(</span><span class="n">TH1</span><span class="o">*</span> <span class="n">h_output</span><span class="p">,</span> <span class="n">Option_t</span> <span class="o">*</span><span class="n">option</span><span class="p">);</span>
<span class="c1">/// This function allows to do discrete Fourier transforms of TH1 and TH2.</span>
<span class="c1">/// Available transform types and flags are described below.</span>
<span class="c1">/// To extract more information about the transform, use the function</span>
<span class="c1">/// TVirtualFFT::GetCurrentTransform() to get a pointer to the current transform object.</span>
<span class="c1">/// \param[out] h_output histogram for the output. If a null pointer is passed, a new histogram is created</span>
<span class="c1">///          and returned, otherwise, the provided histogram is used and should be big enough</span>
<span class="c1">/// \param[in] option option parameters consists of 3 parts:</span>
<span class="c1">/// - option on what to return</span>
<span class="c1">///   - &quot;RE&quot; - returns a histogram of the real part of the output</span>
<span class="c1">///   - &quot;IM&quot; - returns a histogram of the imaginary part of the output</span>
<span class="c1">///   - &quot;MAG&quot;- returns a histogram of the magnitude of the output</span>
<span class="c1">///   - &quot;PH&quot; - returns a histogram of the phase of the output</span>
<span class="c1">/// - option of transform type</span>
<span class="c1">///   - &quot;R2C&quot;  - real to complex transforms - default</span>
<span class="c1">///   - &quot;R2HC&quot; - real to halfcomplex (special format of storing output data,</span>
<span class="c1">///     results the same as for R2C)</span>
<span class="c1">///   - &quot;DHT&quot; - discrete Hartley transform</span>
<span class="c1">///     real to real transforms (sine and cosine):</span>
<span class="c1">///   - &quot;R2R_0&quot;, &quot;R2R_1&quot;, &quot;R2R_2&quot;, &quot;R2R_3&quot; - discrete cosine transforms of types I-IV</span>
<span class="c1">///   - &quot;R2R_4&quot;, &quot;R2R_5&quot;, &quot;R2R_6&quot;, &quot;R2R_7&quot; - discrete sine transforms of types I-IV</span>
<span class="c1">///     To specify the type of each dimension of a 2-dimensional real to real</span>
<span class="c1">///     transform, use options of form &quot;R2R_XX&quot;, for example, &quot;R2R_02&quot; for a transform,</span>
<span class="c1">///     which is of type &quot;R2R_0&quot; in 1st dimension and  &quot;R2R_2&quot; in the 2nd.</span>
<span class="c1">/// - option of transform flag</span>
<span class="c1">///   - &quot;ES&quot; (from &quot;estimate&quot;) - no time in preparing the transform, but probably sub-optimal</span>
<span class="c1">///     performance</span>
<span class="c1">///   - &quot;M&quot; (from &quot;measure&quot;)   - some time spend in finding the optimal way to do the transform</span>
<span class="c1">///   - &quot;P&quot; (from &quot;patient&quot;)   - more time spend in finding the optimal way to do the transform</span>
<span class="c1">///   - &quot;EX&quot; (from &quot;exhaustive&quot;) - the most optimal way is found</span>
<span class="c1">///     This option should be chosen depending on how many transforms of the same size and</span>
<span class="c1">///     type are going to be done. Planning is only done once, for the first transform of this</span>
<span class="c1">///     size and type. Default is &quot;ES&quot;.</span>
<span class="c1">/// Examples of valid options: &quot;Mag R2C M&quot; &quot;Re R2R_11&quot; &quot;Im R2C ES&quot; &quot;PH R2HC EX&quot;</span>

   <span class="k">virtual</span> <span class="n">Int_t</span>    <span class="nf">Fill</span><span class="p">(</span><span class="n">Double_t</span> <span class="n">x</span><span class="p">);</span><span class="c1">//将数据填充进直方图</span>
<span class="c1">/// Increment bin with abscissa X by 1.</span>
<span class="c1">/// if x is less than the low-edge of the first bin, the Underflow bin is incremented</span>
<span class="c1">/// if x is greater than the upper edge of last bin, the Overflow bin is incremented</span>
<span class="c1">/// If the storage of the sum of squares of weights has been triggered,</span>
<span class="c1">/// via the function Sumw2, then the sum of the squares of weights is incremented</span>
<span class="c1">/// by 1 in the bin corresponding to x.</span>
<span class="c1">/// The function returns the corresponding bin number which has its content incremented by 1</span>

   <span class="k">virtual</span> <span class="n">Int_t</span>    <span class="nf">Fill</span><span class="p">(</span><span class="n">Double_t</span> <span class="n">x</span><span class="p">,</span> <span class="n">Double_t</span> <span class="n">w</span><span class="p">);</span>
<span class="c1">/// Increment bin with abscissa X with a weight w.</span>
<span class="c1">/// if x is less than the low-edge of the first bin, the Underflow bin is incremented</span>
<span class="c1">/// if x is greater than the upper edge of last bin, the Overflow bin is incremented</span>
<span class="c1">/// If the weight is not equal to 1, the storage of the sum of squares of</span>
<span class="c1">/// weights is automatically triggered and the sum of the squares of weights is incremented</span>
<span class="c1">/// by w^2 in the bin corresponding to x.</span>
<span class="c1">/// The function returns the corresponding bin number which has its content incremented by w</span>

   <span class="k">virtual</span> <span class="n">Int_t</span>    <span class="nf">Fill</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span> <span class="n">Double_t</span> <span class="n">w</span><span class="p">);</span>
<span class="c1">/// Increment bin with namex with a weight w</span>
<span class="c1">/// if x is less than the low-edge of the first bin, the Underflow bin is incremented</span>
<span class="c1">/// if x is greater than the upper edge of last bin, the Overflow bin is incremented</span>
<span class="c1">/// If the weight is not equal to 1, the storage of the sum of squares of</span>
<span class="c1">/// weights is automatically triggered and the sum of the squares of weights is incremented</span>
<span class="c1">/// by w^2 in the bin corresponding to x.</span>
<span class="c1">/// The function returns the corresponding bin number which has its content incremented by w</span>

   <span class="k">virtual</span> <span class="kt">void</span>     <span class="nf">FillN</span><span class="p">(</span><span class="n">Int_t</span> <span class="n">ntimes</span><span class="p">,</span> <span class="k">const</span> <span class="n">Double_t</span> <span class="o">*</span><span class="n">x</span><span class="p">,</span> <span class="k">const</span> <span class="n">Double_t</span> <span class="o">*</span><span class="n">w</span><span class="p">,</span> <span class="n">Int_t</span> <span class="n">stride</span><span class="o">=</span><span class="mi">1</span><span class="p">);</span>
<span class="c1">/// Fill this histogram with an array x and weights w.</span>
<span class="c1">/// \param[in] ntimes number of entries in arrays x and w (array size must be ntimes*stride)</span>
<span class="c1">/// \param[in] x array of values to be histogrammed</span>
<span class="c1">/// \param[in[ w array of weighs</span>
<span class="c1">/// \param[in] stride step size through arrays x and w</span>
<span class="c1">/// If the weight is not equal to 1, the storage of the sum of squares of</span>
<span class="c1">/// weights is automatically triggered and the sum of the squares of weights is incremented</span>
<span class="c1">/// y w^2 in the bin corresponding to x.</span>
<span class="c1">/// if w is NULL each entry is assumed a weight=1</span>

   <span class="k">virtual</span> <span class="kt">void</span>     <span class="nf">FillN</span><span class="p">(</span><span class="n">Int_t</span><span class="p">,</span> <span class="k">const</span> <span class="n">Double_t</span> <span class="o">*</span><span class="p">,</span> <span class="k">const</span> <span class="n">Double_t</span> <span class="o">*</span><span class="p">,</span> <span class="k">const</span> <span class="n">Double_t</span> <span class="o">*</span><span class="p">,</span> <span class="n">Int_t</span><span class="p">)</span> <span class="p">{;}</span>
   <span class="k">virtual</span> <span class="kt">void</span>     <span class="nf">FillRandom</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">fname</span><span class="p">,</span> <span class="n">Int_t</span> <span class="n">ntimes</span><span class="o">=</span><span class="mi">5000</span><span class="p">);</span>
<span class="c1">/// Fill histogram following distribution in function fname.</span>
<span class="c1">/// The distribution contained in the function fname (TF1) is integrated</span>
<span class="c1">/// over the channel contents for the bin range of this histogram.</span>
<span class="c1">/// It is normalized to 1.</span>
<span class="c1">/// Getting one random number implies:</span>
<span class="c1">/// - Generating a random number between 0 and 1 (say r1)</span>
<span class="c1">/// - Look in which bin in the normalized integral r1 corresponds to</span>
<span class="c1">/// - Fill histogram channel</span>
<span class="c1">///   ntimes random numbers are generated</span>
<span class="c1">/// One can also call TF1::GetRandom to get a random variate from a function.</span>

   <span class="k">virtual</span> <span class="kt">void</span>     <span class="nf">FillRandom</span><span class="p">(</span><span class="n">TH1</span> <span class="o">*</span><span class="n">h</span><span class="p">,</span> <span class="n">Int_t</span> <span class="n">ntimes</span><span class="o">=</span><span class="mi">5000</span><span class="p">);</span>
<span class="c1">/// Fill histogram following distribution in histogram h.</span>
<span class="c1">/// The distribution contained in the histogram h (TH1) is integrated</span>
<span class="c1">/// over the channel contents for the bin range of this histogram.</span>
<span class="c1">/// It is normalized to 1.</span>
<span class="c1">/// Getting one random number implies:</span>
<span class="c1">/// - Generating a random number between 0 and 1 (say r1)</span>
<span class="c1">/// - Look in which bin in the normalized integral r1 corresponds to</span>
<span class="c1">/// - Fill histogram channel ntimes random numbers are generated</span>
<span class="c1">/// SPECIAL CASE when the target histogram has the same binning as the source.</span>
<span class="c1">/// in this case we simply use a poisson distribution where</span>
<span class="c1">/// the mean value per bin = bincontent/integral.</span>

   <span class="k">virtual</span> <span class="n">Int_t</span>    <span class="nf">FindBin</span><span class="p">(</span><span class="n">Double_t</span> <span class="n">x</span><span class="p">,</span> <span class="n">Double_t</span> <span class="n">y</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">Double_t</span> <span class="n">z</span><span class="o">=</span><span class="mi">0</span><span class="p">);</span><span class="c1">//寻找x值对应的bin数 对一维直方图，返回 x 值所在 bin，若为二维直方图，返回 （x，y） 所在 bin，三维同理。</span>
<span class="c1">/// Return Global bin number corresponding to x,y,z</span>
<span class="c1">/// 2-D and 3-D histograms are represented with a one dimensional</span>
<span class="c1">/// structure. This has the advantage that all existing functions, such as</span>
<span class="c1">/// GetBinContent, GetBinError, GetBinFunction work for all dimensions.</span>
<span class="c1">/// This function tries to extend the axis if the given point belongs to an</span>
<span class="c1">///  under-/overflow bin AND if CanExtendAllAxes() is true.</span>
<span class="c1">/// See also TH1::GetBin, TAxis::FindBin and TAxis::FindFixBin</span>

   <span class="k">virtual</span> <span class="n">Int_t</span>    <span class="nf">FindFixBin</span><span class="p">(</span><span class="n">Double_t</span> <span class="n">x</span><span class="p">,</span> <span class="n">Double_t</span> <span class="n">y</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">Double_t</span> <span class="n">z</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
<span class="c1">/// Return Global bin number corresponding to x,y,z.</span>
<span class="c1">/// 2-D and 3-D histograms are represented with a one dimensional</span>
<span class="c1">/// structure. This has the advantage that all existing functions, such as</span>
<span class="c1">/// GetBinContent, GetBinError, GetBinFunction work for all dimensions.</span>
<span class="c1">/// This function DOES NOT try to extend the axis if the given point belongs</span>
<span class="c1">/// to an under-/overflow bin.</span>
<span class="c1">/// See also TH1::GetBin, TAxis::FindBin and TAxis::FindFixBin</span>

   <span class="k">virtual</span> <span class="n">Int_t</span>    <span class="nf">FindFirstBinAbove</span><span class="p">(</span><span class="n">Double_t</span> <span class="n">threshold</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">Int_t</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
<span class="c1">/// Find first bin with content &gt; threshold for axis (1=x, 2=y, 3=z)</span>
<span class="c1">/// if no bins with content &gt; threshold is found the function returns -1.</span>

   <span class="k">virtual</span> <span class="n">Int_t</span>    <span class="nf">FindLastBinAbove</span> <span class="p">(</span><span class="n">Double_t</span> <span class="n">threshold</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">Int_t</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
<span class="c1">/// Find last bin with content &gt; threshold for axis (1=x, 2=y, 3=z)</span>
<span class="c1">/// if no bins with content &gt; threshold is found the function returns -1.</span>

   <span class="k">virtual</span> <span class="n">TObject</span> <span class="o">*</span><span class="nf">FindObject</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span><span class="c1">/// search object named name in the list of functions</span>
   <span class="k">virtual</span> <span class="n">TObject</span> <span class="o">*</span><span class="nf">FindObject</span><span class="p">(</span><span class="k">const</span> <span class="n">TObject</span> <span class="o">*</span><span class="n">obj</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span><span class="c1">/// search object obj in the list of functions</span>
   <span class="k">virtual</span> <span class="n">TFitResultPtr</span>    <span class="nf">Fit</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">formula</span> <span class="p">,</span><span class="n">Option_t</span> <span class="o">*</span><span class="n">option</span><span class="o">=</span><span class="s">&quot;&quot;</span> <span class="p">,</span><span class="n">Option_t</span> <span class="o">*</span><span class="n">goption</span><span class="o">=</span><span class="s">&quot;&quot;</span><span class="p">,</span> <span class="n">Double_t</span> <span class="n">xmin</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">Double_t</span> <span class="n">xmax</span><span class="o">=</span><span class="mi">0</span><span class="p">);</span> <span class="c1">// *MENU*</span>
<span class="c1">/// Fit histogram with function fname.</span>
<span class="c1">/// fname is the name of an already predefined function created by TF1 or TF2</span>
<span class="c1">/// Predefined functions such as gaus, expo and poln are automatically</span>
<span class="c1">/// created by ROOT.</span>
<span class="c1">/// fname can also be a formula, accepted by the linear fitter (linear parts divided</span>
<span class="c1">/// by &quot;++&quot; sign), for example &quot;x++sin(x)&quot; for fitting &quot;[0]*x+[1]*sin(x)&quot;</span>
<span class="c1">///  This function finds a pointer to the TF1 object with name fname</span>
<span class="c1">///  and calls TH1::Fit(TF1 *f1,...)</span>

   <span class="k">virtual</span> <span class="n">TFitResultPtr</span>    <span class="nf">Fit</span><span class="p">(</span><span class="n">TF1</span> <span class="o">*</span><span class="n">f1</span> <span class="p">,</span><span class="n">Option_t</span> <span class="o">*</span><span class="n">option</span><span class="o">=</span><span class="s">&quot;&quot;</span> <span class="p">,</span><span class="n">Option_t</span> <span class="o">*</span><span class="n">goption</span><span class="o">=</span><span class="s">&quot;&quot;</span><span class="p">,</span> <span class="n">Double_t</span> <span class="n">xmin</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">Double_t</span> <span class="n">xmax</span><span class="o">=</span><span class="mi">0</span><span class="p">);</span>
<span class="c1">/// Fit histogram with function f1.</span>
<span class="c1">/// \param[in] option fit options is given in parameter option.</span>
<span class="c1">///        - &quot;W&quot;  Set all weights to 1 for non empty bins; ignore error bars</span>
<span class="c1">///        - &quot;WW&quot; Set all weights to 1 including empty bins; ignore error bars</span>
<span class="c1">///        - &quot;I&quot;  Use integral of function in bin, normalized by the bin volume,</span>
<span class="c1">///          instead of value at bin center</span>
<span class="c1">///        -  &quot;L&quot;  Use Loglikelihood method (default is chisquare method)</span>
<span class="c1">///        - &quot;WL&quot; Use Loglikelihood method and bin contents are not integer,</span>
<span class="c1">///          i.e. histogram is weighted (must have Sumw2() set)</span>
<span class="c1">///        - &quot;P&quot;  Use Pearson chi2 (using expected errors instead of observed errors)</span>
<span class="c1">///        - &quot;U&quot;  Use a User specified fitting algorithm (via SetFCN)</span>
<span class="c1">///        - &quot;Q&quot;  Quiet mode (minimum printing)</span>
<span class="c1">///        - &quot;V&quot;  Verbose mode (default is between Q and V)</span>
<span class="c1">///        - &quot;E&quot;  Perform better Errors estimation using Minos technique</span>
<span class="c1">///        - &quot;B&quot;  User defined parameter settings are used for predefined functions</span>
<span class="c1">///          like &quot;gaus&quot;, &quot;expo&quot;, &quot;poln&quot;, &quot;landau&quot;.</span>
<span class="c1">///          Use this option when you want to fix one or more parameters for these functions.</span>
<span class="c1">///        - &quot;M&quot;  More. Improve fit results.</span>
<span class="c1">///          It uses the IMPROVE command of TMinuit (see TMinuit::mnimpr).</span>
<span class="c1">///          This algorithm attempts to improve the found local minimum by searching for a</span>
<span class="c1">///          better one.</span>
<span class="c1">///        - &quot;R&quot;  Use the Range specified in the function range</span>
<span class="c1">///        - &quot;N&quot;  Do not store the graphics function, do not draw</span>
<span class="c1">///        - &quot;0&quot;  Do not plot the result of the fit. By default the fitted function</span>
<span class="c1">///          is drawn unless the option&quot;N&quot; above is specified.</span>
<span class="c1">///        - &quot;+&quot;  Add this new fitted function to the list of fitted functions</span>
<span class="c1">///          (by default, any previous function is deleted)</span>
<span class="c1">///        - &quot;C&quot;  In case of linear fitting, don&#39;t calculate the chisquare</span>
<span class="c1">///          (saves time)</span>
<span class="c1">///        - &quot;F&quot;  If fitting a polN, switch to minuit fitter</span>
<span class="c1">///        - &quot;S&quot;  The result of the fit is returned in the TFitResultPtr</span>
<span class="c1">///          (see below Access to the Fit Result)</span>
<span class="c1">/// \param[in] goption specify a list of graphics options. See TH1::Draw for a complete list of these options.</span>
<span class="c1">/// \param[in] xxmin range</span>
<span class="c1">/// \param[in] xxmax range</span>
<span class="c1">/// ## Setting initial conditions</span>
<span class="c1">/// Parameters must be initialized before invoking the Fit function.</span>
<span class="c1">/// The setting of the parameter initial values is automatic for the</span>
<span class="c1">/// predefined functions : poln, expo, gaus, landau. One can however disable</span>
<span class="c1">/// this automatic computation by specifying the option &quot;B&quot;.</span>
<span class="c1">/// Note that if a predefined function is defined with an argument,</span>
<span class="c1">/// eg, gaus(0), expo(1), you must specify the initial values for</span>
<span class="c1">/// the parameters.</span>
<span class="c1">/// Note that option &quot;I&quot; gives better results but is slower.</span>
<span class="c1">/// ## Changing the fitting objective function</span>
<span class="c1">/// By default a chi square function is used for fitting. When option &quot;L&quot; (or &quot;LL&quot;) is used</span>
<span class="c1">/// a Poisson likelihood function (see note below) is used.</span>
<span class="c1">/// The functions are defined in the header Fit/Chi2Func.h or Fit/PoissonLikelihoodFCN and they</span>
<span class="c1">/// are implemented using the routines FitUtil::EvaluateChi2 or FitUtil::EvaluatePoissonLogL in</span>
<span class="c1">/// the file math/mathcore/src/FitUtil.cxx.</span>
<span class="c1">/// To specify a User defined fitting function, specify option &quot;U&quot; and</span>
<span class="c1">/// call the following functions:</span>
<span class="c1">///      TVirtualFitter::Fitter(myhist)-&gt;SetFCN(MyFittingFunction)</span>
<span class="c1">/// where MyFittingFunction is of type:</span>
<span class="c1">///      extern void MyFittingFunction(Int_t &amp;npar, Double_t *gin, Double_t &amp;f, Double_t *u, Int_t flag);</span>
<span class="c1">/// ## Chi2 Fits</span>
<span class="c1">/// By default a chi2 (least-square) fit is performed on the histogram. The so-called modified least-square method</span>
<span class="c1">/// is used where the residual for each bin is computed using as error the observed value (the bin error)</span>
<span class="c1">///      Chi2 = Sum{ ( y(i) - f (x(i) | p )/ e(i) )^2 }</span>
<span class="c1">/// where y(i) is the bin content for each bin i, x(i) is the bin center and e(i) is the bin error (sqrt(y(i) for</span>
<span class="c1">/// an un-weighted histogram. Bins with zero errors are excluded from the fit. See also later the note on the treatment of empty bins.</span>
<span class="c1">/// When using option &quot;I&quot; the residual is computed not using the function value at the bin center, f (x(i) | p), but the integral</span>
<span class="c1">/// of the function in the bin,   Integral{ f(x|p)dx } divided by the bin volume</span>
<span class="c1">/// ## Likelihood Fits</span>
<span class="c1">/// When using option &quot;L&quot; a likelihood fit is used instead of the default chi2 square fit.</span>
<span class="c1">/// The likelihood is built assuming a Poisson probability density function for each bin.</span>
<span class="c1">/// The negative log-likelihood to be minimized is</span>
<span class="c1">///       NLL = Sum{ log Poisson( y(i) |{ f(x(i) | p ) ) }</span>
<span class="c1">/// The exact likelihood used is the Poisson likelihood described in this paper:</span>
<span class="c1">/// S. Baker and R. D. Cousins, “Clarification of the use of chi-square and likelihood functions in fits to histograms,”</span>
<span class="c1">/// Nucl. Instrum. Meth. 221 (1984) 437.</span>
<span class="c1">/// This method can then be used only when the bin content represents counts (i.e. errors are sqrt(N) ).</span>
<span class="c1">/// The likelihood method has the advantage of treating correctly bins with low statistics. In case of high</span>
<span class="c1">/// statistics/bin the distribution of the bin content becomes a normal distribution and the likelihood and chi2 fit</span>
<span class="c1">/// give the same result.</span>
<span class="c1">/// The likelihood method, although a bit slower, it is therefore the recommended method in case of low</span>
<span class="c1">/// bin statistics, where the chi2 method may give incorrect results, in particular when there are</span>
<span class="c1">/// several empty bins (see also below).</span>
<span class="c1">/// In case of a weighted histogram, it is possible to perform a likelihood fit by using the</span>
<span class="c1">/// option &quot;WL&quot;. Note a weighted histogram is an histogram which has been filled with weights and it</span>
<span class="c1">/// contains the sum of the weight square ( TH1::Sumw2() has been called). The bin error for a weighted</span>
<span class="c1">/// histogram is the square root of the sum of the weight square.</span>
<span class="c1">/// ## Treatment of Empty Bins</span>
<span class="c1">/// Empty bins, which have the content equal to zero AND error equal to zero,</span>
<span class="c1">/// are excluded by default from the chisquare fit, but they are considered in the likelihood fit.</span>
<span class="c1">/// since they affect the likelihood if the function value in these bins is not negligible.</span>
<span class="c1">/// When using option &quot;WW&quot; these bins will be considered in the chi2 fit with an error of 1.</span>
<span class="c1">/// Note that if the histogram is having bins with zero content and non zero-errors they are considered as</span>
<span class="c1">/// any other bins in the fit. Instead bins with zero error and non-zero content are excluded in the chi2 fit.</span>
<span class="c1">/// A likelihood fit should also not be peformed on such an histogram, since we are assuming a wrong pdf for each bin.</span>
<span class="c1">/// In general, one should not fit an histogram with non-empty bins and zero errors, apart if all the bins have zero errors.</span>
<span class="c1">/// In this case one could use the option &quot;w&quot;, which gives a weight=1 for each bin (unweighted least-square fit).</span>
<span class="c1">/// ## Fitting a histogram of dimension N with a function of dimension N-1</span>
<span class="c1">/// It is possible to fit a TH2 with a TF1 or a TH3 with a TF2.</span>
<span class="c1">/// In this case the option &quot;Integral&quot; is not allowed and each cell has</span>
<span class="c1">/// equal weight.</span>
<span class="c1">/// ## Associated functions</span>
<span class="c1">/// One or more object (typically a TF1*) can be added to the list</span>
<span class="c1">/// of functions (fFunctions) associated to each histogram.</span>
<span class="c1">/// When TH1::Fit is invoked, the fitted function is added to this list.</span>
<span class="c1">/// Given an histogram h, one can retrieve an associated function</span>
<span class="c1">/// with:  TF1 *myfunc = h-&gt;GetFunction(&quot;myfunc&quot;);</span>
<span class="c1">/// ##Access to the fit result</span>
<span class="c1">/// The function returns a TFitResultPtr which can hold a  pointer to a TFitResult object.</span>
<span class="c1">/// By default the TFitResultPtr contains only the status of the fit which is return by an</span>
<span class="c1">/// automatic conversion of the TFitResultPtr to an integer. One can write in this case directly:</span>
<span class="c1">///     Int_t fitStatus =  h-&gt;Fit(myFunc)</span>
<span class="c1">/// ## Access to the fit status</span>
<span class="c1">/// The status of the fit can be obtained converting the TFitResultPtr to an integer</span>
<span class="c1">/// independently if the fit option &quot;S&quot; is used or not:</span>
<span class="c1">///     TFitResultPtr r = h-&gt;Fit(myFunc,opt);</span>
<span class="c1">///     Int_t fitStatus = r;</span>
<span class="c1">/// The fitStatus is 0 if the fit is OK (i.e no error occurred).</span>
<span class="c1">/// The value of the fit status code is negative in case of an error not connected with the</span>
<span class="c1">/// minimization procedure, for example  when a wrong function is used.</span>
<span class="c1">/// Otherwise the return value is the one returned from the minimization procedure.</span>
<span class="c1">/// When TMinuit (default case) or Minuit2 are used as minimizer the status returned is :</span>
<span class="c1">/// fitStatus =  migradResult + 10*minosResult + 100*hesseResult + 1000*improveResult.</span>
<span class="c1">/// TMinuit will return 0 (for migrad, minos, hesse or improve) in case of success and 4 in</span>
<span class="c1">/// case of error (see the documentation of TMinuit::mnexcm). So for example, for an error</span>
<span class="c1">/// only in Minos but not in Migrad a fitStatus of 40 will be returned.</span>
<span class="c1">/// Minuit2 will return also 0 in case of success and different values in migrad minos or</span>
<span class="c1">/// hesse depending on the error. See in this case the documentation of</span>
<span class="c1">/// Minuit2Minimizer::Minimize for the migradResult, Minuit2Minimizer::GetMinosError for the</span>
<span class="c1">/// minosResult and Minuit2Minimizer::Hesse for the hesseResult.</span>
<span class="c1">/// If other minimizers are used see their specific documentation for the status code returned.</span>
<span class="c1">/// For example in the case of Fumili, for the status returned see TFumili::Minimize.</span>
<span class="c1">/// ## Access to the Minimizer information during fitting</span>
<span class="c1">/// This function calls, the ROOT::Fit::FitObject function implemented in HFitImpl.cxx</span>
<span class="c1">/// which uses the ROOT::Fit::Fitter class. The Fitter class creates the objective fuction</span>
<span class="c1">/// (e.g. chi2 or likelihood) and uses an implementation of the  Minimizer interface for minimizing</span>
<span class="c1">/// the function.</span>
<span class="c1">/// The default minimizer is Minuit (class TMinuitMinimizer which calls TMinuit).</span>
<span class="c1">/// The default  can be set in the resource file in etc/system.rootrc. For example</span>
<span class="c1">///     Root.Fitter:      Minuit2</span>
<span class="c1">/// A different fitter can also be set via ROOT::Math::MinimizerOptions::SetDefaultMinimizer</span>
<span class="c1">/// (or TVirtualFitter::SetDefaultFitter).</span>
<span class="c1">/// For example ROOT::Math::MinimizerOptions::SetDefaultMinimizer(&quot;GSLMultiMin&quot;,&quot;BFGS&quot;);</span>
<span class="c1">/// will set the usdage of the BFGS algorithm of the GSL multi-dimensional minimization</span>
<span class="c1">/// (implemented in libMathMore). ROOT::Math::MinimizerOptions can be used also to set other</span>
<span class="c1">/// default options, like maximum number of function calls, minimization tolerance or print</span>
<span class="c1">/// level. See the documentation of this class.</span>
<span class="c1">/// For fitting linear functions (containing the &quot;++&quot; sign&quot; and polN functions,</span>
<span class="c1">/// the linear fitter is automatically initialized.</span>

   <span class="k">virtual</span> <span class="kt">void</span>     <span class="nf">FitPanel</span><span class="p">();</span> <span class="c1">// *MENU*    Display a panel with all histogram fit options.    See class TFitPanel for example</span>
   <span class="n">TH1</span>             <span class="o">*</span><span class="nf">GetAsymmetry</span><span class="p">(</span><span class="n">TH1</span><span class="o">*</span> <span class="n">h2</span><span class="p">,</span> <span class="n">Double_t</span> <span class="n">c2</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">Double_t</span> <span class="n">dc2</span><span class="o">=</span><span class="mi">0</span><span class="p">);</span>
<span class="c1">/// Return an histogram containing the asymmetry of this histogram with h2,</span>
<span class="c1">/// where the asymmetry is defined as:</span>
<span class="c1">/// Asymmetry = (h1 - h2)/(h1 + h2)  where h1 = this</span>
<span class="c1">/// works for 1D, 2D, etc. histograms</span>
<span class="c1">/// c2 is an optional argument that gives a relative weight between the two</span>
<span class="c1">/// histograms, and dc2 is the error on this weight.  This is useful, for example,</span>
<span class="c1">/// when forming an asymmetry between two histograms from 2 different data sets that</span>
<span class="c1">/// need to be normalized to each other in some way.  The function calculates</span>
<span class="c1">/// the errors asumming Poisson statistics on h1 and h2 (that is, dh = sqrt(h)).</span>
<span class="c1">/// example:  assuming &#39;h1&#39; and &#39;h2&#39; are already filled</span>
<span class="c1">/// h3 = h1-&gt;GetAsymmetry(h2)</span>
<span class="c1">/// then &#39;h3&#39; is created and filled with the asymmetry between &#39;h1&#39; and &#39;h2&#39;;</span>
<span class="c1">/// h1 and h2 are left intact.</span>
<span class="c1">/// Note that it is the user&#39;s responsibility to manage the created histogram.</span>
<span class="c1">/// The name of the returned histogram will be Asymmetry_nameOfh1-nameOfh2</span>
<span class="c1">///</span>
<span class="c1">/// clone the histograms so top and bottom will have the</span>
<span class="c1">/// correct dimensions:</span>
<span class="c1">/// Sumw2 just makes sure the errors will be computed properly</span>
<span class="c1">/// when we form sums and ratios below.</span>

   <span class="n">Int_t</span>            <span class="nf">GetBufferLength</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span><span class="k">return</span> <span class="n">fBuffer</span> <span class="o">?</span> <span class="p">(</span><span class="n">Int_t</span><span class="p">)</span><span class="n">fBuffer</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;}</span>
   <span class="n">Int_t</span>            <span class="nf">GetBufferSize</span>  <span class="p">()</span> <span class="k">const</span> <span class="p">{</span><span class="k">return</span> <span class="n">fBufferSize</span><span class="p">;}</span>
   <span class="k">const</span>   <span class="n">Double_t</span> <span class="o">*</span><span class="nf">GetBuffer</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span><span class="k">return</span> <span class="n">fBuffer</span><span class="p">;}</span>
   <span class="k">static</span>  <span class="n">Int_t</span>    <span class="nf">GetDefaultBufferSize</span><span class="p">();</span>
<span class="c1">/// static function</span>
<span class="c1">/// return the default buffer size for automatic histograms</span>
<span class="c1">/// the parameter fgBufferSize may be changed via SetDefaultBufferSize</span>

   <span class="k">virtual</span> <span class="n">Double_t</span> <span class="o">*</span><span class="nf">GetIntegral</span><span class="p">();</span><span class="c1">//ROOT 6  //TH1积分，当前bin值为前面所有bin的累积，然后归一化（最大值为1），返回该数组</span>
<span class="c1">///  Return a pointer to the array of bins integral.</span>
<span class="c1">///  if the pointer fIntegral is null, TH1::ComputeIntegral is called</span>
<span class="c1">/// The array dimension is the number of bins in the histograms</span>
<span class="c1">/// including underflow and overflow (fNCells)</span>
<span class="c1">/// the last value integral[fNCells] is set to the number of entries of</span>
<span class="c1">/// the histogram</span>

   <span class="n">TH1</span>             <span class="o">*</span><span class="nf">GetCumulative</span><span class="p">(</span><span class="n">Bool_t</span> <span class="n">forward</span> <span class="o">=</span> <span class="n">kTRUE</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">suffix</span> <span class="o">=</span> <span class="s">&quot;_cumulative&quot;</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span><span class="c1">//ROOT 6 //TH1积分，当前bin值为前面所有bin的累积。</span>
<span class="c1">///  Return a pointer to an histogram containing the cumulative The</span>
<span class="c1">///  cumulative can be computed both in the forward (default) or backward</span>
<span class="c1">///  direction; the name of the new histogram is constructed from</span>
<span class="c1">///  the name of this histogram with the suffix suffix appended.</span>
<span class="c1">/// The cumulative distribution is formed by filling each bin of the</span>
<span class="c1">/// resulting histogram with the sum of that bin and all previous</span>
<span class="c1">/// (forward == kTRUE) or following (forward = kFALSE) bins.</span>
<span class="c1">/// note: while cumulative distributions make sense in one dimension, you</span>
<span class="c1">/// may not be getting what you expect in more than 1D because the concept</span>
<span class="c1">/// of a cumulative distribution is much trickier to define; make sure you</span>
<span class="c1">/// understand the order of summation before you use this method with</span>
<span class="c1">/// histograms of dimension &gt;= 2.</span>

   <span class="n">TList</span>           <span class="o">*</span><span class="nf">GetListOfFunctions</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">fFunctions</span><span class="p">;</span> <span class="p">}</span>

   <span class="k">virtual</span> <span class="n">Int_t</span>    <span class="nf">GetNdivisions</span><span class="p">(</span><span class="n">Option_t</span> <span class="o">*</span><span class="n">axis</span><span class="o">=</span><span class="s">&quot;X&quot;</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
   <span class="k">virtual</span> <span class="n">Color_t</span>  <span class="nf">GetAxisColor</span><span class="p">(</span><span class="n">Option_t</span> <span class="o">*</span><span class="n">axis</span><span class="o">=</span><span class="s">&quot;X&quot;</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
   <span class="k">virtual</span> <span class="n">Color_t</span>  <span class="nf">GetLabelColor</span><span class="p">(</span><span class="n">Option_t</span> <span class="o">*</span><span class="n">axis</span><span class="o">=</span><span class="s">&quot;X&quot;</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
   <span class="k">virtual</span> <span class="n">Style_t</span>  <span class="nf">GetLabelFont</span><span class="p">(</span><span class="n">Option_t</span> <span class="o">*</span><span class="n">axis</span><span class="o">=</span><span class="s">&quot;X&quot;</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
   <span class="k">virtual</span> <span class="n">Float_t</span>  <span class="nf">GetLabelOffset</span><span class="p">(</span><span class="n">Option_t</span> <span class="o">*</span><span class="n">axis</span><span class="o">=</span><span class="s">&quot;X&quot;</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
   <span class="k">virtual</span> <span class="n">Float_t</span>  <span class="nf">GetLabelSize</span><span class="p">(</span><span class="n">Option_t</span> <span class="o">*</span><span class="n">axis</span><span class="o">=</span><span class="s">&quot;X&quot;</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
   <span class="k">virtual</span> <span class="n">Style_t</span>  <span class="nf">GetTitleFont</span><span class="p">(</span><span class="n">Option_t</span> <span class="o">*</span><span class="n">axis</span><span class="o">=</span><span class="s">&quot;X&quot;</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
   <span class="k">virtual</span> <span class="n">Float_t</span>  <span class="nf">GetTitleOffset</span><span class="p">(</span><span class="n">Option_t</span> <span class="o">*</span><span class="n">axis</span><span class="o">=</span><span class="s">&quot;X&quot;</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
   <span class="k">virtual</span> <span class="n">Float_t</span>  <span class="nf">GetTitleSize</span><span class="p">(</span><span class="n">Option_t</span> <span class="o">*</span><span class="n">axis</span><span class="o">=</span><span class="s">&quot;X&quot;</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
   <span class="k">virtual</span> <span class="n">Float_t</span>  <span class="nf">GetTickLength</span><span class="p">(</span><span class="n">Option_t</span> <span class="o">*</span><span class="n">axis</span><span class="o">=</span><span class="s">&quot;X&quot;</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
   <span class="k">virtual</span> <span class="n">Float_t</span>  <span class="nf">GetBarOffset</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span><span class="k">return</span> <span class="n">Float_t</span><span class="p">(</span><span class="mf">0.001</span><span class="o">*</span><span class="n">Float_t</span><span class="p">(</span><span class="n">fBarOffset</span><span class="p">));}</span>
   <span class="k">virtual</span> <span class="n">Float_t</span>  <span class="nf">GetBarWidth</span><span class="p">()</span> <span class="k">const</span>  <span class="p">{</span><span class="k">return</span> <span class="n">Float_t</span><span class="p">(</span><span class="mf">0.001</span><span class="o">*</span><span class="n">Float_t</span><span class="p">(</span><span class="n">fBarWidth</span><span class="p">));}</span>
   <span class="k">virtual</span> <span class="n">Int_t</span>    <span class="nf">GetContour</span><span class="p">(</span><span class="n">Double_t</span> <span class="o">*</span><span class="n">levels</span><span class="o">=</span><span class="mi">0</span><span class="p">);</span>
<span class="c1">/// Return contour values into array levels if pointer levels is non zero</span>
<span class="c1">/// The function returns the number of contour levels.</span>
<span class="c1">/// see GetContourLevel to return one contour only</span>

   <span class="k">virtual</span> <span class="n">Double_t</span> <span class="nf">GetContourLevel</span><span class="p">(</span><span class="n">Int_t</span> <span class="n">level</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span><span class="c1">/// Return value of contour number level use GetContour to return the array of all contour levels</span>
   <span class="k">virtual</span> <span class="n">Double_t</span> <span class="nf">GetContourLevelPad</span><span class="p">(</span><span class="n">Int_t</span> <span class="n">level</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
<span class="c1">/// Return the value of contour number &quot;level&quot; in Pad coordinates ie: if the Pad</span>
<span class="c1">/// is in log scale along Z it returns le log of the contour level value.</span>
<span class="c1">/// see GetContour to return the array of all contour levels</span>

   <span class="k">virtual</span> <span class="n">Int_t</span>    <span class="nf">GetBin</span><span class="p">(</span><span class="n">Int_t</span> <span class="n">binx</span><span class="p">,</span> <span class="n">Int_t</span> <span class="n">biny</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">Int_t</span> <span class="n">binz</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
<span class="c1">/// Return Global bin number corresponding to binx,y,z.</span>
<span class="c1">/// 2-D and 3-D histograms are represented with a one dimensional structure.</span>
<span class="c1">/// This has the advantage that all existing functions, such as</span>
<span class="c1">/// GetBinContent, GetBinError, GetBinFunction work for all dimensions.</span>
<span class="c1">/// In case of a TH1x, returns binx directly.</span>
<span class="c1">/// see TH1::GetBinXYZ for the inverse transformation.</span>
<span class="c1">/// Convention for numbering bins</span>
<span class="c1">/// For all histogram types: nbins, xlow, xup</span>
<span class="c1">///    bin = 0;       underflow bin</span>
<span class="c1">///    bin = 1;       first bin with low-edge xlow INCLUDED</span>
<span class="c1">///    bin = nbins;   last bin with upper-edge xup EXCLUDED</span>
<span class="c1">///    bin = nbins+1; overflow bin</span>
<span class="c1">/// In case of 2-D or 3-D histograms, a &quot;global bin&quot; number is defined.</span>
<span class="c1">/// For example, assuming a 3-D histogram with binx,biny,binz, the function</span>
<span class="c1">///     Int_t bin = h-&gt;GetBin(binx,biny,binz);</span>
<span class="c1">/// returns a global/linearized bin number. This global bin is useful</span>
<span class="c1">/// to access the bin information independently of the dimension.</span>

   <span class="k">virtual</span> <span class="kt">void</span>     <span class="nf">GetBinXYZ</span><span class="p">(</span><span class="n">Int_t</span> <span class="n">binglobal</span><span class="p">,</span> <span class="n">Int_t</span> <span class="o">&amp;</span><span class="n">binx</span><span class="p">,</span> <span class="n">Int_t</span> <span class="o">&amp;</span><span class="n">biny</span><span class="p">,</span> <span class="n">Int_t</span> <span class="o">&amp;</span><span class="n">binz</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span><span class="c1">/// return binx, biny, binz corresponding to the global bin number globalbin. see TH1::GetBin function above</span>
   <span class="k">virtual</span> <span class="n">Double_t</span> <span class="nf">GetBinCenter</span><span class="p">(</span><span class="n">Int_t</span> <span class="n">bin</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span><span class="c1">//返回该bin的中点坐标。</span>
   <span class="k">virtual</span> <span class="n">Double_t</span> <span class="nf">GetBinContent</span><span class="p">(</span><span class="n">Int_t</span> <span class="n">bin</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span><span class="c1">//返回该bin的计数.</span>
<span class="c1">/// Return content of bin number bin.</span>
<span class="c1">/// Implemented in TH1C,S,F,D</span>
<span class="c1">///  Convention for numbering bins</span>
<span class="c1">///  For all histogram types: nbins, xlow, xup</span>
<span class="c1">///    bin = 0;       underflow bin</span>
<span class="c1">///    bin = 1;       first bin with low-edge xlow INCLUDED</span>
<span class="c1">///    bin = nbins;   last bin with upper-edge xup EXCLUDED</span>
<span class="c1">///    bin = nbins+1; overflow bin</span>
<span class="c1">///  In case of 2-D or 3-D histograms, a &quot;global bin&quot; number is defined.</span>
<span class="c1">///  For example, assuming a 3-D histogram with binx,biny,binz, the function</span>
<span class="c1">///    Int_t bin = h-&gt;GetBin(binx,biny,binz);</span>
<span class="c1">///  returns a global/linearized bin number. This global bin is useful</span>
<span class="c1">///  to access the bin information independently of the dimension.</span>

   <span class="k">virtual</span> <span class="n">Double_t</span> <span class="nf">GetBinContent</span><span class="p">(</span><span class="n">Int_t</span> <span class="n">bin</span><span class="p">,</span> <span class="n">Int_t</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">GetBinContent</span><span class="p">(</span><span class="n">bin</span><span class="p">);</span> <span class="p">}</span>
   <span class="k">virtual</span> <span class="n">Double_t</span> <span class="nf">GetBinContent</span><span class="p">(</span><span class="n">Int_t</span> <span class="n">bin</span><span class="p">,</span> <span class="n">Int_t</span><span class="p">,</span> <span class="n">Int_t</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">GetBinContent</span><span class="p">(</span><span class="n">bin</span><span class="p">);</span> <span class="p">}</span>
   <span class="k">virtual</span> <span class="n">Double_t</span> <span class="nf">GetBinError</span><span class="p">(</span><span class="n">Int_t</span> <span class="n">bin</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span><span class="c1">//Return value of error associated to bin number bin. if the sum of squares of weights has been defined (via Sumw2),this function returns the sqrt(sum of w2). otherwise it returns the sqrt(contents) for this bin.</span>
   <span class="k">virtual</span> <span class="n">Double_t</span> <span class="nf">GetBinError</span><span class="p">(</span><span class="n">Int_t</span> <span class="n">binx</span><span class="p">,</span> <span class="n">Int_t</span> <span class="n">biny</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">GetBinError</span><span class="p">(</span><span class="n">GetBin</span><span class="p">(</span><span class="n">binx</span><span class="p">,</span> <span class="n">biny</span><span class="p">));</span> <span class="p">}</span> <span class="c1">// for 2D histograms only</span>
   <span class="k">virtual</span> <span class="n">Double_t</span> <span class="nf">GetBinError</span><span class="p">(</span><span class="n">Int_t</span> <span class="n">binx</span><span class="p">,</span> <span class="n">Int_t</span> <span class="n">biny</span><span class="p">,</span> <span class="n">Int_t</span> <span class="n">binz</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">GetBinError</span><span class="p">(</span><span class="n">GetBin</span><span class="p">(</span><span class="n">binx</span><span class="p">,</span> <span class="n">biny</span><span class="p">,</span> <span class="n">binz</span><span class="p">));</span> <span class="p">}</span> <span class="c1">// for 3D histograms only</span>
   <span class="k">virtual</span> <span class="n">Double_t</span> <span class="nf">GetBinErrorLow</span><span class="p">(</span><span class="n">Int_t</span> <span class="n">bin</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span><span class="c1">//Return lower error associated to bin number bin. The error will depend on the statistic option used will return the binContent - lower interval value</span>
   <span class="k">virtual</span> <span class="n">Double_t</span> <span class="nf">GetBinErrorUp</span><span class="p">(</span><span class="n">Int_t</span> <span class="n">bin</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span><span class="c1">//Return upper error associated to bin number bin. The error will depend on the statistic option used will return the binContent - upper interval value</span>
   <span class="k">virtual</span> <span class="n">EBinErrorOpt</span>  <span class="nf">GetBinErrorOption</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">fBinStatErrOpt</span><span class="p">;</span> <span class="p">}</span>
   <span class="k">virtual</span> <span class="n">Double_t</span> <span class="nf">GetBinLowEdge</span><span class="p">(</span><span class="n">Int_t</span> <span class="n">bin</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span><span class="c1">//return bin lower edge for 1D historam      Better to use h1.GetXaxis().GetBinLowEdge(bin)</span>
   <span class="k">virtual</span> <span class="n">Double_t</span> <span class="nf">GetBinWidth</span><span class="p">(</span><span class="n">Int_t</span> <span class="n">bin</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span><span class="c1">//返回bin的宽度。      return bin width for 1D historam     Better to use h1.GetXaxis().GetBinWidth(bin)</span>
   <span class="k">virtual</span> <span class="n">Double_t</span> <span class="nf">GetBinWithContent</span><span class="p">(</span><span class="n">Double_t</span> <span class="n">c</span><span class="p">,</span> <span class="n">Int_t</span> <span class="o">&amp;</span><span class="n">binx</span><span class="p">,</span> <span class="n">Int_t</span> <span class="n">firstx</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">Int_t</span> <span class="n">lastx</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="n">Double_t</span> <span class="n">maxdiff</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
<span class="c1">/// compute first binx in the range [firstx,lastx] for which</span>
<span class="c1">/// diff = abs(bin_content-c) &lt;= maxdiff</span>
<span class="c1">/// In case several bins in the specified range with diff=0 are found</span>
<span class="c1">/// the first bin found is returned in binx.</span>
<span class="c1">/// In case several bins in the specified range satisfy diff &lt;=maxdiff</span>
<span class="c1">/// the bin with the smallest difference is returned in binx.</span>
<span class="c1">/// In all cases the function returns the smallest difference.</span>
<span class="c1">/// NOTE1: if firstx &lt;= 0, firstx is set to bin 1</span>
<span class="c1">///    if (lastx &lt; firstx then firstx is set to the number of bins</span>
<span class="c1">///    ie if firstx=0 and lastx=0 (default) the search is on all bins.</span>
<span class="c1">/// NOTE2: if maxdiff=0 (default), the first bin with content=c is returned.</span>

   <span class="k">virtual</span> <span class="kt">void</span>     <span class="nf">GetCenter</span><span class="p">(</span><span class="n">Double_t</span> <span class="o">*</span><span class="n">center</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span><span class="c1">/// Fill array with center of bins for 1D histogram       Better to use h1.GetXaxis().GetCenter(center)</span>
   <span class="k">static</span>  <span class="n">Bool_t</span>   <span class="nf">GetDefaultSumw2</span><span class="p">();</span>
   <span class="n">TDirectory</span>      <span class="o">*</span><span class="nf">GetDirectory</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span><span class="k">return</span> <span class="n">fDirectory</span><span class="p">;}</span>
   <span class="k">virtual</span> <span class="n">Double_t</span> <span class="nf">GetEntries</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>  <span class="c1">//returns the number of entries</span>
   <span class="k">virtual</span> <span class="n">Double_t</span> <span class="nf">GetEffectiveEntries</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
<span class="c1">/// number of effective entries of the histogram,</span>
<span class="c1">/// neff = (Sum of weights )^2 / (Sum of weight^2 )</span>
<span class="c1">/// In case of an unweighted histogram this number is equivalent to the</span>
<span class="c1">/// number of entries of the histogram.</span>
<span class="c1">/// For a weighted histogram, this number corresponds to the hypotetical number of unweighted entries</span>
<span class="c1">/// a histogram would need to have the same statistical power as this weighted histogram.</span>
<span class="c1">/// Note: The underflow/overflow are included if one has set the TH1::StatOverFlows flag</span>
<span class="c1">/// and if the statistics has been computed at filling time.</span>
<span class="c1">/// If a range is set in the histogram the number is computed from the given range.</span>

   <span class="k">virtual</span> <span class="n">TF1</span>     <span class="o">*</span><span class="nf">GetFunction</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span><span class="c1">/// Return pointer to function with name. Functions such as TH1::Fit store the fitted function in the list of functions of this histogram.</span>
   <span class="k">virtual</span> <span class="n">Int_t</span>    <span class="nf">GetDimension</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">fDimension</span><span class="p">;</span> <span class="p">}</span>
   <span class="k">virtual</span> <span class="n">Double_t</span> <span class="nf">GetKurtosis</span><span class="p">(</span><span class="n">Int_t</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span><span class="c1">//For axis =1, 2 or 3 returns kurtosis of the histogram along x, y or z axis.Kurtosis(gaussian(0, 1)) = 0. For axis =11, 12 or 13 returns the approximate standard error of kurtosis of the histogram along x, y or z axis. Note, that since third and fourth moment are not calculated at the fill time, kurtosis and its standard error are computed bin by bin</span>
   <span class="k">virtual</span> <span class="kt">void</span>     <span class="nf">GetLowEdge</span><span class="p">(</span><span class="n">Double_t</span> <span class="o">*</span><span class="n">edge</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span><span class="c1">/// Fill array with low edge of bins for 1D histogram    Better to use h1.GetXaxis().GetLowEdge(edge)</span>
   <span class="k">virtual</span> <span class="n">Double_t</span> <span class="nf">GetMaximum</span><span class="p">(</span><span class="n">Double_t</span> <span class="n">maxval</span><span class="o">=</span><span class="n">FLT_MAX</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
<span class="c1">/// Return maximum value smaller than maxval of bins in the range,</span>
<span class="c1">/// unless the value has been overridden by TH1::SetMaximum,</span>
<span class="c1">/// in which case it returns that value. (This happens, for example,</span>
<span class="c1">/// when the histogram is drawn and the y or z axis limits are changed</span>
<span class="c1">/// To get the maximum value of bins in the histogram regardless of</span>
<span class="c1">/// whether the value has been overridden, use</span>
<span class="c1">///  h-&gt;GetBinContent(h-&gt;GetMaximumBin())</span>

   <span class="k">virtual</span> <span class="n">Int_t</span>    <span class="nf">GetMaximumBin</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span><span class="c1">/// Return location of bin with maximum value in the range.</span>
   <span class="k">virtual</span> <span class="n">Int_t</span>    <span class="nf">GetMaximumBin</span><span class="p">(</span><span class="n">Int_t</span> <span class="o">&amp;</span><span class="n">locmax</span><span class="p">,</span> <span class="n">Int_t</span> <span class="o">&amp;</span><span class="n">locmay</span><span class="p">,</span> <span class="n">Int_t</span> <span class="o">&amp;</span><span class="n">locmaz</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span><span class="c1">/// Return location of bin with maximum value in the range.</span>
   <span class="k">virtual</span> <span class="n">Double_t</span> <span class="nf">GetMaximumStored</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span><span class="k">return</span> <span class="n">fMaximum</span><span class="p">;}</span>
   <span class="k">virtual</span> <span class="n">Double_t</span> <span class="nf">GetMinimum</span><span class="p">(</span><span class="n">Double_t</span> <span class="n">minval</span><span class="o">=-</span><span class="n">FLT_MAX</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
<span class="c1">/// Return minimum value larger than minval of bins in the range,</span>
<span class="c1">/// unless the value has been overridden by TH1::SetMinimum,</span>
<span class="c1">/// in which case it returns that value. (This happens, for example,</span>
<span class="c1">/// when the histogram is drawn and the y or z axis limits are changed</span>
<span class="c1">/// To get the minimum value of bins in the histogram regardless of</span>
<span class="c1">/// whether the value has been overridden, use</span>
<span class="c1">/// h-&gt;GetBinContent(h-&gt;GetMinimumBin())</span>

   <span class="k">virtual</span> <span class="n">Int_t</span>    <span class="nf">GetMinimumBin</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span><span class="c1">/// Return location of bin with minimum value in the range.</span>
   <span class="k">virtual</span> <span class="n">Int_t</span>    <span class="nf">GetMinimumBin</span><span class="p">(</span><span class="n">Int_t</span> <span class="o">&amp;</span><span class="n">locmix</span><span class="p">,</span> <span class="n">Int_t</span> <span class="o">&amp;</span><span class="n">locmiy</span><span class="p">,</span> <span class="n">Int_t</span> <span class="o">&amp;</span><span class="n">locmiz</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span><span class="c1">/// Return location of bin with minimum value in the range.</span>
   <span class="k">virtual</span> <span class="n">Double_t</span> <span class="nf">GetMinimumStored</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span><span class="k">return</span> <span class="n">fMinimum</span><span class="p">;}</span>
   <span class="k">virtual</span> <span class="n">Double_t</span> <span class="nf">GetMean</span><span class="p">(</span><span class="n">Int_t</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span><span class="c1">//returns the mean value along axis. For axis = 1,2 or 3 returns the mean value of the histogram along X,Y or Z axis. For axis = 11, 12, 13 returns the standard error of the mean value of the histogram along X, Y or Z axis. Note that the mean value/RMS is computed using the bins in the currently defined range (see TAxis::SetRange). By default the range includes all bins from 1 to nbins included, excluding underflows and overflows. To force the underflows and overflows in the computation, one must call the static function TH1::StatOverflows(kTRUE) before filling the histogram.</span>
   <span class="k">virtual</span> <span class="n">Double_t</span> <span class="nf">GetMeanError</span><span class="p">(</span><span class="n">Int_t</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span><span class="c1">//Return standard error of mean of this histogram along the X axis.  Note that the mean value/RMS is computed using the bins in the currently defined range (see TAxis::SetRange). By default the range includes  all bins from 1 to nbins included, excluding underflows and overflows. To force the underflows and overflows in the computation, one must call the static function TH1::StatOverflows(kTRUE) before filling the histogram.  Also note, that although the definition of standard error doesn&#39;t include the assumption of normality, many uses of this feature implicitly assume it.</span>
   <span class="k">virtual</span> <span class="n">Int_t</span>    <span class="nf">GetNbinsX</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span><span class="k">return</span> <span class="n">fXaxis</span><span class="p">.</span><span class="n">GetNbins</span><span class="p">();}</span><span class="c1">//获取该轴bin值</span>
   <span class="k">virtual</span> <span class="n">Int_t</span>    <span class="nf">GetNbinsY</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span><span class="k">return</span> <span class="n">fYaxis</span><span class="p">.</span><span class="n">GetNbins</span><span class="p">();}</span>
   <span class="k">virtual</span> <span class="n">Int_t</span>    <span class="nf">GetNbinsZ</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span><span class="k">return</span> <span class="n">fZaxis</span><span class="p">.</span><span class="n">GetNbins</span><span class="p">();}</span>
   <span class="k">virtual</span> <span class="n">Int_t</span>    <span class="nf">GetNcells</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span><span class="k">return</span> <span class="n">fNcells</span><span class="p">;</span> <span class="p">}</span><span class="c1">//number of bins(1D), cells (2D) +U/Overflows</span>
   <span class="k">virtual</span> <span class="n">Double_t</span> <span class="nf">GetNormFactor</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span><span class="k">return</span> <span class="n">fNormFactor</span><span class="p">;}</span><span class="c1">//如果没有设置将会返回0。这个因子是将直方图面积设为该因子。设置该因子参考 SetNormFactor(Double_t factor=1)。</span>
   <span class="k">virtual</span> <span class="kt">char</span>    <span class="o">*</span><span class="nf">GetObjectInfo</span><span class="p">(</span><span class="n">Int_t</span> <span class="n">px</span><span class="p">,</span> <span class="n">Int_t</span> <span class="n">py</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
<span class="c1">/// Redefines TObject::GetObjectInfo.</span>
<span class="c1">/// Displays the histogram info (bin number, contents, integral up to bin</span>
<span class="c1">/// corresponding to cursor position px,py</span>

   <span class="n">Option_t</span>        <span class="o">*</span><span class="nf">GetOption</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span><span class="k">return</span> <span class="n">fOption</span><span class="p">.</span><span class="n">Data</span><span class="p">();}</span>

   <span class="n">TVirtualHistPainter</span> <span class="o">*</span><span class="nf">GetPainter</span><span class="p">(</span><span class="n">Option_t</span> <span class="o">*</span><span class="n">option</span><span class="o">=</span><span class="s">&quot;&quot;</span><span class="p">);</span><span class="c1">/// return pointer to painter if painter does not exist, it is created</span>

   <span class="k">virtual</span> <span class="n">Int_t</span>    <span class="nf">GetQuantiles</span><span class="p">(</span><span class="n">Int_t</span> <span class="n">nprobSum</span><span class="p">,</span> <span class="n">Double_t</span> <span class="o">*</span><span class="n">q</span><span class="p">,</span> <span class="k">const</span> <span class="n">Double_t</span> <span class="o">*</span><span class="n">probSum</span><span class="o">=</span><span class="mi">0</span><span class="p">);</span>
<span class="c1">/// Compute Quantiles for this histogram</span>
<span class="c1">/// Quantile x_q of a probability distribution Function F is defined as</span>
<span class="c1">///      F(x_q) = q with 0 &lt;= q &lt;= 1.</span>
<span class="c1">/// For instance the median x_0.5 of a distribution is defined as that value</span>
<span class="c1">/// of the random variable for which the distribution function equals 0.5:</span>
<span class="c1">///      F(x_0.5) = Probability(x &lt; x_0.5) = 0.5</span>
<span class="c1">/// code from Eddy Offermann, Renaissance</span>
<span class="c1">/// \param[in] nprobSum maximum size of array q and size of array probSum (if given)</span>
<span class="c1">/// \param[in] probSum array of positions where quantiles will be computed.</span>
<span class="c1">///   - if probSum is null, probSum will be computed internally and will</span>
<span class="c1">///     have a size = number of bins + 1 in h. it will correspond to the</span>
<span class="c1">///     quantiles calculated at the lowest edge of the histogram (quantile=0) and</span>
<span class="c1">///     all the upper edges of the bins.</span>
<span class="c1">///   - if probSum is not null, it is assumed to contain at least nprobSum values.</span>
<span class="c1">/// \param[out] q array q filled with nq quantiles</span>
<span class="c1">/// \return value nq (&lt;=nprobSum) with the number of quantiles computed</span>
<span class="c1">/// Note that the Integral of the histogram is automatically recomputed</span>
<span class="c1">/// if the number of entries is different of the number of entries when</span>
<span class="c1">/// the integral was computed last time. In case you do not use the Fill</span>
<span class="c1">/// functions to fill your histogram, but SetBinContent, you must call</span>
<span class="c1">/// TH1::ComputeIntegral before calling this function.</span>

   <span class="k">virtual</span> <span class="n">Double_t</span> <span class="nf">GetRandom</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span><span class="c1">//return a random number distributed according the histogram bin contents.  This function checks if the bins integral exists. If not, the integral is evaluated, normalized to one. The integral is automatically recomputed if the number of entries is not the same then when the integral was computed. NB Only valid for 1-d histograms. Use GetRandom2 or 3 otherwise. If the histogram has a bin with negative content a NaN is returned</span>
   <span class="k">virtual</span> <span class="kt">void</span>     <span class="nf">GetStats</span><span class="p">(</span><span class="n">Double_t</span> <span class="o">*</span><span class="n">stats</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
<span class="c1">// fill the array stats from the contents of this histogram</span>
<span class="c1">// The array stats must be correctly dimensioned in the calling program.</span>
<span class="c1">// stats[0] = sumw</span>
<span class="c1">// stats[1] = sumw2</span>
<span class="c1">// stats[2] = sumwx</span>
<span class="c1">// stats[3] = sumwx2</span>
<span class="c1">// If no axis-subrange is specified (via TAxis::SetRange), the array stats is simply a copy of the statistics quantities computed at filling time.If a sub-range is specified, the function recomputes these quantities from the bin contents in the current axis range.</span>
<span class="c1">// Note that the mean value/RMS is computed using the bins in the currently defined range (see TAxis::SetRange). By default the range includes all bins from 1 to nbins included, excluding underflows and overflows. To force the underflows and overflows in the computation, one must call the static function TH1::StatOverflows(kTRUE) before filling the histogram.</span>

   <span class="k">virtual</span> <span class="n">Double_t</span> <span class="nf">GetStdDev</span><span class="p">(</span><span class="n">Int_t</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span><span class="c1">//returns the sigma distribution along axis</span>
<span class="c1">/// Returns the Standard Deviation (Sigma).</span>
<span class="c1">/// The Sigma estimate is computed as Sqrt((1/N)*(Sum(x_i-x_mean)^2))</span>
<span class="c1">/// For axis = 1,2 or 3 returns the Sigma value of the histogram along</span>
<span class="c1">/// X, Y or Z axis</span>
<span class="c1">/// For axis = 11, 12 or 13 returns the error of StdDev estimation along</span>
<span class="c1">/// X, Y or Z axis for Normal distribution</span>
<span class="c1">/// Note that the mean value/sigma is computed using the bins in the currently</span>
<span class="c1">/// defined range (see TAxis::SetRange). By default the range includes</span>
<span class="c1">/// all bins from 1 to nbins included, excluding underflows and overflows.</span>
<span class="c1">/// To force the underflows and overflows in the computation, one must</span>
<span class="c1">/// call the static function TH1::StatOverflows(kTRUE) before filling</span>
<span class="c1">/// the histogram.</span>

   <span class="k">virtual</span> <span class="n">Double_t</span> <span class="nf">GetStdDevError</span><span class="p">(</span><span class="n">Int_t</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
<span class="c1">/// Return error of standard deviation estimation for Normal distribution</span>
<span class="c1">/// Note that the mean value/StdDev is computed using the bins in the currently</span>
<span class="c1">/// defined range (see TAxis::SetRange). By default the range includes</span>
<span class="c1">/// all bins from 1 to nbins included, excluding underflows and overflows.</span>
<span class="c1">/// To force the underflows and overflows in the computation, one must</span>
<span class="c1">/// call the static function TH1::StatOverflows(kTRUE) before filling</span>
<span class="c1">/// the histogram.</span>
<span class="c1">/// Value returned is standard deviation of sample standard deviation.</span>
<span class="c1">/// Note that it is an approximated value which is valid only in the case that the</span>
<span class="c1">/// original data distribution is Normal. The correct one would require</span>
<span class="c1">/// the 4-th momentum value, which cannot be accurately estimated from an histogram since</span>
<span class="c1">/// the x-information for all entries is not kept.</span>

   <span class="k">virtual</span> <span class="n">Double_t</span> <span class="nf">GetSumOfWeights</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span><span class="c1">//Return the sum of weights excluding under/overflows.</span>
   <span class="k">virtual</span> <span class="n">TArrayD</span> <span class="o">*</span><span class="nf">GetSumw2</span><span class="p">()</span> <span class="p">{</span><span class="k">return</span> <span class="o">&amp;</span><span class="n">fSumw2</span><span class="p">;}</span>
   <span class="k">virtual</span> <span class="k">const</span> <span class="n">TArrayD</span> <span class="o">*</span><span class="nf">GetSumw2</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span><span class="k">return</span> <span class="o">&amp;</span><span class="n">fSumw2</span><span class="p">;}</span>
   <span class="k">virtual</span> <span class="n">Int_t</span>    <span class="nf">GetSumw2N</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span><span class="k">return</span> <span class="n">fSumw2</span><span class="p">.</span><span class="n">fN</span><span class="p">;}</span>
           <span class="n">Double_t</span> <span class="nf">GetRMS</span><span class="p">(</span><span class="n">Int_t</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">GetStdDev</span><span class="p">(</span><span class="n">axis</span><span class="p">);</span> <span class="p">}</span>
<span class="c1">// For axis = 1,2 or 3 returns the Sigma value of the histogram along X, Y or Z axis. For axis = 11, 12 or 13 returns the error of RMS estimation along X, Y or Z axis for Normal distribution.</span>
<span class="c1">// Note that the mean value/sigma is computed using the bins in the currently defined range (see TAxis::SetRange). By default the range includes all bins from 1 to nbins included, excluding underflows and overflows. To force the underflows and overflows in the computation, one must  call the static function TH1::StatOverflows(kTRUE) before filling  the histogram.</span>
<span class="c1">// Note that this function returns the Standard Deviation (Sigma) of the distribution (not RMS). The Sigma estimate is computed as Sqrt((1/N)*(Sum(x_i-x_mean)^2)). The name &quot;RMS&quot; was introduced many years ago (Hbook/PAW times). </span>
           <span class="n">Double_t</span> <span class="nf">GetRMSError</span><span class="p">(</span><span class="n">Int_t</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">GetStdDevError</span><span class="p">(</span><span class="n">axis</span><span class="p">);</span> <span class="p">}</span>
<span class="c1">// Return error of RMS estimation for Normal distribution.</span>
<span class="c1">// Note that the mean value/RMS is computed using the bins in the currently defined range (see TAxis::SetRange). By default the range includes all bins from 1 to nbins included, excluding underflows and overflows.  To force the underflows and overflows in the computation, one must call the static function TH1::StatOverflows(kTRUE) before filling the histogram.</span>
<span class="c1">// Value returned is standard deviation of sample standard deviation.</span>
<span class="n">Note</span> <span class="n">that</span> <span class="n">it</span> <span class="n">is</span> <span class="n">an</span> <span class="n">approximated</span> <span class="n">value</span> <span class="n">which</span> <span class="n">is</span> <span class="n">valid</span> <span class="n">only</span> <span class="n">in</span> <span class="n">the</span> <span class="k">case</span> <span class="n">that</span> <span class="n">the</span> <span class="n">original</span> <span class="n">data</span> <span class="n">distribution</span> <span class="n">is</span> <span class="n">Normal</span><span class="p">.</span> <span class="n">The</span> <span class="n">correct</span> <span class="n">one</span> <span class="n">would</span> <span class="n">require</span> <span class="n">the</span> <span class="mi">4</span><span class="o">-</span><span class="n">th</span> <span class="n">momentum</span> <span class="n">value</span><span class="p">,</span> <span class="n">which</span> <span class="n">cannot</span> <span class="n">be</span> <span class="n">accurately</span> <span class="n">estimated</span> <span class="n">from</span> <span class="n">an</span> <span class="n">histogram</span> <span class="n">since</span> <span class="n">the</span> <span class="n">x</span><span class="o">-</span><span class="n">information</span> <span class="k">for</span> <span class="n">all</span> <span class="n">entries</span> <span class="n">is</span> <span class="n">not</span> <span class="n">kept</span><span class="p">.</span>
   <span class="k">virtual</span> <span class="n">Double_t</span> <span class="n">GetSkewness</span><span class="p">(</span><span class="n">Int_t</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
<span class="c1">///For axis = 1, 2 or 3 returns skewness of the histogram along x, y or z axis.</span>
<span class="c1">///For axis = 11, 12 or 13 returns the approximate standard error of skewness</span>
<span class="c1">///of the histogram along x, y or z axis</span>
<span class="c1">///Note, that since third and fourth moment are not calculated</span>
<span class="c1">///at the fill time, skewness and its standard error are computed bin by bin</span>

           <span class="n">TAxis</span><span class="o">*</span>   <span class="nf">GetXaxis</span><span class="p">()</span>  <span class="p">{</span> <span class="k">return</span> <span class="o">&amp;</span><span class="n">fXaxis</span><span class="p">;</span> <span class="p">}</span><span class="c1">//返回指向该坐标轴 TAxis* 的指针，可对该轴进行设置。具体参考TAxis类的使用。</span>
           <span class="n">TAxis</span><span class="o">*</span>   <span class="nf">GetYaxis</span><span class="p">()</span>  <span class="p">{</span> <span class="k">return</span> <span class="o">&amp;</span><span class="n">fYaxis</span><span class="p">;</span> <span class="p">}</span><span class="c1">//返回指向该坐标轴 TAxis* 的指针，可对该轴进行设置。具体参考TAxis类的使用。</span>
           <span class="n">TAxis</span><span class="o">*</span>   <span class="nf">GetZaxis</span><span class="p">()</span>  <span class="p">{</span> <span class="k">return</span> <span class="o">&amp;</span><span class="n">fZaxis</span><span class="p">;</span> <span class="p">}</span><span class="c1">//返回指向该坐标轴 TAxis* 的指针，可对该轴进行设置。具体参考TAxis类的使用。</span>
     <span class="k">const</span> <span class="n">TAxis</span><span class="o">*</span>   <span class="nf">GetXaxis</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="o">&amp;</span><span class="n">fXaxis</span><span class="p">;</span> <span class="p">}</span>
     <span class="k">const</span> <span class="n">TAxis</span><span class="o">*</span>   <span class="nf">GetYaxis</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="o">&amp;</span><span class="n">fYaxis</span><span class="p">;</span> <span class="p">}</span>
     <span class="k">const</span> <span class="n">TAxis</span><span class="o">*</span>   <span class="nf">GetZaxis</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="o">&amp;</span><span class="n">fZaxis</span><span class="p">;</span> <span class="p">}</span>
   <span class="k">virtual</span> <span class="n">Double_t</span> <span class="nf">Integral</span><span class="p">(</span><span class="n">Option_t</span> <span class="o">*</span><span class="n">option</span><span class="o">=</span><span class="s">&quot;&quot;</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span><span class="c1">//Return integral of bin contents. Only bins in the bins range are considered. By default the integral is computed as the sum of bin contents in the range.  if option &quot;width&quot; is specified, the integral is the sum of the bin contents multiplied by the bin width in x.</span>
   <span class="k">virtual</span> <span class="n">Double_t</span> <span class="nf">Integral</span><span class="p">(</span><span class="n">Int_t</span> <span class="n">binx1</span><span class="p">,</span> <span class="n">Int_t</span> <span class="n">binx2</span><span class="p">,</span> <span class="n">Option_t</span> <span class="o">*</span><span class="n">option</span><span class="o">=</span><span class="s">&quot;&quot;</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span><span class="c1">//returns the integral of bin contents in a given bin range</span>
<span class="c1">///Return integral of bin contents in range [binx1,binx2]</span>
<span class="c1">/// By default the integral is computed as the sum of bin contents in the range.</span>
<span class="c1">/// if option &quot;width&quot; is specified, the integral is the sum of</span>
<span class="c1">/// the bin contents multiplied by the bin width in x.</span>

   <span class="k">virtual</span> <span class="n">Double_t</span> <span class="nf">IntegralAndError</span><span class="p">(</span><span class="n">Int_t</span> <span class="n">binx1</span><span class="p">,</span> <span class="n">Int_t</span> <span class="n">binx2</span><span class="p">,</span> <span class="n">Double_t</span> <span class="o">&amp;</span> <span class="n">err</span><span class="p">,</span> <span class="n">Option_t</span> <span class="o">*</span><span class="n">option</span><span class="o">=</span><span class="s">&quot;&quot;</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
<span class="c1">///Return integral of bin contents in range [binx1,binx2] and its error</span>
<span class="c1">/// By default the integral is computed as the sum of bin contents in the range.</span>
<span class="c1">/// if option &quot;width&quot; is specified, the integral is the sum of</span>
<span class="c1">/// the bin contents multiplied by the bin width in x.</span>
<span class="c1">/// the error is computed using error propagation from the bin errors assumming that</span>
<span class="c1">/// all the bins are uncorrelated</span>

   <span class="k">virtual</span> <span class="n">Double_t</span> <span class="nf">Interpolate</span><span class="p">(</span><span class="n">Double_t</span> <span class="n">x</span><span class="p">);</span><span class="c1">//Given a point x, approximates the value via linear interpolation based on the two nearest bin centers. 获取x的y值。其值为最近两个bin线性插值。</span>
   <span class="k">virtual</span> <span class="n">Double_t</span> <span class="nf">Interpolate</span><span class="p">(</span><span class="n">Double_t</span> <span class="n">x</span><span class="p">,</span> <span class="n">Double_t</span> <span class="n">y</span><span class="p">);</span>
   <span class="k">virtual</span> <span class="n">Double_t</span> <span class="nf">Interpolate</span><span class="p">(</span><span class="n">Double_t</span> <span class="n">x</span><span class="p">,</span> <span class="n">Double_t</span> <span class="n">y</span><span class="p">,</span> <span class="n">Double_t</span> <span class="n">z</span><span class="p">);</span>
           <span class="n">Bool_t</span>   <span class="nf">IsBinOverflow</span><span class="p">(</span><span class="n">Int_t</span> <span class="n">bin</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span><span class="c1">//Return true if the bin is overflow.</span>
           <span class="n">Bool_t</span>   <span class="nf">IsBinUnderflow</span><span class="p">(</span><span class="n">Int_t</span> <span class="n">bin</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span><span class="c1">//Return true if the bin is overflow.</span>
   <span class="k">virtual</span> <span class="n">Double_t</span> <span class="nf">AndersonDarlingTest</span><span class="p">(</span><span class="k">const</span> <span class="n">TH1</span> <span class="o">*</span><span class="n">h2</span><span class="p">,</span> <span class="n">Option_t</span> <span class="o">*</span><span class="n">option</span><span class="o">=</span><span class="s">&quot;&quot;</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
<span class="c1">/// Statistical test of compatibility in shape between</span>
<span class="c1">/// this histogram and h2, using the Anderson-Darling 2 sample test.</span>
<span class="c1">/// The AD 2 sample test formula are derived from the paper</span>
<span class="c1">/// F.W Scholz, M.A. Stephens &quot;k-Sample Anderson-Darling Test&quot;.</span>
<span class="c1">/// The test is implemented in root in the ROOT::Math::GoFTest class</span>
<span class="c1">/// It is the same formula ( (6) in the paper), and also shown in this preprint</span>
<span class="c1">/// http://arxiv.org/pdf/0804.0380v1.pdf</span>
<span class="c1">/// Binned data are considered as un-binned data</span>
<span class="c1">/// with identical observation happening in the bin center.</span>
<span class="c1">/// \param[in] option is a character string to specify options</span>
<span class="c1">///    - &quot;D&quot; Put out a line of &quot;Debug&quot; printout</span>
<span class="c1">///    - &quot;T&quot; Return the normalized A-D test statistic</span>
<span class="c1">/// - Note1: Underflow and overflow are not considered in the test</span>
<span class="c1">/// - Note2:  The test works only for un-weighted histogram (i.e. representing counts)</span>
<span class="c1">/// - Note3:  The histograms are not required to have the same X axis</span>
<span class="c1">/// - Note4:  The test works only for 1-dimensional histograms</span>

   <span class="k">virtual</span> <span class="n">Double_t</span> <span class="nf">AndersonDarlingTest</span><span class="p">(</span><span class="k">const</span> <span class="n">TH1</span> <span class="o">*</span><span class="n">h2</span><span class="p">,</span> <span class="n">Double_t</span> <span class="o">&amp;</span><span class="n">advalue</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span><span class="c1">/// Same funciton as above but returning also the test statistic value</span>
   <span class="k">virtual</span> <span class="n">Double_t</span> <span class="nf">KolmogorovTest</span><span class="p">(</span><span class="k">const</span> <span class="n">TH1</span> <span class="o">*</span><span class="n">h2</span><span class="p">,</span> <span class="n">Option_t</span> <span class="o">*</span><span class="n">option</span><span class="o">=</span><span class="s">&quot;&quot;</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span><span class="c1">// statistical test of compatibility in shape between two histograms</span>
<span class="c1">/// Statistical test of compatibility in shape between</span>
<span class="c1">/// this histogram and h2, using Kolmogorov test.</span>
<span class="c1">/// Note that the KolmogorovTest (KS) test should in theory be used only for unbinned data</span>
<span class="c1">/// and not for binned data as in the case of the histogram (see NOTE 3 below).</span>
<span class="c1">/// So, before using this method blindly, read the NOTE 3.</span>
<span class="c1">/// Default: Ignore under- and overflow bins in comparison</span>
<span class="c1">/// \param[in] option is a character string to specify options</span>
<span class="c1">///    - &quot;U&quot; include Underflows in test  (also for 2-dim)</span>
<span class="c1">///    -  &quot;O&quot; include Overflows     (also valid for 2-dim)</span>
<span class="c1">///    -  &quot;N&quot; include comparison of normalizations</span>
<span class="c1">///    -  &quot;D&quot; Put out a line of &quot;Debug&quot; printout</span>
<span class="c1">///    -  &quot;M&quot; Return the Maximum Kolmogorov distance instead of prob</span>
<span class="c1">///    -  &quot;X&quot; Run the pseudo experiments post-processor with the following procedure:</span>
<span class="c1">///       make pseudoexperiments based on random values from the parent</span>
<span class="c1">///       distribution and compare the KS distance of the pseudoexperiment</span>
<span class="c1">///       to the parent distribution. Bin the KS distances in a histogram,</span>
<span class="c1">///       and then take the integral of all the KS values above the value</span>
<span class="c1">///       obtained from the original data to Monte Carlo distribution.</span>
<span class="c1">///       The number of pseudo-experiments nEXPT is currently fixed at 1000.</span>
<span class="c1">///       The function returns the integral.</span>
<span class="c1">///       (thanks to Ben Kilminster to submit this procedure). Note that</span>
<span class="c1">///       this option &quot;X&quot; is much slower.</span>
<span class="c1">/// The returned function value is the probability of test</span>
<span class="c1">///   (much less than one means NOT compatible)</span>
<span class="c1">/// Code adapted by Rene Brun from original HBOOK routine HDIFF</span>
<span class="c1">/// NOTE1</span>
<span class="c1">/// A good description of the Kolmogorov test can be seen at:</span>
<span class="c1">/// http://www.itl.nist.gov/div898/handbook/eda/section3/eda35g.htm</span>
<span class="c1">/// NOTE2</span>
<span class="c1">/// see also alternative function TH1::Chi2Test</span>
<span class="c1">/// The Kolmogorov test is assumed to give better results than Chi2Test</span>
<span class="c1">/// in case of histograms with low statistics.</span>
<span class="c1">/// NOTE3 (Jan Conrad, Fred James)</span>
<span class="c1">/// &quot;The returned value PROB is calculated such that it will be</span>
<span class="c1">/// uniformly distributed between zero and one for compatible histograms,</span>
<span class="c1">/// provided the data are not binned (or the number of bins is very large</span>
<span class="c1">/// compared with the number of events). Users who have access to unbinned</span>
<span class="c1">/// data and wish exact confidence levels should therefore not put their data</span>
<span class="c1">/// into histograms, but should call directly TMath::KolmogorovTest. On</span>
<span class="c1">/// the other hand, since TH1 is a convenient way of collecting data and</span>
<span class="c1">/// saving space, this function has been provided. However, the values of</span>
<span class="c1">/// PROB for binned data will be shifted slightly higher than expected,</span>
<span class="c1">/// depending on the effects of the binning. For example, when comparing two</span>
<span class="c1">/// uniform distributions of 500 events in 100 bins, the values of PROB,</span>
<span class="c1">/// instead of being exactly uniformly distributed between zero and one, have</span>
<span class="c1">/// a mean value of about 0.56. We can apply a useful</span>
<span class="c1">/// rule: As long as the bin width is small compared with any significant</span>
<span class="c1">/// physical effect (for example the experimental resolution) then the binning</span>
<span class="c1">/// cannot have an important effect. Therefore, we believe that for all</span>
<span class="c1">/// practical purposes, the probability value PROB is calculated correctly</span>
<span class="c1">/// provided the user is aware that:</span>
<span class="c1">/// 1. The value of PROB should not be expected to have exactly the correct</span>
<span class="c1">///    distribution for binned data.</span>
<span class="c1">/// 2. The user is responsible for seeing to it that the bin widths are</span>
<span class="c1">///    small compared with any physical phenomena of interest.</span>
<span class="c1">/// 3. The effect of binning (if any) is always to make the value of PROB</span>
<span class="c1">///    slightly too big. That is, setting an acceptance criterion of (PROB&gt;0.05</span>
<span class="c1">///    will assure that at most 5% of truly compatible histograms are rejected,</span>
<span class="c1">///    and usually somewhat less.&quot;</span>
<span class="c1">/// Note also that for GoF test of unbinned data ROOT provides also the class</span>
<span class="c1">/// ROOT::Math::GoFTest. The class has also method for doing one sample tests</span>
<span class="c1">/// (i.e. comparing the data with a given distribution).</span>

   <span class="k">virtual</span> <span class="kt">void</span>     <span class="nf">LabelsDeflate</span><span class="p">(</span><span class="n">Option_t</span> <span class="o">*</span><span class="n">axis</span><span class="o">=</span><span class="s">&quot;X&quot;</span><span class="p">);</span><span class="c1">// Reduce the number of bins for the axis passed in the option to the number of bins having a label. The method will remove only the extra bins existing after the last &quot;labeled&quot; bin. Note that if there are &quot;un-labeled&quot; bins present between &quot;labeled&quot; bins they will not be removed.</span>
   <span class="k">virtual</span> <span class="kt">void</span>     <span class="nf">LabelsInflate</span><span class="p">(</span><span class="n">Option_t</span> <span class="o">*</span><span class="n">axis</span><span class="o">=</span><span class="s">&quot;X&quot;</span><span class="p">);</span><span class="c1">//Double the number of bins for axis.Refill histogram. This function is called by TAxis::FindBin(const char *label).</span>
   <span class="k">virtual</span> <span class="kt">void</span>     <span class="nf">LabelsOption</span><span class="p">(</span><span class="n">Option_t</span> <span class="o">*</span><span class="n">option</span><span class="o">=</span><span class="s">&quot;h&quot;</span><span class="p">,</span> <span class="n">Option_t</span> <span class="o">*</span><span class="n">axis</span><span class="o">=</span><span class="s">&quot;X&quot;</span><span class="p">);</span>
<span class="c1">/// Set option(s) to draw axis with labels</span>
<span class="c1">/// \param[in] option</span>
<span class="c1">///     - &quot;a&quot; sort by alphabetic order</span>
<span class="c1">///     - &quot;&gt;&quot; sort by decreasing values</span>
<span class="c1">///     - &quot;&lt;&quot; sort by increasing values</span>
<span class="c1">///     - &quot;h&quot; draw labels horizontal</span>
<span class="c1">///     - &quot;v&quot; draw labels vertical</span>
<span class="c1">///     - &quot;u&quot; draw labels up (end of label right adjusted)</span>
<span class="c1">///     - &quot;d&quot; draw labels down (start of label left adjusted)</span>

   <span class="k">virtual</span> <span class="n">Long64_t</span> <span class="nf">Merge</span><span class="p">(</span><span class="n">TCollection</span> <span class="o">*</span><span class="n">list</span><span class="p">);</span>
<span class="c1">/// Add all histograms in the collection to this histogram.</span>
<span class="c1">/// This function computes the min/max for the x axis,</span>
<span class="c1">/// compute a new number of bins, if necessary,</span>
<span class="c1">/// add bin contents, errors and statistics.</span>
<span class="c1">/// If all histograms have bin labels, bins with identical labels</span>
<span class="c1">/// will be merged, no matter what their order is.</span>
<span class="c1">/// If overflows are present and limits are different the function will fail.</span>
<span class="c1">/// The function returns the total number of entries in the result histogram</span>
<span class="c1">/// if the merge is successful, -1 otherwise.</span>
<span class="c1">/// IMPORTANT remark. The axis x may have different number</span>
<span class="c1">/// of bins and different limits, BUT the largest bin width must be</span>
<span class="c1">/// a multiple of the smallest bin width and the upper limit must also</span>
<span class="c1">/// be a multiple of the bin width.</span>

   <span class="k">virtual</span> <span class="n">Bool_t</span>   <span class="nf">Multiply</span><span class="p">(</span><span class="n">TF1</span> <span class="o">*</span><span class="n">h1</span><span class="p">,</span> <span class="n">Double_t</span> <span class="n">c1</span><span class="o">=</span><span class="mi">1</span><span class="p">);</span><span class="c1">//Performs the operation: this = this*c1*f1. if errors are defined (see TH1::Sumw2), errors are also recalculated.  Only bins inside the function range are recomputed. IMPORTANT NOTE: If you intend to use the errors of this histogram later you should call Sumw2 before making this operation. This is particularly important if you fit the histogram after TH1::Multiply The function return kFALSE if the Multiply operation failed.</span>
   <span class="k">virtual</span> <span class="n">Bool_t</span>   <span class="nf">Multiply</span><span class="p">(</span><span class="k">const</span> <span class="n">TH1</span> <span class="o">*</span><span class="n">h1</span><span class="p">);</span><span class="c1">// Multiply this histogram by h1.  this = this*h1   If errors of this are available (TH1::Sumw2), errors are recalculated.  Note that if h1 has Sumw2 set, Sumw2 is automatically called for this if not already set.   IMPORTANT NOTE: If you intend to use the errors of this histogram later you should call Sumw2 before making this operation. This is particularly important if you fit the histogram after TH1::Multiply. The function return kFALSE if the Multiply operation failed</span>
   <span class="k">virtual</span> <span class="n">Bool_t</span>   <span class="nf">Multiply</span><span class="p">(</span><span class="k">const</span> <span class="n">TH1</span> <span class="o">*</span><span class="n">h1</span><span class="p">,</span> <span class="k">const</span> <span class="n">TH1</span> <span class="o">*</span><span class="n">h2</span><span class="p">,</span> <span class="n">Double_t</span> <span class="n">c1</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">Double_t</span> <span class="n">c2</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">Option_t</span> <span class="o">*</span><span class="n">option</span><span class="o">=</span><span class="s">&quot;&quot;</span><span class="p">);</span> <span class="c1">// *MENU*  Replace contents of this histogram by multiplication of h1 by h2. this = (c1*h1)*(c2*h2)   If errors of this are available (TH1::Sumw2), errors are recalculated. Note that if h1 or h2 have Sumw2 set, Sumw2 is automatically called for this if not already set.   IMPORTANT NOTE: If you intend to use the errors of this histogram later you should call Sumw2 before making this operation. This is particularly important if you fit the histogram after TH1::Multiply. The function return kFALSE if the Multiply operation failed.</span>
   <span class="k">virtual</span> <span class="kt">void</span>     <span class="nf">Paint</span><span class="p">(</span><span class="n">Option_t</span> <span class="o">*</span><span class="n">option</span><span class="o">=</span><span class="s">&quot;&quot;</span><span class="p">);</span><span class="c1">//Control routine to paint any kind of histograms.  This function is automatically called by TCanvas::Update.(see TH1::Draw for the list of options)</span>
   <span class="k">virtual</span> <span class="kt">void</span>     <span class="nf">Print</span><span class="p">(</span><span class="n">Option_t</span> <span class="o">*</span><span class="n">option</span><span class="o">=</span><span class="s">&quot;&quot;</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span><span class="c1">//Print some global quantities for this histogram. If option &quot;base&quot; is given, number of bins and ranges are also printed.  If option &quot;range&quot; is given, bin contents and errors are also printed for all bins in the current range (default 1--&gt;nbins).  If option &quot;all&quot; is given, bin contents and errors are also printed for all bins including under and overflows.</span>
   <span class="k">virtual</span> <span class="kt">void</span>     <span class="nf">PutStats</span><span class="p">(</span><span class="n">Double_t</span> <span class="o">*</span><span class="n">stats</span><span class="p">);</span><span class="c1">/// Replace current statistics with the values in array stats</span>
   <span class="k">virtual</span> <span class="n">TH1</span>     <span class="o">*</span><span class="nf">Rebin</span><span class="p">(</span><span class="n">Int_t</span> <span class="n">ngroup</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span><span class="o">*</span><span class="n">newname</span><span class="o">=</span><span class="s">&quot;&quot;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Double_t</span> <span class="o">*</span><span class="n">xbins</span><span class="o">=</span><span class="mi">0</span><span class="p">);</span>  <span class="c1">// *MENU*</span>
<span class="c1">/// Rebin this histogram</span>
<span class="c1">/// ### case 1  xbins=0</span>
<span class="c1">/// If newname is blank (default), the current histogram is modified and</span>
<span class="c1">/// a pointer to it is returned.</span>
<span class="c1">/// If newname is not blank, the current histogram is not modified, and a</span>
<span class="c1">/// new histogram is returned which is a Clone of the current histogram</span>
<span class="c1">/// with its name set to newname.</span>
<span class="c1">/// The parameter ngroup indicates how many bins of this have to be merged</span>
<span class="c1">/// into one bin of the result.</span>
<span class="c1">/// If the original histogram has errors stored (via Sumw2), the resulting</span>
<span class="c1">/// histograms has new errors correctly calculated.</span>
<span class="c1">/// NOTE:  If ngroup is not an exact divider of the number of bins,</span>
<span class="c1">/// the top limit of the rebinned histogram is reduced</span>
<span class="c1">/// to the upper edge of the last bin that can make a complete</span>
<span class="c1">/// group. The remaining bins are added to the overflow bin.</span>
<span class="c1">/// Statistics will be recomputed from the new bin contents.</span>
<span class="c1">/// ### case 2  xbins!=0</span>
<span class="c1">/// A new histogram is created (you should specify newname).</span>
<span class="c1">/// The parameter ngroup is the number of variable size bins in the created histogram.</span>
<span class="c1">/// The array xbins must contain ngroup+1 elements that represent the low-edges</span>
<span class="c1">/// of the bins.</span>
<span class="c1">/// If the original histogram has errors stored (via Sumw2), the resulting</span>
<span class="c1">/// histograms has new errors correctly calculated.</span>
<span class="c1">/// NOTE:  The bin edges specified in xbins should correspond to bin edges</span>
<span class="c1">/// in the original histogram. If a bin edge in the new histogram is</span>
<span class="c1">/// in the middle of a bin in the original histogram, all entries in</span>
<span class="c1">/// the split bin in the original histogram will be transfered to the</span>
<span class="c1">/// lower of the two possible bins in the new histogram. This is</span>
<span class="c1">/// probably not what you want.</span>

   <span class="k">virtual</span> <span class="n">TH1</span>     <span class="o">*</span><span class="nf">RebinX</span><span class="p">(</span><span class="n">Int_t</span> <span class="n">ngroup</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span><span class="o">*</span><span class="n">newname</span><span class="o">=</span><span class="s">&quot;&quot;</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">Rebin</span><span class="p">(</span><span class="n">ngroup</span><span class="p">,</span><span class="n">newname</span><span class="p">,</span> <span class="p">(</span><span class="n">Double_t</span><span class="o">*</span><span class="p">)</span> <span class="mi">0</span><span class="p">);</span> <span class="p">}</span>
   <span class="k">virtual</span> <span class="kt">void</span>     <span class="nf">Rebuild</span><span class="p">(</span><span class="n">Option_t</span> <span class="o">*</span><span class="n">option</span><span class="o">=</span><span class="s">&quot;&quot;</span><span class="p">);</span><span class="c1">/// Using the current bin info, recompute the arrays for contents and errors</span>
   <span class="k">virtual</span> <span class="kt">void</span>     <span class="nf">RecursiveRemove</span><span class="p">(</span><span class="n">TObject</span> <span class="o">*</span><span class="n">obj</span><span class="p">);</span><span class="c1">/// Recursively remove object from the list of functions</span>
   <span class="k">virtual</span> <span class="kt">void</span>     <span class="nf">Reset</span><span class="p">(</span><span class="n">Option_t</span> <span class="o">*</span><span class="n">option</span><span class="o">=</span><span class="s">&quot;&quot;</span><span class="p">);</span><span class="c1">//将其清除重置</span>
<span class="c1">// Reset this histogram: contents, errors, etc.</span>
<span class="c1">// if option &quot;ICE&quot; is specified, resets only Integral, Contents and Errors.  </span>
<span class="c1">// if option &quot;ICES&quot; is specified, resets only Integral, Contents , Errors and Statistics  </span>
<span class="c1">// if option &quot;M&quot;   is specified, resets also Minimum and Maximum  </span>
<span class="c1">// The option &quot;ICE&quot; is used when extending the histogram (in ExtendAxis, LabelInflate, etc..)  </span>
<span class="c1">// The option &quot;ICES is used in combination with the buffer (see BufferEmpty and BufferFill)</span>

   <span class="k">virtual</span> <span class="kt">void</span>     <span class="nf">ResetStats</span><span class="p">();</span><span class="c1">//Reset the statistics including the number of entries and replace with values calculates from bin content. The number of entries is set to the total bin content or (in case of weighted histogram) to number of effective entries.</span>
   <span class="k">virtual</span> <span class="kt">void</span>     <span class="nf">SavePrimitive</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">ostream</span> <span class="o">&amp;</span><span class="n">out</span><span class="p">,</span> <span class="n">Option_t</span> <span class="o">*</span><span class="n">option</span> <span class="o">=</span> <span class="s">&quot;&quot;</span><span class="p">);</span><span class="c1">/// Save primitive as a C++ statement(s) on output stream out</span>
   <span class="k">virtual</span> <span class="kt">void</span>     <span class="nf">Scale</span><span class="p">(</span><span class="n">Double_t</span> <span class="n">c1</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">Option_t</span> <span class="o">*</span><span class="n">option</span><span class="o">=</span><span class="s">&quot;&quot;</span><span class="p">);</span><span class="c1">//比例缩放</span>
<span class="c1">/// Multiply this histogram by a constant c1.</span>
<span class="c1">///this = c1*this</span>
<span class="c1">/// Note that both contents and errors(if any) are scaled.</span>
<span class="c1">/// This function uses the services of TH1::Add</span>
<span class="c1">/// IMPORTANT NOTE: If you intend to use the errors of this histogram later</span>
<span class="c1">/// you should call Sumw2 before making this operation.</span>
<span class="c1">/// This is particularly important if you fit the histogram after TH1::Scale</span>
<span class="c1">/// One can scale an histogram such that the bins integral is equal to</span>
<span class="c1">/// the normalization parameter via TH1::Scale(Double_t norm), where norm</span>
<span class="c1">/// is the desired normalization divided by the integral of the histogram.</span>
<span class="c1">/// If option contains &quot;width&quot; the bin contents and errors are divided</span>
<span class="c1">/// by the bin width.</span>

   <span class="k">virtual</span> <span class="kt">void</span>     <span class="nf">SetAxisColor</span><span class="p">(</span><span class="n">Color_t</span> <span class="n">color</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">Option_t</span> <span class="o">*</span><span class="n">axis</span><span class="o">=</span><span class="s">&quot;X&quot;</span><span class="p">);</span>
   <span class="k">virtual</span> <span class="kt">void</span>     <span class="nf">SetAxisRange</span><span class="p">(</span><span class="n">Double_t</span> <span class="n">xmin</span><span class="p">,</span> <span class="n">Double_t</span> <span class="n">xmax</span><span class="p">,</span> <span class="n">Option_t</span> <span class="o">*</span><span class="n">axis</span><span class="o">=</span><span class="s">&quot;X&quot;</span><span class="p">);</span>
   <span class="k">virtual</span> <span class="kt">void</span>     <span class="nf">SetBarOffset</span><span class="p">(</span><span class="n">Float_t</span> <span class="n">offset</span><span class="o">=</span><span class="mf">0.25</span><span class="p">)</span> <span class="p">{</span><span class="n">fBarOffset</span> <span class="o">=</span> <span class="n">Short_t</span><span class="p">(</span><span class="mi">1000</span><span class="o">*</span><span class="n">offset</span><span class="p">);}</span>
   <span class="k">virtual</span> <span class="kt">void</span>     <span class="nf">SetBarWidth</span><span class="p">(</span><span class="n">Float_t</span> <span class="n">width</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span> <span class="p">{</span><span class="n">fBarWidth</span> <span class="o">=</span> <span class="n">Short_t</span><span class="p">(</span><span class="mi">1000</span><span class="o">*</span><span class="n">width</span><span class="p">);}</span>
   <span class="k">virtual</span> <span class="kt">void</span>     <span class="nf">SetBinContent</span><span class="p">(</span><span class="n">Int_t</span> <span class="n">bin</span><span class="p">,</span> <span class="n">Double_t</span> <span class="n">content</span><span class="p">);</span>
<span class="c1">/// Set bin content</span>
<span class="c1">/// see convention for numbering bins in TH1::GetBin</span>
<span class="c1">/// In case the bin number is greater than the number of bins and</span>
<span class="c1">/// the timedisplay option is set or CanExtendAllAxes(),</span>
<span class="c1">/// the number of bins is automatically doubled to accommodate the new bin</span>

   <span class="k">virtual</span> <span class="kt">void</span>     <span class="nf">SetBinContent</span><span class="p">(</span><span class="n">Int_t</span> <span class="n">bin</span><span class="p">,</span> <span class="n">Int_t</span><span class="p">,</span> <span class="n">Double_t</span> <span class="n">content</span><span class="p">)</span> <span class="p">{</span> <span class="n">SetBinContent</span><span class="p">(</span><span class="n">bin</span><span class="p">,</span> <span class="n">content</span><span class="p">);</span> <span class="p">}</span>
   <span class="k">virtual</span> <span class="kt">void</span>     <span class="nf">SetBinContent</span><span class="p">(</span><span class="n">Int_t</span> <span class="n">bin</span><span class="p">,</span> <span class="n">Int_t</span><span class="p">,</span> <span class="n">Int_t</span><span class="p">,</span> <span class="n">Double_t</span> <span class="n">content</span><span class="p">)</span> <span class="p">{</span> <span class="n">SetBinContent</span><span class="p">(</span><span class="n">bin</span><span class="p">,</span> <span class="n">content</span><span class="p">);</span> <span class="p">}</span>
   <span class="k">virtual</span> <span class="kt">void</span>     <span class="nf">SetBinError</span><span class="p">(</span><span class="n">Int_t</span> <span class="n">bin</span><span class="p">,</span> <span class="n">Double_t</span> <span class="n">error</span><span class="p">);</span><span class="c1">/// see convention for numbering bins in TH1::GetBin</span>
   <span class="k">virtual</span> <span class="kt">void</span>     <span class="nf">SetBinError</span><span class="p">(</span><span class="n">Int_t</span> <span class="n">binx</span><span class="p">,</span> <span class="n">Int_t</span> <span class="n">biny</span><span class="p">,</span> <span class="n">Double_t</span> <span class="n">error</span><span class="p">);</span><span class="c1">/// see convention for numbering bins in TH1::GetBin</span>
   <span class="k">virtual</span> <span class="kt">void</span>     <span class="nf">SetBinError</span><span class="p">(</span><span class="n">Int_t</span> <span class="n">binx</span><span class="p">,</span> <span class="n">Int_t</span> <span class="n">biny</span><span class="p">,</span> <span class="n">Int_t</span> <span class="n">binz</span><span class="p">,</span> <span class="n">Double_t</span> <span class="n">error</span><span class="p">);</span><span class="c1">// see convention for numbering bins in TH1::GetBin</span>
   <span class="k">virtual</span> <span class="kt">void</span>     <span class="nf">SetBins</span><span class="p">(</span><span class="n">Int_t</span> <span class="n">nx</span><span class="p">,</span> <span class="n">Double_t</span> <span class="n">xmin</span><span class="p">,</span> <span class="n">Double_t</span> <span class="n">xmax</span><span class="p">);</span>
<span class="c1">/// Redefine  x axis parameters.</span>
<span class="c1">/// The X axis parameters are modified.</span>
<span class="c1">/// The bins content array is resized</span>
<span class="c1">/// if errors (Sumw2) the errors array is resized</span>
<span class="c1">/// The previous bin contents are lost</span>
<span class="c1">/// To change only the axis limits, see TAxis::SetRange</span>

   <span class="k">virtual</span> <span class="kt">void</span>     <span class="nf">SetBins</span><span class="p">(</span><span class="n">Int_t</span> <span class="n">nx</span><span class="p">,</span> <span class="k">const</span> <span class="n">Double_t</span> <span class="o">*</span><span class="n">xBins</span><span class="p">);</span>
<span class="c1">/// Redefine  x axis parameters with variable bin sizes.</span>
<span class="c1">/// The X axis parameters are modified.</span>
<span class="c1">/// The bins content array is resized</span>
<span class="c1">/// if errors (Sumw2) the errors array is resized</span>
<span class="c1">/// The previous bin contents are lost</span>
<span class="c1">/// To change only the axis limits, see TAxis::SetRange</span>
<span class="c1">/// xBins is supposed to be of length nx+1</span>

   <span class="k">virtual</span> <span class="kt">void</span>     <span class="nf">SetBins</span><span class="p">(</span><span class="n">Int_t</span> <span class="n">nx</span><span class="p">,</span> <span class="n">Double_t</span> <span class="n">xmin</span><span class="p">,</span> <span class="n">Double_t</span> <span class="n">xmax</span><span class="p">,</span> <span class="n">Int_t</span> <span class="n">ny</span><span class="p">,</span> <span class="n">Double_t</span> <span class="n">ymin</span><span class="p">,</span> <span class="n">Double_t</span> <span class="n">ymax</span><span class="p">);</span>
<span class="c1">/// Redefine  x and y axis parameters.</span>
<span class="c1">/// The X and Y axis parameters are modified.</span>
<span class="c1">/// The bins content array is resized</span>
<span class="c1">/// if errors (Sumw2) the errors array is resized</span>
<span class="c1">/// The previous bin contents are lost</span>
<span class="c1">/// To change only the axis limits, see TAxis::SetRange</span>

   <span class="k">virtual</span> <span class="kt">void</span>     <span class="nf">SetBins</span><span class="p">(</span><span class="n">Int_t</span> <span class="n">nx</span><span class="p">,</span> <span class="k">const</span> <span class="n">Double_t</span> <span class="o">*</span><span class="n">xBins</span><span class="p">,</span> <span class="n">Int_t</span> <span class="n">ny</span><span class="p">,</span> <span class="k">const</span> <span class="n">Double_t</span> <span class="o">*</span><span class="n">yBins</span><span class="p">);</span>
<span class="c1">/// Redefine  x and y axis parameters with variable bin sizes.</span>
<span class="c1">/// The X and Y axis parameters are modified.</span>
<span class="c1">/// The bins content array is resized</span>
<span class="c1">/// if errors (Sumw2) the errors array is resized</span>
<span class="c1">/// The previous bin contents are lost</span>
<span class="c1">/// To change only the axis limits, see TAxis::SetRange</span>
<span class="c1">/// xBins is supposed to be of length nx+1, yBins is supposed to be of length ny+1</span>

   <span class="k">virtual</span> <span class="kt">void</span>     <span class="nf">SetBins</span><span class="p">(</span><span class="n">Int_t</span> <span class="n">nx</span><span class="p">,</span> <span class="n">Double_t</span> <span class="n">xmin</span><span class="p">,</span> <span class="n">Double_t</span> <span class="n">xmax</span><span class="p">,</span> <span class="n">Int_t</span> <span class="n">ny</span><span class="p">,</span> <span class="n">Double_t</span> <span class="n">ymin</span><span class="p">,</span> <span class="n">Double_t</span> <span class="n">ymax</span><span class="p">,</span>
                            <span class="n">Int_t</span> <span class="n">nz</span><span class="p">,</span> <span class="n">Double_t</span> <span class="n">zmin</span><span class="p">,</span> <span class="n">Double_t</span> <span class="n">zmax</span><span class="p">);</span>
<span class="c1">/// Redefine  x, y and z axis parameters.</span>
<span class="c1">/// The X, Y and Z axis parameters are modified.</span>
<span class="c1">/// The bins content array is resized</span>
<span class="c1">/// if errors (Sumw2) the errors array is resized</span>
<span class="c1">/// The previous bin contents are lost</span>
<span class="c1">/// To change only the axis limits, see TAxis::SetRange</span>

   <span class="k">virtual</span> <span class="kt">void</span>     <span class="nf">SetBins</span><span class="p">(</span><span class="n">Int_t</span> <span class="n">nx</span><span class="p">,</span> <span class="k">const</span> <span class="n">Double_t</span> <span class="o">*</span><span class="n">xBins</span><span class="p">,</span> <span class="n">Int_t</span> <span class="n">ny</span><span class="p">,</span> <span class="k">const</span> <span class="n">Double_t</span> <span class="o">*</span> <span class="n">yBins</span><span class="p">,</span> <span class="n">Int_t</span> <span class="n">nz</span><span class="p">,</span>
                            <span class="k">const</span> <span class="n">Double_t</span> <span class="o">*</span><span class="n">zBins</span><span class="p">);</span>
<span class="c1">/// Redefine  x, y and z axis parameters with variable bin sizes.</span>
<span class="c1">/// The X, Y and Z axis parameters are modified.</span>
<span class="c1">/// The bins content array is resized</span>
<span class="c1">/// if errors (Sumw2) the errors array is resized</span>
<span class="c1">/// The previous bin contents are lost</span>
<span class="c1">/// To change only the axis limits, see TAxis::SetRange</span>
<span class="c1">/// xBins is supposed to be of length nx+1, yBins is supposed to be of length ny+1,</span>
<span class="c1">/// zBins is supposed to be of length nz+1</span>

   <span class="k">virtual</span> <span class="kt">void</span>     <span class="nf">SetBinsLength</span><span class="p">(</span><span class="n">Int_t</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span> <span class="c1">//redefined in derived classes       Set total number of bins including under/overflow   Reallocate bin contents array</span>
   <span class="k">virtual</span> <span class="kt">void</span>     <span class="nf">SetBinErrorOption</span><span class="p">(</span><span class="n">EBinErrorOpt</span> <span class="n">type</span><span class="p">)</span> <span class="p">{</span> <span class="n">fBinStatErrOpt</span> <span class="o">=</span> <span class="n">type</span><span class="p">;</span> <span class="p">}</span>
   <span class="k">virtual</span> <span class="kt">void</span>     <span class="nf">SetBuffer</span><span class="p">(</span><span class="n">Int_t</span> <span class="n">buffersize</span><span class="p">,</span> <span class="n">Option_t</span> <span class="o">*</span><span class="n">option</span><span class="o">=</span><span class="s">&quot;&quot;</span><span class="p">);</span><span class="c1">/// set the maximum number of entries to be kept in the buffer</span>
   <span class="k">virtual</span> <span class="n">UInt_t</span>   <span class="nf">SetCanExtend</span><span class="p">(</span><span class="n">UInt_t</span> <span class="n">extendBitMask</span><span class="p">);</span>
<span class="c1">/// make the histogram axes extendable / not extendable according to the bit mask</span>
<span class="c1">/// returns the previous bit mask specifying which axes are extendable</span>

   <span class="k">virtual</span> <span class="kt">void</span>     <span class="nf">SetContent</span><span class="p">(</span><span class="k">const</span> <span class="n">Double_t</span> <span class="o">*</span><span class="n">content</span><span class="p">);</span><span class="c1">/// Replace bin contents by the contents of array content</span>
   <span class="k">virtual</span> <span class="kt">void</span>     <span class="nf">SetContour</span><span class="p">(</span><span class="n">Int_t</span> <span class="n">nlevels</span><span class="p">,</span> <span class="k">const</span> <span class="n">Double_t</span> <span class="o">*</span><span class="n">levels</span><span class="o">=</span><span class="mi">0</span><span class="p">);</span>
<span class="c1">/// Set the number and values of contour levels.</span>
<span class="c1">/// By default the number of contour levels is set to 20. The contours values</span>
<span class="c1">/// in the array &quot;levels&quot; should be specified in increasing order.</span>
<span class="c1">/// if argument levels = 0 or missing, equidistant contours are computed</span>

   <span class="k">virtual</span> <span class="kt">void</span>     <span class="nf">SetContourLevel</span><span class="p">(</span><span class="n">Int_t</span> <span class="n">level</span><span class="p">,</span> <span class="n">Double_t</span> <span class="n">value</span><span class="p">);</span><span class="c1">/// Set value for one contour level.</span>
   <span class="k">static</span>  <span class="kt">void</span>     <span class="nf">SetDefaultBufferSize</span><span class="p">(</span><span class="n">Int_t</span> <span class="n">buffersize</span><span class="o">=</span><span class="mi">1000</span><span class="p">);</span>
<span class="c1">/// static function to set the default buffer size for automatic histograms.</span>
<span class="c1">/// When an histogram is created with one of its axis lower limit greater</span>
<span class="c1">/// or equal to its upper limit, the function SetBuffer is automatically</span>
<span class="c1">/// called with the default buffer size.</span>

   <span class="k">static</span>  <span class="kt">void</span>     <span class="nf">SetDefaultSumw2</span><span class="p">(</span><span class="n">Bool_t</span> <span class="n">sumw2</span><span class="o">=</span><span class="n">kTRUE</span><span class="p">);</span>
<span class="c1">/// static function.</span>
<span class="c1">/// When this static function is called with sumw2=kTRUE, all new</span>
<span class="c1">/// histograms will automatically activate the storage</span>
<span class="c1">/// of the sum of squares of errors, ie TH1::Sumw2 is automatically called.</span>

   <span class="k">virtual</span> <span class="kt">void</span>     <span class="nf">SetDirectory</span><span class="p">(</span><span class="n">TDirectory</span> <span class="o">*</span><span class="n">dir</span><span class="p">);</span>
<span class="c1">/// By default when an histogram is created, it is added to the list</span>
<span class="c1">/// of histogram objects in the current directory in memory.</span>
<span class="c1">/// Remove reference to this histogram from current directory and add</span>
<span class="c1">/// reference to new directory dir. dir can be 0 in which case the</span>
<span class="c1">/// histogram does not belong to any directory.</span>
<span class="c1">/// Note that the directory is not a real property of the histogram and</span>
<span class="c1">/// it will not be copied when the histogram is copied or cloned.</span>
<span class="c1">/// If the user wants to have the copied (cloned) histogram in the same</span>
<span class="c1">/// directory, he needs to set again the directory using SetDirectory to the</span>
<span class="c1">/// copied histograms</span>

   <span class="k">virtual</span> <span class="kt">void</span>     <span class="nf">SetEntries</span><span class="p">(</span><span class="n">Double_t</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span><span class="n">fEntries</span> <span class="o">=</span> <span class="n">n</span><span class="p">;};</span>
   <span class="k">virtual</span> <span class="kt">void</span>     <span class="nf">SetError</span><span class="p">(</span><span class="k">const</span> <span class="n">Double_t</span> <span class="o">*</span><span class="n">error</span><span class="p">);</span><span class="c1">/// Replace bin errors by values in array error.</span>
   <span class="k">virtual</span> <span class="kt">void</span>     <span class="nf">SetLabelColor</span><span class="p">(</span><span class="n">Color_t</span> <span class="n">color</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">Option_t</span> <span class="o">*</span><span class="n">axis</span><span class="o">=</span><span class="s">&quot;X&quot;</span><span class="p">);</span>
   <span class="k">virtual</span> <span class="kt">void</span>     <span class="nf">SetLabelFont</span><span class="p">(</span><span class="n">Style_t</span> <span class="n">font</span><span class="o">=</span><span class="mi">62</span><span class="p">,</span> <span class="n">Option_t</span> <span class="o">*</span><span class="n">axis</span><span class="o">=</span><span class="s">&quot;X&quot;</span><span class="p">);</span>
   <span class="k">virtual</span> <span class="kt">void</span>     <span class="nf">SetLabelOffset</span><span class="p">(</span><span class="n">Float_t</span> <span class="n">offset</span><span class="o">=</span><span class="mf">0.005</span><span class="p">,</span> <span class="n">Option_t</span> <span class="o">*</span><span class="n">axis</span><span class="o">=</span><span class="s">&quot;X&quot;</span><span class="p">);</span>
   <span class="k">virtual</span> <span class="kt">void</span>     <span class="nf">SetLabelSize</span><span class="p">(</span><span class="n">Float_t</span> <span class="n">size</span><span class="o">=</span><span class="mf">0.02</span><span class="p">,</span> <span class="n">Option_t</span> <span class="o">*</span><span class="n">axis</span><span class="o">=</span><span class="s">&quot;X&quot;</span><span class="p">);</span>

   <span class="cm">/*</span>
<span class="cm">    * Set the minimum / maximum value for the Y axis (1-D histograms) or Z axis (2-D histograms)</span>
<span class="cm">    *   By default the maximum / minimum value used in drawing is the maximum / minimum value of the histogram</span>
<span class="cm">    * plus a margin of 10%. If these functions are called, the values are used without any extra margin.</span>
<span class="cm">    */</span>
   <span class="k">virtual</span> <span class="kt">void</span>     <span class="nf">SetMaximum</span><span class="p">(</span><span class="n">Double_t</span> <span class="n">maximum</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1111</span><span class="p">)</span> <span class="p">{</span> <span class="n">fMaximum</span> <span class="o">=</span> <span class="n">maximum</span><span class="p">;</span> <span class="p">};</span> <span class="c1">// *MENU*  Set the minimum / maximum value for the Y axis (1-D histograms) or Z axis (2-D histograms). By default the maximum / minimum value used in drawing is the maximum / minimum value of the histogram plus a margin of 10\%. If these functions are called, the values are used without any extra margin.</span>
   <span class="k">virtual</span> <span class="kt">void</span>     <span class="nf">SetMinimum</span><span class="p">(</span><span class="n">Double_t</span> <span class="n">minimum</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1111</span><span class="p">)</span> <span class="p">{</span> <span class="n">fMinimum</span> <span class="o">=</span> <span class="n">minimum</span><span class="p">;</span> <span class="p">};</span> <span class="c1">// *MENU*</span>

   <span class="k">virtual</span> <span class="kt">void</span>     <span class="nf">SetName</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">);</span> <span class="c1">// *MENU*  Change the name of this histogram. Histograms are named objects in a THashList. We must update the hashlist if we change the name. We protect this operation</span>
   <span class="k">virtual</span> <span class="kt">void</span>     <span class="nf">SetNameTitle</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">title</span><span class="p">);</span><span class="c1">//Change the name and title of this histogram. Histograms are named objects in a THashList. We must update the hashlist if we change the name</span>
   <span class="k">virtual</span> <span class="kt">void</span>     <span class="nf">SetNdivisions</span><span class="p">(</span><span class="n">Int_t</span> <span class="n">n</span><span class="o">=</span><span class="mi">510</span><span class="p">,</span> <span class="n">Option_t</span> <span class="o">*</span><span class="n">axis</span><span class="o">=</span><span class="s">&quot;X&quot;</span><span class="p">);</span>
   <span class="k">virtual</span> <span class="kt">void</span>     <span class="nf">SetNormFactor</span><span class="p">(</span><span class="n">Double_t</span> <span class="n">factor</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span><span class="n">fNormFactor</span> <span class="o">=</span> <span class="n">factor</span><span class="p">;}</span>
   <span class="k">virtual</span> <span class="kt">void</span>     <span class="nf">SetStats</span><span class="p">(</span><span class="n">Bool_t</span> <span class="n">stats</span><span class="o">=</span><span class="n">kTRUE</span><span class="p">);</span> <span class="c1">// *MENU*</span>
<span class="c1">/// Set statistics option on/off</span>
<span class="c1">/// By default, the statistics box is drawn.</span>
<span class="c1">/// The paint options can be selected via gStyle-&gt;SetOptStats.</span>
<span class="c1">/// This function sets/resets the kNoStats bin in the histogram object.</span>
<span class="c1">/// It has priority over the Style option.</span>

   <span class="k">virtual</span> <span class="kt">void</span>     <span class="nf">SetOption</span><span class="p">(</span><span class="n">Option_t</span> <span class="o">*</span><span class="n">option</span><span class="o">=</span><span class="s">&quot; &quot;</span><span class="p">)</span> <span class="p">{</span><span class="n">fOption</span> <span class="o">=</span> <span class="n">option</span><span class="p">;}</span>
   <span class="k">virtual</span> <span class="kt">void</span>     <span class="nf">SetTickLength</span><span class="p">(</span><span class="n">Float_t</span> <span class="n">length</span><span class="o">=</span><span class="mf">0.02</span><span class="p">,</span> <span class="n">Option_t</span> <span class="o">*</span><span class="n">axis</span><span class="o">=</span><span class="s">&quot;X&quot;</span><span class="p">);</span>
   <span class="k">virtual</span> <span class="kt">void</span>     <span class="nf">SetTitleFont</span><span class="p">(</span><span class="n">Style_t</span> <span class="n">font</span><span class="o">=</span><span class="mi">62</span><span class="p">,</span> <span class="n">Option_t</span> <span class="o">*</span><span class="n">axis</span><span class="o">=</span><span class="s">&quot;X&quot;</span><span class="p">);</span>
   <span class="k">virtual</span> <span class="kt">void</span>     <span class="nf">SetTitleOffset</span><span class="p">(</span><span class="n">Float_t</span> <span class="n">offset</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">Option_t</span> <span class="o">*</span><span class="n">axis</span><span class="o">=</span><span class="s">&quot;X&quot;</span><span class="p">);</span>
   <span class="k">virtual</span> <span class="kt">void</span>     <span class="nf">SetTitleSize</span><span class="p">(</span><span class="n">Float_t</span> <span class="n">size</span><span class="o">=</span><span class="mf">0.02</span><span class="p">,</span> <span class="n">Option_t</span> <span class="o">*</span><span class="n">axis</span><span class="o">=</span><span class="s">&quot;X&quot;</span><span class="p">);</span>
   <span class="k">virtual</span> <span class="kt">void</span>     <span class="nf">SetTitle</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">title</span><span class="p">);</span>  <span class="c1">// *MENU*  Change (i.e. set) the title. if title is in the form &quot;stringt;stringx;stringy;stringz&quot; the histogram title is set to stringt, the x axis title to stringx, the y axis title to stringy, and the z axis title to stringz. To insert the character &quot;;&quot; in one of the titles, one should use &quot;\#;&quot; or &quot;\#semicolon&quot;.</span>
   <span class="k">virtual</span> <span class="kt">void</span>     <span class="nf">SetXTitle</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">title</span><span class="p">)</span> <span class="p">{</span><span class="n">fXaxis</span><span class="p">.</span><span class="n">SetTitle</span><span class="p">(</span><span class="n">title</span><span class="p">);}</span>
   <span class="k">virtual</span> <span class="kt">void</span>     <span class="nf">SetYTitle</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">title</span><span class="p">)</span> <span class="p">{</span><span class="n">fYaxis</span><span class="p">.</span><span class="n">SetTitle</span><span class="p">(</span><span class="n">title</span><span class="p">);}</span>
   <span class="k">virtual</span> <span class="kt">void</span>     <span class="nf">SetZTitle</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">title</span><span class="p">)</span> <span class="p">{</span><span class="n">fZaxis</span><span class="p">.</span><span class="n">SetTitle</span><span class="p">(</span><span class="n">title</span><span class="p">);}</span>
   <span class="k">virtual</span> <span class="n">TH1</span>     <span class="o">*</span><span class="nf">ShowBackground</span><span class="p">(</span><span class="n">Int_t</span> <span class="n">niter</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span> <span class="n">Option_t</span> <span class="o">*</span><span class="n">option</span><span class="o">=</span><span class="s">&quot;same&quot;</span><span class="p">);</span> <span class="c1">// *MENU*</span>
<span class="c1">/// This function calculates the background spectrum in this histogram.</span>
<span class="c1">/// The background is returned as a histogram.</span>
<span class="c1">/// \param[in] niter number of iterations (default value = 2)</span>
<span class="c1">///     Increasing niter make the result smoother and lower.</span>
<span class="c1">/// \param[in] option may contain one of the following options</span>
<span class="c1">///  - to set the direction parameter</span>
<span class="c1">///    &quot;BackDecreasingWindow&quot;. By default the direction is BackIncreasingWindow</span>
<span class="c1">///  - filterOrder-order of clipping filter (default &quot;BackOrder2&quot;)</span>
<span class="c1">///    possible values= &quot;BackOrder4&quot; &quot;BackOrder6&quot; &quot;BackOrder8&quot;</span>
<span class="c1">///  - &quot;nosmoothing&quot; - if selected, the background is not smoothed</span>
<span class="c1">///    By default the background is smoothed.</span>
<span class="c1">///  - smoothWindow - width of smoothing window, (default is &quot;BackSmoothing3&quot;)</span>
<span class="c1">///    possible values= &quot;BackSmoothing5&quot; &quot;BackSmoothing7&quot; &quot;BackSmoothing9&quot;</span>
<span class="c1">///    &quot;BackSmoothing11&quot; &quot;BackSmoothing13&quot; &quot;BackSmoothing15&quot;</span>
<span class="c1">///  - &quot;nocompton&quot; - if selected the estimation of Compton edge</span>
<span class="c1">///    will be not be included   (by default the compton estimation is set)</span>
<span class="c1">///  - &quot;same&quot; if this option is specified, the resulting background</span>
<span class="c1">///    histogram is superimposed on the picture in the current pad.</span>
<span class="c1">///    This option is given by default.</span>
<span class="c1">/// NOTE that the background is only evaluated in the current range of this histogram.</span>
<span class="c1">/// i.e., if this has a bin range (set via h-&gt;GetXaxis()-&gt;SetRange(binmin, binmax),</span>
<span class="c1">/// the returned histogram will be created with the same number of bins</span>
<span class="c1">/// as this input histogram, but only bins from binmin to binmax will be filled</span>
<span class="c1">/// with the estimated background.</span>

   <span class="k">virtual</span> <span class="n">Int_t</span>    <span class="nf">ShowPeaks</span><span class="p">(</span><span class="n">Double_t</span> <span class="n">sigma</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">Option_t</span> <span class="o">*</span><span class="n">option</span><span class="o">=</span><span class="s">&quot;&quot;</span><span class="p">,</span> <span class="n">Double_t</span> <span class="n">threshold</span><span class="o">=</span><span class="mf">0.05</span><span class="p">);</span> <span class="c1">// *MENU*</span>
<span class="c1">/// Interface to TSpectrum::Search.</span>
<span class="c1">/// The function finds peaks in this histogram where the width is &gt; sigma</span>
<span class="c1">/// and the peak maximum greater than threshold*maximum bin content of this.</span>
<span class="c1">/// For more details see TSpectrum::Search.</span>
<span class="c1">/// Note the difference in the default value for option compared to TSpectrum::Search</span>
<span class="c1">/// option=&quot;&quot; by default (instead of &quot;goff&quot;).</span>

   <span class="k">virtual</span> <span class="kt">void</span>     <span class="nf">Smooth</span><span class="p">(</span><span class="n">Int_t</span> <span class="n">ntimes</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">Option_t</span> <span class="o">*</span><span class="n">option</span><span class="o">=</span><span class="s">&quot;&quot;</span><span class="p">);</span> <span class="c1">// *MENU* Smooth bin contents of this histogram. if option contains &quot;R&quot; smoothing is applied only to the bins defined in the X axis range (default is to smooth all bins). Bin contents are replaced by their smooth values. Errors (if any) are not modified. the smoothing procedure is repeated ntimes (default=1)</span>
   <span class="k">static</span>  <span class="kt">void</span>     <span class="nf">SmoothArray</span><span class="p">(</span><span class="n">Int_t</span> <span class="n">NN</span><span class="p">,</span> <span class="n">Double_t</span> <span class="o">*</span><span class="n">XX</span><span class="p">,</span> <span class="n">Int_t</span> <span class="n">ntimes</span><span class="o">=</span><span class="mi">1</span><span class="p">);</span><span class="c1">//smooth array xx, translation of Hbook routine hsmoof.F    based on algorithm 353QH twice presented by J. Friedman in Proc.of the 1974 CERN School of Computing, Norway, 11-24 August, 1974.</span>
   <span class="k">static</span>  <span class="kt">void</span>     <span class="nf">StatOverflows</span><span class="p">(</span><span class="n">Bool_t</span> <span class="n">flag</span><span class="o">=</span><span class="n">kTRUE</span><span class="p">);</span>
<span class="c1">/// if flag=kTRUE, underflows and overflows are used by the Fill functions</span>
<span class="c1">/// in the computation of statistics (mean value, StdDev).</span>
<span class="c1">/// By default, underflows or overflows are not used.</span>

   <span class="k">virtual</span> <span class="kt">void</span>     <span class="nf">Sumw2</span><span class="p">(</span><span class="n">Bool_t</span> <span class="n">flag</span> <span class="o">=</span> <span class="n">kTRUE</span><span class="p">);</span>
<span class="c1">/// Create structure to store sum of squares of weights.</span>
<span class="c1">/// if histogram is already filled, the sum of squares of weights</span>
<span class="c1">/// is filled with the existing bin contents</span>
<span class="c1">/// The error per bin will be computed as sqrt(sum of squares of weight)</span>
<span class="c1">/// for each bin.</span>
<span class="c1">/// This function is automatically called when the histogram is created</span>
<span class="c1">/// if the static function TH1::SetDefaultSumw2 has been called before.</span>
<span class="c1">/// If flag = false the structure is deleted</span>

   <span class="kt">void</span>             <span class="nf">UseCurrentStyle</span><span class="p">();</span><span class="c1">///Copy current attributes from/to current style</span>
   <span class="k">static</span>  <span class="n">TH1</span>     <span class="o">*</span><span class="nf">TransformHisto</span><span class="p">(</span><span class="n">TVirtualFFT</span> <span class="o">*</span><span class="n">fft</span><span class="p">,</span> <span class="n">TH1</span><span class="o">*</span> <span class="n">h_output</span><span class="p">,</span>  <span class="n">Option_t</span> <span class="o">*</span><span class="n">option</span><span class="p">);</span>
<span class="c1">/// For a given transform (first parameter), fills the histogram (second parameter)</span>
<span class="c1">/// with the transform output data, specified in the third parameter</span>
<span class="c1">/// If the 2nd parameter h_output is empty, a new histogram (TH1D or TH2D) is created</span>
<span class="c1">/// and the user is responsible for deleting it.</span>
<span class="c1">/// Available options:</span>
<span class="c1">/// - &quot;RE&quot; - real part of the output</span>
<span class="c1">/// - &quot;IM&quot; - imaginary part of the output</span>
<span class="c1">/// - &quot;MAG&quot; - magnitude of the output</span>
<span class="c1">/// - &quot;PH&quot;  - phase of the output</span>



   <span class="c1">// TODO: Remove obsolete methods in v6-04</span>
   <span class="k">virtual</span> <span class="n">Double_t</span> <span class="nf">GetCellContent</span><span class="p">(</span><span class="n">Int_t</span> <span class="n">binx</span><span class="p">,</span> <span class="n">Int_t</span> <span class="n">biny</span><span class="p">)</span> <span class="k">const</span>
                        <span class="p">{</span> <span class="n">Obsolete</span><span class="p">(</span><span class="s">&quot;GetCellContent&quot;</span><span class="p">,</span> <span class="s">&quot;v6-00&quot;</span><span class="p">,</span> <span class="s">&quot;v6-04&quot;</span><span class="p">);</span> <span class="k">return</span> <span class="n">GetBinContent</span><span class="p">(</span><span class="n">GetBin</span><span class="p">(</span><span class="n">binx</span><span class="p">,</span> <span class="n">biny</span><span class="p">));</span> <span class="p">}</span>
   <span class="k">virtual</span> <span class="n">Double_t</span> <span class="nf">GetCellError</span><span class="p">(</span><span class="n">Int_t</span> <span class="n">binx</span><span class="p">,</span> <span class="n">Int_t</span> <span class="n">biny</span><span class="p">)</span> <span class="k">const</span>
                        <span class="p">{</span> <span class="n">Obsolete</span><span class="p">(</span><span class="s">&quot;GetCellError&quot;</span><span class="p">,</span> <span class="s">&quot;v6-00&quot;</span><span class="p">,</span> <span class="s">&quot;v6-04&quot;</span><span class="p">);</span> <span class="k">return</span> <span class="n">GetBinError</span><span class="p">(</span><span class="n">binx</span><span class="p">,</span> <span class="n">biny</span><span class="p">);</span> <span class="p">}</span>
   <span class="k">virtual</span> <span class="kt">void</span>     <span class="nf">RebinAxis</span><span class="p">(</span><span class="n">Double_t</span> <span class="n">x</span><span class="p">,</span> <span class="n">TAxis</span> <span class="o">*</span><span class="n">axis</span><span class="p">)</span>
                        <span class="p">{</span> <span class="n">Obsolete</span><span class="p">(</span><span class="s">&quot;RebinAxis&quot;</span><span class="p">,</span> <span class="s">&quot;v6-00&quot;</span><span class="p">,</span> <span class="s">&quot;v6-04&quot;</span><span class="p">);</span> <span class="n">ExtendAxis</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">axis</span><span class="p">);</span> <span class="p">}</span>
   <span class="k">virtual</span> <span class="kt">void</span>     <span class="nf">SetCellContent</span><span class="p">(</span><span class="n">Int_t</span> <span class="n">binx</span><span class="p">,</span> <span class="n">Int_t</span> <span class="n">biny</span><span class="p">,</span> <span class="n">Double_t</span> <span class="n">content</span><span class="p">)</span>
                        <span class="p">{</span> <span class="n">Obsolete</span><span class="p">(</span><span class="s">&quot;SetCellContent&quot;</span><span class="p">,</span> <span class="s">&quot;v6-00&quot;</span><span class="p">,</span> <span class="s">&quot;v6-04&quot;</span><span class="p">);</span> <span class="n">SetBinContent</span><span class="p">(</span><span class="n">GetBin</span><span class="p">(</span><span class="n">binx</span><span class="p">,</span> <span class="n">biny</span><span class="p">),</span> <span class="n">content</span><span class="p">);</span> <span class="p">}</span>
   <span class="k">virtual</span> <span class="kt">void</span>     <span class="nf">SetCellError</span><span class="p">(</span><span class="n">Int_t</span> <span class="n">binx</span><span class="p">,</span> <span class="n">Int_t</span> <span class="n">biny</span><span class="p">,</span> <span class="n">Double_t</span> <span class="n">content</span><span class="p">)</span>
                        <span class="p">{</span> <span class="n">Obsolete</span><span class="p">(</span><span class="s">&quot;SetCellError&quot;</span><span class="p">,</span> <span class="s">&quot;v6-00&quot;</span><span class="p">,</span> <span class="s">&quot;v6-04&quot;</span><span class="p">);</span> <span class="n">SetBinError</span><span class="p">(</span><span class="n">binx</span><span class="p">,</span> <span class="n">biny</span><span class="p">,</span> <span class="n">content</span><span class="p">);</span> <span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="code">
<h2>code<a class="headerlink" href="#code" title="永久链接至标题">¶</a></h2>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">TH1F</span> <span class="o">*</span><span class="n">h1</span><span class="o">=</span><span class="k">new</span> <span class="n">TH1F</span><span class="p">(</span><span class="s">&quot;stats name&quot;</span><span class="p">,</span><span class="s">&quot;title name&quot;</span><span class="p">,</span><span class="n">number</span> <span class="n">of</span> <span class="n">bins</span><span class="p">,</span><span class="n">min</span><span class="p">,</span><span class="n">max</span><span class="p">);</span>
<span class="n">TH1F</span> <span class="o">*</span><span class="n">h1</span><span class="o">=</span><span class="k">new</span> <span class="n">TH1F</span><span class="p">(</span><span class="s">&quot;stats name&quot;</span><span class="p">,</span><span class="s">&quot;title name;X axis;Y axis&quot;</span><span class="p">,</span><span class="n">number</span> <span class="n">of</span> <span class="n">bins</span><span class="p">,</span><span class="n">min</span><span class="p">,</span><span class="n">max</span><span class="p">);</span>
 <span class="kt">float</span> <span class="n">x</span><span class="o">=</span><span class="n">gRandom</span><span class="o">-&gt;</span><span class="n">Uniform</span><span class="p">(</span><span class="o">-</span><span class="mf">5.</span><span class="p">,</span><span class="mf">5.</span><span class="p">);</span>
 <span class="n">h1</span><span class="o">-&gt;</span><span class="n">Fill</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>                       <span class="c1">//均匀分布</span>
<span class="n">h1</span><span class="o">-&gt;</span><span class="n">FillRandom</span><span class="p">(</span><span class="s">&quot;gaus&quot;</span><span class="p">,</span><span class="mi">50000</span><span class="p">);</span>       <span class="c1">//</span>
<span class="n">h1</span><span class="o">-&gt;</span><span class="n">Draw</span><span class="p">();</span>
</pre></div>
</div>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">//循环创建图片</span>
<span class="n">TH1D</span>  <span class="n">h</span><span class="p">[</span><span class="mi">16</span><span class="p">];</span>
<span class="kt">char</span> <span class="n">Stringtemp</span><span class="p">[</span><span class="mi">256</span><span class="p">];</span>
<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="mi">16</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">){</span> 
  <span class="n">sprintf</span><span class="p">(</span><span class="n">Stringtemp</span><span class="p">,</span><span class="s">&quot;h[%d]&quot;</span><span class="p">,</span><span class="n">i</span><span class="p">);</span><span class="c1">//这样创建数组名不好，直接 &quot;h%d&quot;这样好</span>
  <span class="n">h</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">=</span><span class="k">new</span> <span class="n">TH1D</span><span class="p">(</span><span class="n">Stringtemp</span><span class="p">,</span><span class="s">&quot;&quot;</span><span class="p">,</span><span class="mi">4096</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">4096</span><span class="p">);</span>
<span class="p">}</span> 
</pre></div>
</div>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">//默认情况下，Draw 将会清空当 前Pad 再画当前直方图，如想要一个图上多个直方图，将第二个及之后的直方图 Option_t 设为 &quot;same&quot;。</span>
  <span class="n">TH1D</span> <span class="o">*</span><span class="n">h</span><span class="o">=</span><span class="k">new</span> <span class="n">TH1D</span><span class="p">(</span><span class="s">&quot;h&quot;</span><span class="p">,</span><span class="s">&quot;the title&quot;</span><span class="p">,</span><span class="mi">60</span><span class="p">,</span><span class="o">-</span><span class="mf">3.0</span><span class="p">,</span><span class="mf">3.0</span><span class="p">);</span>
  <span class="n">TH1D</span> <span class="o">*</span><span class="n">h1</span><span class="o">=</span><span class="k">new</span> <span class="n">TH1D</span><span class="p">(</span><span class="s">&quot;h1&quot;</span><span class="p">,</span><span class="s">&quot;&quot;</span><span class="p">,</span><span class="mi">60</span><span class="p">,</span><span class="o">-</span><span class="mf">3.0</span><span class="p">,</span><span class="mf">3.0</span><span class="p">);</span>
  <span class="n">TRandom</span> <span class="o">*</span><span class="n">r</span> <span class="o">=</span><span class="k">new</span> <span class="n">TRandom</span><span class="p">();</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="mi">1000</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">h</span><span class="o">-&gt;</span><span class="n">Fill</span><span class="p">(</span><span class="n">r</span><span class="o">-&gt;</span><span class="n">Gaus</span><span class="p">());</span>
    <span class="n">h1</span><span class="o">-&gt;</span><span class="n">Fill</span><span class="p">(</span><span class="n">r</span><span class="o">-&gt;</span><span class="n">Gaus</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">));</span>
  <span class="p">}</span>
  <span class="n">h</span><span class="o">-&gt;</span><span class="n">Draw</span><span class="p">();</span>
  <span class="c1">// h1-&gt;Draw();</span>
  <span class="n">h1</span><span class="o">-&gt;</span><span class="n">Draw</span><span class="p">(</span><span class="s">&quot;same&quot;</span><span class="p">);</span>
</pre></div>
</div>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">//Double_t   *GetIntegral();</span>
<span class="c1">//Return a pointer to the array of bins integral.</span>
<span class="c1">//返回一个指向数组的指针，当前值为 bin 从 0到当前 bin 面积所占的比例。</span>
  <span class="kt">int</span> <span class="n">bin</span><span class="o">=</span><span class="mi">60</span><span class="p">;</span>
  <span class="n">TH1D</span> <span class="o">*</span><span class="n">h</span><span class="o">=</span><span class="k">new</span> <span class="n">TH1D</span><span class="p">(</span><span class="s">&quot;h&quot;</span><span class="p">,</span><span class="s">&quot;the title&quot;</span><span class="p">,</span><span class="n">bin</span><span class="p">,</span><span class="o">-</span><span class="mf">3.0</span><span class="p">,</span><span class="mf">3.0</span><span class="p">);</span>
  <span class="n">TRandom</span> <span class="o">*</span><span class="n">r</span> <span class="o">=</span><span class="k">new</span> <span class="n">TRandom</span><span class="p">();</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="mi">1000</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
    <span class="p">{</span>
      <span class="n">h</span><span class="o">-&gt;</span><span class="n">Fill</span><span class="p">(</span><span class="n">r</span><span class="o">-&gt;</span><span class="n">Gaus</span><span class="p">());</span>
    <span class="p">}</span>
  <span class="kt">double</span> <span class="o">*</span><span class="n">Integral</span><span class="p">;</span>
  <span class="n">Integral</span><span class="o">=</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">GetIntegral</span><span class="p">();</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">bin</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
    <span class="p">{</span>
      <span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">i</span><span class="o">&lt;&lt;</span><span class="s">&quot;  &quot;</span><span class="o">&lt;&lt;</span><span class="n">Integral</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">&lt;&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="n">h</span><span class="o">-&gt;</span><span class="n">Draw</span><span class="p">();</span>
</pre></div>
</div>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">//克隆直方图，这里的 Close 是新开辟一块内存空间存储新直方图的，克隆之后，原始直方图的修改或删除对克隆的直方图没有影响。而TH1D *hnew =h;这个只是将新建的对象指向 h 的地址。</span>
<span class="n">TH1D</span> <span class="o">*</span><span class="n">h</span><span class="o">=</span><span class="k">new</span> <span class="n">TH1D</span><span class="p">(</span><span class="s">&quot;h&quot;</span><span class="p">,</span><span class="s">&quot;the title&quot;</span><span class="p">,</span><span class="mi">60</span><span class="p">,</span><span class="o">-</span><span class="mf">3.0</span><span class="p">,</span><span class="mf">3.0</span><span class="p">);</span>
<span class="n">TRandom</span> <span class="o">*</span><span class="n">r</span> <span class="o">=</span><span class="k">new</span> <span class="n">TRandom</span><span class="p">();</span>
<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="mi">1000</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">h</span><span class="o">-&gt;</span><span class="n">Fill</span><span class="p">(</span><span class="n">r</span><span class="o">-&gt;</span><span class="n">Gaus</span><span class="p">());</span>
<span class="p">}</span>
<span class="n">TH1D</span> <span class="o">*</span><span class="n">hnew</span> <span class="o">=</span> <span class="p">(</span><span class="n">TH1D</span><span class="o">*</span><span class="p">)</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">Clone</span><span class="p">(</span><span class="s">&quot;hnew&quot;</span><span class="p">);</span>
<span class="c1">// TH1D *hnew =h;</span>
<span class="n">h</span><span class="o">-&gt;</span><span class="n">Reset</span><span class="p">();</span>
<span class="n">hnew</span><span class="o">-&gt;</span><span class="n">Draw</span><span class="p">();</span>
</pre></div>
</div>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// virtual TH1     *Rebin(Int_t ngroup=2, const char*newname=&quot;&quot;, const Double_t *xbins=0);</span>

<span class="c1">/// examples: if h1 is an existing TH1F histogram with 100 bins</span>
<span class="n">h1</span><span class="o">-&gt;</span><span class="n">Rebin</span><span class="p">();</span>  <span class="c1">//merges two bins in one in h1: previous contents of h1 are lost</span>
<span class="n">h1</span><span class="o">-&gt;</span><span class="n">Rebin</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span> <span class="c1">//merges five bins in one in h1</span>
<span class="n">TH1F</span> <span class="o">*</span><span class="n">hnew</span> <span class="o">=</span> <span class="n">h1</span><span class="o">-&gt;</span><span class="n">Rebin</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="s">&quot;hnew&quot;</span><span class="p">);</span> <span class="c1">// creates a new histogram hnew  merging 5 bins of h1 in one bin</span>

<span class="c1">/// examples: if h1 is an existing TH1F histogram with 100 bins</span>
<span class="n">Double_t</span> <span class="n">xbins</span><span class="p">[</span><span class="mi">25</span><span class="p">]</span> <span class="o">=</span> <span class="p">{...}</span> <span class="c1">//array of low-edges (xbins[25] is the upper edge of last bin</span>
<span class="n">h1</span><span class="o">-&gt;</span><span class="n">Rebin</span><span class="p">(</span><span class="mi">24</span><span class="p">,</span><span class="s">&quot;hnew&quot;</span><span class="p">,</span><span class="n">xbins</span><span class="p">);</span>  <span class="c1">//creates a new variable bin size histogram hnew</span>
</pre></div>
</div>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// virtual Long64_t Merge(TCollection *list);</span>
<span class="kt">void</span> <span class="nf">atest</span><span class="p">()</span> <span class="p">{</span>
<span class="n">TH1F</span> <span class="o">*</span><span class="n">h1</span> <span class="o">=</span> <span class="k">new</span> <span class="n">TH1F</span><span class="p">(</span><span class="s">&quot;h1&quot;</span><span class="p">,</span><span class="s">&quot;h1&quot;</span><span class="p">,</span><span class="mi">110</span><span class="p">,</span><span class="o">-</span><span class="mi">110</span><span class="p">,</span><span class="mi">0</span><span class="p">);</span>
<span class="n">TH1F</span> <span class="o">*</span><span class="n">h2</span> <span class="o">=</span> <span class="k">new</span> <span class="n">TH1F</span><span class="p">(</span><span class="s">&quot;h2&quot;</span><span class="p">,</span><span class="s">&quot;h2&quot;</span><span class="p">,</span><span class="mi">220</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">110</span><span class="p">);</span>
<span class="n">TH1F</span> <span class="o">*</span><span class="n">h3</span> <span class="o">=</span> <span class="k">new</span> <span class="n">TH1F</span><span class="p">(</span><span class="s">&quot;h3&quot;</span><span class="p">,</span><span class="s">&quot;h3&quot;</span><span class="p">,</span><span class="mi">330</span><span class="p">,</span><span class="o">-</span><span class="mi">55</span><span class="p">,</span><span class="mi">55</span><span class="p">);</span>
<span class="n">TRandom</span> <span class="n">r</span><span class="p">;</span>
<span class="k">for</span> <span class="p">(</span><span class="n">Int_t</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="mi">10000</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">h1</span><span class="o">-&gt;</span><span class="n">Fill</span><span class="p">(</span><span class="n">r</span><span class="p">.</span><span class="n">Gaus</span><span class="p">(</span><span class="o">-</span><span class="mi">55</span><span class="p">,</span><span class="mi">10</span><span class="p">));</span>
  <span class="n">h2</span><span class="o">-&gt;</span><span class="n">Fill</span><span class="p">(</span><span class="n">r</span><span class="p">.</span><span class="n">Gaus</span><span class="p">(</span><span class="mi">55</span><span class="p">,</span><span class="mi">10</span><span class="p">));</span>
  <span class="n">h3</span><span class="o">-&gt;</span><span class="n">Fill</span><span class="p">(</span><span class="n">r</span><span class="p">.</span><span class="n">Gaus</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">10</span><span class="p">));</span>
<span class="p">}</span>
<span class="c1">///</span>
<span class="n">TList</span> <span class="o">*</span><span class="n">list</span> <span class="o">=</span> <span class="k">new</span> <span class="n">TList</span><span class="p">;</span>
<span class="n">list</span><span class="o">-&gt;</span><span class="n">Add</span><span class="p">(</span><span class="n">h1</span><span class="p">);</span>
<span class="n">list</span><span class="o">-&gt;</span><span class="n">Add</span><span class="p">(</span><span class="n">h2</span><span class="p">);</span>
<span class="n">list</span><span class="o">-&gt;</span><span class="n">Add</span><span class="p">(</span><span class="n">h3</span><span class="p">);</span>
<span class="n">TH1F</span> <span class="o">*</span><span class="n">h</span> <span class="o">=</span> <span class="p">(</span><span class="n">TH1F</span><span class="o">*</span><span class="p">)</span><span class="n">h1</span><span class="o">-&gt;</span><span class="n">Clone</span><span class="p">(</span><span class="s">&quot;h&quot;</span><span class="p">);</span>
<span class="n">h</span><span class="o">-&gt;</span><span class="n">Reset</span><span class="p">();</span>
<span class="n">h</span><span class="o">-&gt;</span><span class="n">Merge</span><span class="p">(</span><span class="n">list</span><span class="p">);</span>
<span class="n">h</span><span class="o">-&gt;</span><span class="n">Draw</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// virtual Int_t    GetQuantiles(Int_t nprobSum, Double_t *q, const Double_t *probSum=0);</span>
<span class="n">Getting</span> <span class="n">quantiles</span> <span class="n">q</span> <span class="n">from</span> <span class="n">two</span> <span class="n">histograms</span> <span class="n">and</span> <span class="n">storing</span> <span class="n">results</span> <span class="n">in</span> <span class="n">a</span> <span class="n">TGraph</span><span class="p">,</span> <span class="n">a</span> <span class="n">so</span><span class="o">-</span><span class="n">called</span> <span class="n">QQ</span><span class="o">-</span><span class="n">plot</span>
<span class="n">TGraph</span> <span class="o">*</span><span class="n">gr</span> <span class="o">=</span> <span class="k">new</span> <span class="n">TGraph</span><span class="p">(</span><span class="n">nprob</span><span class="p">);</span>
<span class="n">h1</span><span class="o">-&gt;</span><span class="n">GetQuantiles</span><span class="p">(</span><span class="n">nprob</span><span class="p">,</span><span class="n">gr</span><span class="o">-&gt;</span><span class="n">GetX</span><span class="p">());</span>
<span class="n">h2</span><span class="o">-&gt;</span><span class="n">GetQuantiles</span><span class="p">(</span><span class="n">nprob</span><span class="p">,</span><span class="n">gr</span><span class="o">-&gt;</span><span class="n">GetY</span><span class="p">());</span>
<span class="n">gr</span><span class="o">-&gt;</span><span class="n">Draw</span><span class="p">(</span><span class="s">&quot;alp&quot;</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">quantiles</span><span class="p">()</span> <span class="p">{</span>
   <span class="c1">// demo for quantiles</span>
   <span class="k">const</span> <span class="n">Int_t</span> <span class="n">nq</span> <span class="o">=</span> <span class="mi">20</span><span class="p">;</span>
   <span class="n">TH1F</span> <span class="o">*</span><span class="n">h</span> <span class="o">=</span> <span class="k">new</span> <span class="n">TH1F</span><span class="p">(</span><span class="s">&quot;h&quot;</span><span class="p">,</span><span class="s">&quot;demo quantiles&quot;</span><span class="p">,</span><span class="mi">100</span><span class="p">,</span><span class="o">-</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">);</span>
   <span class="n">h</span><span class="o">-&gt;</span><span class="n">FillRandom</span><span class="p">(</span><span class="s">&quot;gaus&quot;</span><span class="p">,</span><span class="mi">5000</span><span class="p">);</span>
<span class="c1">///</span>
   <span class="n">Double_t</span> <span class="n">xq</span><span class="p">[</span><span class="n">nq</span><span class="p">];</span>  <span class="c1">// position where to compute the quantiles in [0,1]</span>
   <span class="n">Double_t</span> <span class="n">yq</span><span class="p">[</span><span class="n">nq</span><span class="p">];</span>  <span class="c1">// array to contain the quantiles</span>
   <span class="k">for</span> <span class="p">(</span><span class="n">Int_t</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">nq</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="n">xq</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">Float_t</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="n">nq</span><span class="p">;</span>
   <span class="n">h</span><span class="o">-&gt;</span><span class="n">GetQuantiles</span><span class="p">(</span><span class="n">nq</span><span class="p">,</span><span class="n">yq</span><span class="p">,</span><span class="n">xq</span><span class="p">);</span>
<span class="c1">///</span>
   <span class="c1">//show the original histogram in the top pad</span>
   <span class="n">TCanvas</span> <span class="o">*</span><span class="n">c1</span> <span class="o">=</span> <span class="k">new</span> <span class="n">TCanvas</span><span class="p">(</span><span class="s">&quot;c1&quot;</span><span class="p">,</span><span class="s">&quot;demo quantiles&quot;</span><span class="p">,</span><span class="mi">10</span><span class="p">,</span><span class="mi">10</span><span class="p">,</span><span class="mi">700</span><span class="p">,</span><span class="mi">900</span><span class="p">);</span>
   <span class="n">c1</span><span class="o">-&gt;</span><span class="n">Divide</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">);</span>
   <span class="n">c1</span><span class="o">-&gt;</span><span class="n">cd</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
   <span class="n">h</span><span class="o">-&gt;</span><span class="n">Draw</span><span class="p">();</span>
<span class="c1">///</span>
   <span class="c1">// show the quantiles in the bottom pad</span>
   <span class="n">c1</span><span class="o">-&gt;</span><span class="n">cd</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
   <span class="n">gPad</span><span class="o">-&gt;</span><span class="n">SetGrid</span><span class="p">();</span>
   <span class="n">TGraph</span> <span class="o">*</span><span class="n">gr</span> <span class="o">=</span> <span class="k">new</span> <span class="n">TGraph</span><span class="p">(</span><span class="n">nq</span><span class="p">,</span><span class="n">xq</span><span class="p">,</span><span class="n">yq</span><span class="p">);</span>
   <span class="n">gr</span><span class="o">-&gt;</span><span class="n">SetMarkerStyle</span><span class="p">(</span><span class="mi">21</span><span class="p">);</span>
   <span class="n">gr</span><span class="o">-&gt;</span><span class="n">Draw</span><span class="p">(</span><span class="s">&quot;alp&quot;</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// virtual TFitResultPtr    Fit(TF1 *f1 ,Option_t *option=&quot;&quot; ,Option_t *goption=&quot;&quot;, Double_t xmin=0, Double_t xmax=0);</span>

<span class="c1">/// In order to use the Range option, one must first create a function</span>
<span class="c1">/// with the expression to be fitted. For example, if your histogram</span>
<span class="c1">/// has a defined range between -4 and 4 and you want to fit a gaussian</span>
<span class="c1">/// only in the interval 1 to 3, you can do:</span>
<span class="n">TF1</span> <span class="o">*</span><span class="n">f1</span> <span class="o">=</span> <span class="k">new</span> <span class="n">TF1</span><span class="p">(</span><span class="s">&quot;f1&quot;</span><span class="p">,</span> <span class="s">&quot;gaus&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>
<span class="n">histo</span><span class="o">-&gt;</span><span class="n">Fit</span><span class="p">(</span><span class="s">&quot;f1&quot;</span><span class="p">,</span> <span class="s">&quot;R&quot;</span><span class="p">);</span>

<span class="c1">/// You can specify boundary limits for some or all parameters via</span>
<span class="n">f1</span><span class="o">-&gt;</span><span class="n">SetParLimits</span><span class="p">(</span><span class="n">p_number</span><span class="p">,</span> <span class="n">parmin</span><span class="p">,</span> <span class="n">parmax</span><span class="p">);</span>
<span class="c1">/// if parmin&gt;=parmax, the parameter is fixed</span>
<span class="c1">/// Note that you are not forced to fix the limits for all parameters.</span>
<span class="c1">/// For example, if you fit a function with 6 parameters, you can do:</span>
<span class="n">func</span><span class="o">-&gt;</span><span class="n">SetParameters</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mf">3.1</span><span class="p">,</span> <span class="mf">1.e-6</span><span class="p">,</span> <span class="o">-</span><span class="mi">8</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">100</span><span class="p">);</span>
<span class="n">func</span><span class="o">-&gt;</span><span class="n">SetParLimits</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="o">-</span><span class="mi">10</span><span class="p">,</span> <span class="o">-</span><span class="mi">4</span><span class="p">);</span>
<span class="n">func</span><span class="o">-&gt;</span><span class="n">FixParameter</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="n">func</span><span class="o">-&gt;</span><span class="n">SetParLimits</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="c1">/// With this setup, parameters 0-&gt;2 can vary freely</span>
<span class="c1">/// Parameter 3 has boundaries [-10,-4] with initial value -8</span>
<span class="c1">/// Parameter 4 is fixed to 0</span>
<span class="c1">/// Parameter 5 is fixed to 100.</span>
<span class="c1">/// When the lower limit and upper limit are equal, the parameter is fixed.</span>
<span class="c1">/// However to fix a parameter to 0, one must call the FixParameter function.</span>


<span class="c1">/// If the option &quot;S&quot; is instead used, TFitResultPtr contains the TFitResult and behaves as a smart</span>
<span class="c1">/// pointer to it. For example one can do:</span>
<span class="n">TFitResultPtr</span> <span class="n">r</span> <span class="o">=</span> <span class="n">h</span><span class="o">-&gt;</span><span class="n">Fit</span><span class="p">(</span><span class="n">myFunc</span><span class="p">,</span><span class="s">&quot;S&quot;</span><span class="p">);</span>
<span class="n">TMatrixDSym</span> <span class="n">cov</span> <span class="o">=</span> <span class="n">r</span><span class="o">-&gt;</span><span class="n">GetCovarianceMatrix</span><span class="p">();</span>  <span class="c1">//  to access the covariance matrix</span>
<span class="n">Double_t</span> <span class="n">chi2</span>   <span class="o">=</span> <span class="n">r</span><span class="o">-&gt;</span><span class="n">Chi2</span><span class="p">();</span> <span class="c1">// to retrieve the fit chi2</span>
<span class="n">Double_t</span> <span class="n">par0</span>   <span class="o">=</span> <span class="n">r</span><span class="o">-&gt;</span><span class="n">Parameter</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span> <span class="c1">// retrieve the value for the parameter 0</span>
<span class="n">Double_t</span> <span class="n">err0</span>   <span class="o">=</span> <span class="n">r</span><span class="o">-&gt;</span><span class="n">ParError</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span> <span class="c1">// retrieve the error for the parameter 0</span>
<span class="n">r</span><span class="o">-&gt;</span><span class="n">Print</span><span class="p">(</span><span class="s">&quot;V&quot;</span><span class="p">);</span>     <span class="c1">// print full information of fit including covariance matrix</span>
<span class="n">r</span><span class="o">-&gt;</span><span class="n">Write</span><span class="p">();</span>        <span class="c1">// store the result in a file</span>

<span class="c1">/// The fit parameters, error and chi2 (but not covariance matrix) can be retrieved also</span>
<span class="c1">/// from the fitted function.</span>
<span class="c1">/// If the histogram is made persistent, the list of</span>
<span class="c1">/// associated functions is also persistent. Given a pointer (see above)</span>
<span class="c1">/// to an associated function myfunc, one can retrieve the function/fit</span>
<span class="c1">/// parameters with calls such as:</span>

<span class="n">Double_t</span> <span class="n">chi2</span> <span class="o">=</span> <span class="n">myfunc</span><span class="o">-&gt;</span><span class="n">GetChisquare</span><span class="p">();</span>
<span class="n">Double_t</span> <span class="n">par0</span> <span class="o">=</span> <span class="n">myfunc</span><span class="o">-&gt;</span><span class="n">GetParameter</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span> <span class="c1">//value of 1st parameter</span>
<span class="n">Double_t</span> <span class="n">err0</span> <span class="o">=</span> <span class="n">myfunc</span><span class="o">-&gt;</span><span class="n">GetParError</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>  <span class="c1">//error on first parameter</span>

<span class="c1">/// The status of the fit can be obtained converting the TFitResultPtr to an integer</span>
<span class="c1">/// independently if the fit option &quot;S&quot; is used or not:</span>
<span class="n">TFitResultPtr</span> <span class="n">r</span> <span class="o">=</span> <span class="n">h</span><span class="o">-&gt;</span><span class="n">Fit</span><span class="p">(</span><span class="n">myFunc</span><span class="p">,</span><span class="n">opt</span><span class="p">);</span>
<span class="n">Int_t</span> <span class="n">fitStatus</span> <span class="o">=</span> <span class="n">r</span><span class="p">;</span>
<span class="c1">/// The fitStatus is 0 if the fit is OK (i.e no error occurred).</span>
<span class="c1">/// The value of the fit status code is negative in case of an error not connected with the</span>
<span class="c1">/// minimization procedure, for example  when a wrong function is used.</span>
<span class="c1">/// Otherwise the return value is the one returned from the minimization procedure.</span>

<span class="c1">/// ## Excluding points</span>
<span class="c1">/// Use TF1::RejectPoint inside your fitting function to exclude points</span>
<span class="c1">/// within a certain range from the fit. Example:</span>
    <span class="n">Double_t</span> <span class="nf">fline</span><span class="p">(</span><span class="n">Double_t</span> <span class="o">*</span><span class="n">x</span><span class="p">,</span> <span class="n">Double_t</span> <span class="o">*</span><span class="n">par</span><span class="p">)</span>
    <span class="p">{</span>
       <span class="k">if</span> <span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mf">2.5</span> <span class="o">&amp;&amp;</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mf">3.5</span><span class="p">)</span> <span class="p">{</span>
          <span class="n">TF1</span><span class="o">::</span><span class="n">RejectPoint</span><span class="p">();</span>
          <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
       <span class="p">}</span>
       <span class="k">return</span> <span class="n">par</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">par</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="nf">exclude</span><span class="p">()</span> <span class="p">{</span>
       <span class="n">TF1</span> <span class="o">*</span><span class="n">f1</span> <span class="o">=</span> <span class="k">new</span> <span class="n">TF1</span><span class="p">(</span><span class="s">&quot;f1&quot;</span><span class="p">,</span> <span class="s">&quot;[0] +[1]*x +gaus(2)&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">5</span><span class="p">);</span>
       <span class="n">f1</span><span class="o">-&gt;</span><span class="n">SetParameters</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">);</span>
       <span class="n">TH1F</span> <span class="o">*</span><span class="n">h</span> <span class="o">=</span> <span class="k">new</span> <span class="n">TH1F</span><span class="p">(</span><span class="s">&quot;h&quot;</span><span class="p">,</span> <span class="s">&quot;background + signal&quot;</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">5</span><span class="p">);</span>
       <span class="n">h</span><span class="o">-&gt;</span><span class="n">FillRandom</span><span class="p">(</span><span class="s">&quot;f1&quot;</span><span class="p">,</span> <span class="mi">2000</span><span class="p">);</span>
       <span class="n">TF1</span> <span class="o">*</span><span class="n">fline</span> <span class="o">=</span> <span class="k">new</span> <span class="n">TF1</span><span class="p">(</span><span class="s">&quot;fline&quot;</span><span class="p">,</span> <span class="n">fline</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
       <span class="n">fline</span><span class="o">-&gt;</span><span class="n">SetParameters</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>
       <span class="n">h</span><span class="o">-&gt;</span><span class="n">Fit</span><span class="p">(</span><span class="s">&quot;fline&quot;</span><span class="p">,</span> <span class="s">&quot;l&quot;</span><span class="p">);</span>
    <span class="p">}</span>

<span class="c1">/// ## Warning when using the option &quot;0&quot;</span>
<span class="c1">/// When selecting the option &quot;0&quot;, the fitted function is added to</span>
<span class="c1">/// the list of functions of the histogram, but it is not drawn.</span>
<span class="c1">/// You can undo what you disabled in the following way:</span>
<span class="n">h</span><span class="p">.</span><span class="n">Fit</span><span class="p">(</span><span class="s">&quot;myFunction&quot;</span><span class="p">,</span> <span class="s">&quot;0&quot;</span><span class="p">);</span> <span class="c1">// fit, store function but do not draw</span>
<span class="n">h</span><span class="p">.</span><span class="n">Draw</span><span class="p">();</span> <span class="n">function</span> <span class="n">is</span> <span class="n">not</span> <span class="n">drawn</span>
<span class="k">const</span> <span class="n">Int_t</span> <span class="n">kNotDraw</span> <span class="o">=</span> <span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">9</span><span class="p">;</span>
<span class="n">h</span><span class="p">.</span><span class="n">GetFunction</span><span class="p">(</span><span class="s">&quot;myFunction&quot;</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">ResetBit</span><span class="p">(</span><span class="n">kNotDraw</span><span class="p">);</span>
<span class="n">h</span><span class="p">.</span><span class="n">Draw</span><span class="p">();</span>  <span class="c1">// function is visible again</span>
</pre></div>
</div>
</div>
<div class="section" id="example">
<h2>example<a class="headerlink" href="#example" title="永久链接至标题">¶</a></h2>
<!-- ```cpp --><!-- ``` --><!-- TH1.md ends here --></div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="TH2.html" class="btn btn-neutral float-right" title="TH2" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="TGraphPolar.html" class="btn btn-neutral float-left" title="TGraphPolar" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2020, Hongyi Wu(吴鸿毅)

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>